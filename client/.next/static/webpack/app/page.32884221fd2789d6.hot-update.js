"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/util/DrawingAnalytics.ts":
/*!**************************************!*\
  !*** ./src/util/DrawingAnalytics.ts ***!
  \**************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var object_sizeof__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! object-sizeof */ \"(app-pages-browser)/../node_modules/object-sizeof/indexv2.js\");\n/* harmony import */ var object_sizeof__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(object_sizeof__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _AnalyticsLocalStorageManager__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./AnalyticsLocalStorageManager */ \"(app-pages-browser)/./src/util/AnalyticsLocalStorageManager.ts\");\n\n\nclass DrawingAnalytics {\n    generateId() {\n        return \"\".concat(Date.now(), \"-\").concat(Math.random().toString(36).substr(2, 9));\n    }\n    loadFromStorage() {\n        // Load existing data if any (useful for page refreshes)\n        const existingBehavior = this.storage.getUserBehavior();\n        if (existingBehavior && existingBehavior.sessionId === this.sessionId) {\n            this.userBehavior = existingBehavior;\n        }\n    }\n    initializeUserBehavior() {\n        return {\n            sessionId: this.sessionId,\n            userId: this.userId,\n            sessionStart: Date.now(),\n            totalStrokes: 0,\n            averageStrokeLength: 0,\n            mostUsedTool: '',\n            mostUsedColor: '',\n            totalDrawingTime: 0,\n            idleTime: 0,\n            undoCount: 0,\n            redoCount: 0,\n            canvasClearCount: 0\n        };\n    }\n    startPeriodicSync(intervalMs) {\n        console.log('startPeriodicSync');\n        this.syncTimer = setInterval(async ()=>{\n            await this.syncNow();\n        }, intervalMs);\n    }\n    // Manual sync trigger\n    async syncNow() {\n        console.log('Starting analytics sync...');\n        // Queue current session data\n        this.storage.queueForSync(this.sessionId);\n        // Try to sync all queued data\n        const syncQueue = this.storage.getSyncQueue();\n        let syncedCount = 0;\n        // todo send to the backend\n        // for (const payload of syncQueue) {\n        // if (success) {\n        // \tthis.storage.clearSyncedData(payload.timestamp);\n        // \tsyncedCount++;\n        // } else {\n        // \tbreak; // Stop on first failure to maintain order\n        // }\n        // }\n        if (syncedCount > 0) {\n            console.log(\"Synced \".concat(syncedCount, \" analytics payloads\"));\n            // Clear local data after successful sync\n            this.storage.clearLocalData();\n            return true;\n        }\n        return false;\n    }\n    // Enhanced drawing event logging with comprehensive data\n    logDrawingEvent(eventType) {\n        let data = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n        const eventId = this.generateId();\n        const timestamp = Date.now();\n        const event = {\n            eventId,\n            timestamp,\n            eventType,\n            sessionId: this.sessionId,\n            userId: this.userId,\n            ...data\n        };\n        this.events.push(event);\n        this.updateUserBehavior(event);\n        this.lastActivity = timestamp;\n        // Log to console with structured format\n        // console.group(`Drawing Event: ${eventType}`);\n        // console.log('Event ID:', eventId);\n        // console.log('Timestamp:', new Date(timestamp).toISOString());\n        // console.log('Data:', data);\n        console.groupEnd();\n        this.storage.appendData(this.storage.STORAGE_KEYS.EVENTS, event);\n        return eventId;\n    }\n    // Enhanced network logging with quality assessment\n    logNetworkEvent(eventId, startTime, acknowledged, payloadSize) {\n        let retryCount = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 0;\n        const rtt = performance.now() - startTime;\n        const connectionQuality = this.assessConnectionQuality(rtt);\n        const networkMetric1 = {\n            eventId,\n            timestamp: Date.now(),\n            rtt,\n            acknowledged,\n            retryCount,\n            payloadSize,\n            connectionQuality\n        };\n        this.networkMetrics.push(networkMetric1);\n        // console.group(`Network Event`);\n        // console.log('Event ID:', eventId);\n        // console.log('RTT:', `${rtt.toFixed(2)}ms`);\n        // console.log('Quality:', connectionQuality);\n        // console.log('Payload Size:', `${payloadSize} bytes`);\n        // console.log('Acknowledged:', acknowledged);\n        this.storage.appendData(this.storage.STORAGE_KEYS.NETWORK, networkMetric1);\n        if (retryCount > 0) console.warn('Retry Count:', retryCount);\n        console.groupEnd();\n    }\n    assessConnectionQuality(rtt) {\n        if (rtt < 50) return 'excellent';\n        if (rtt < 100) return 'good';\n        if (rtt < 200) return 'fair';\n        if (rtt < 500) return 'decent';\n        return 'poor';\n    }\n    // Performance monitoring\n    startPerformanceMonitoring() {\n        if ( false || typeof requestAnimationFrame === 'undefined') {\n            console.warn('Performance monitoring not available in this environment');\n            return;\n        }\n        const monitor = ()=>{\n            const now = performance.now();\n            const deltaTime = now - this.lastFPSCheck;\n            if (deltaTime >= 1000) {\n                var _performance_memory;\n                // if its been a second\n                const fps = this.frameCount * 1000 / deltaTime;\n                const memoryUsage = ((_performance_memory = performance.memory) === null || _performance_memory === void 0 ? void 0 : _performance_memory.usedJSHeapSize) || 0;\n                const perfMetric = {\n                    timestamp: Date.now(),\n                    fps: Math.round(fps),\n                    memoryUsage,\n                    canvasRenderTime: 0,\n                    eventProcessingTime: 0,\n                    queuedEvents: this.eventQueue.length\n                };\n                this.performanceMetrics.push(perfMetric);\n                this.frameCount = 0;\n                this.lastFPSCheck = now;\n                // Log performance warnings\n                if (fps < 30) {\n                    console.warn(\"Low FPS detected: \".concat(fps.toFixed(1)));\n                }\n                if (this.eventQueue.length > 10) {\n                    console.warn(\"Event queue backlog: \".concat(this.eventQueue.length, \" events\"));\n                }\n            }\n            this.frameCount++;\n            this.storage.appendData(this.storage.STORAGE_KEYS.NETWORK, networkMetric);\n            requestAnimationFrame(monitor);\n        };\n        requestAnimationFrame(monitor);\n    }\n    // Update user behavior metrics\n    updateUserBehavior(event) {\n        switch(event.eventType){\n            case 'stroke_start':\n                this.userBehavior.totalStrokes++;\n                this.currentStrokeStart = event.timestamp;\n                break;\n            case 'stroke_end':\n                if (this.currentStrokeStart) {\n                    const strokeDuration = event.timestamp - this.currentStrokeStart;\n                    this.userBehavior.totalDrawingTime += strokeDuration;\n                }\n                break;\n            case 'undo':\n                this.userBehavior.undoCount++;\n                break;\n            case 'redo':\n                this.userBehavior.redoCount++;\n                break;\n            case 'canvas_clear':\n                this.userBehavior.canvasClearCount++;\n                break;\n        }\n    }\n    // Enhanced socket emission with comprehensive logging\n    emitWithLogging(socket, eventName, data) {\n        let options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};\n        return new Promise((resolve)=>{\n            const startTime = performance.now();\n            const eventId = this.logDrawingEvent('stroke_continue', data);\n            const payloadSize = object_sizeof__WEBPACK_IMPORTED_MODULE_0___default()(data);\n            let retryCount = 0;\n            const maxRetries = options.retryCount || 3;\n            const attempt = ()=>{\n                socket.emit(eventName, data, (ack)=>{\n                    this.logNetworkEvent(eventId, startTime, ack, payloadSize, retryCount);\n                    if (ack) {\n                        resolve(true);\n                    } else if (retryCount < maxRetries) {\n                        retryCount++;\n                        console.warn(\"Retrying event \".concat(eventId, \" (attempt \").concat(retryCount, \"/\").concat(maxRetries, \")\"));\n                        setTimeout(attempt, 100 * retryCount); // Exponential backoff\n                    } else {\n                        console.error(\"Event \".concat(eventId, \" failed after \").concat(maxRetries, \" retries\"));\n                        resolve(false);\n                    }\n                });\n            };\n            attempt();\n        });\n    }\n    // Data export and analysis methods\n    exportAnalytics() {\n        return {\n            session: this.userBehavior,\n            events: this.events,\n            network: this.networkMetrics,\n            performance: this.performanceMetrics,\n            summary: this.generateSummary()\n        };\n    }\n    generateSummary() {\n        const totalEvents = this.events.length;\n        const avgRTT = this.networkMetrics.reduce((sum, m)=>sum + m.rtt, 0) / this.networkMetrics.length || 0;\n        const acknowledgedMessages = this.networkMetrics.filter((m)=>m.acknowledged);\n        const nackMessages = this.networkMetrics.filter((m)=>!m.acknowledged);\n        const failedDataSend = nackMessages.reduce((sum, i)=>sum + i.payloadSize, 0);\n        const successRate = acknowledgedMessages.length / this.networkMetrics.length * 100 || 0;\n        const totalDataSend = acknowledgedMessages.reduce((sum, i)=>sum + i.payloadSize, 0);\n        const totalDataAttempted = totalDataSend + failedDataSend;\n        const dataEfficiencyRate = totalDataSend / totalDataAttempted * 100;\n        const avgSuccessfulPayloadSize = totalDataSend / acknowledgedMessages.length;\n        const avgFailedPayloadSize = failedDataSend / nackMessages.length;\n        const avgFPS = this.performanceMetrics.reduce((sum, m)=>sum + m.fps, 0) / this.performanceMetrics.length || 0;\n        return {\n            totalEvents,\n            avgRTT: Math.round(avgRTT * 100) / 100,\n            successRate: Math.round(successRate * 100) / 100,\n            avgFPS: Math.round(avgFPS),\n            totalDataSend: Math.round(totalDataSend),\n            dataEfficiencyRate: Math.round(dataEfficiencyRate),\n            avgSuccessfulPayloadSize: Math.round(avgSuccessfulPayloadSize),\n            avgFailedPayloadSize: Math.round(avgFailedPayloadSize),\n            sessionDuration: Date.now() - this.userBehavior.sessionStart,\n            networkQualityDistribution: this.getNetworkQualityDistribution()\n        };\n    }\n    getNetworkQualityDistribution() {\n        const distribution = {\n            excellent: 0,\n            good: 0,\n            fair: 0,\n            poor: 0,\n            decent: 0\n        };\n        this.networkMetrics.forEach((metric)=>{\n            distribution[metric.connectionQuality]++;\n        });\n        return distribution;\n    }\n    // Real-time monitoring dashboard (console-based)\n    startRealtimeMonitoring() {\n        let intervalMs = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 5000;\n        setInterval(()=>{\n            const summary = this.generateSummary();\n            console.log('Session Duration:', \"\".concat(Math.round(summary.sessionDuration / 1000), \"s\"));\n            console.log('local storage', this.storage.getStorageInfo());\n            // console.log('Total Events:', summary.totalEvents);\n            // console.log('Average RTT:', `${summary.avgRTT}ms`);\n            // console.log('Success Rate:', `${summary.successRate}%`);\n            // console.log('Average FPS:', summary.avgFPS);\n            // console.log('Network Quality:', summary.networkQualityDistribution);\n            console.groupEnd();\n        }, intervalMs);\n    }\n    // Cleanup\n    destroy() {\n        if (this.syncTimer) {\n            clearInterval(this.syncTimer);\n        }\n        this.syncNow(); // Final sync\n    }\n    constructor(userId, intervalMs = 30000){\n        this.events = [];\n        this.networkMetrics = [];\n        this.performanceMetrics = [];\n        this.lastActivity = Date.now();\n        this.frameCount = 0;\n        this.lastFPSCheck = performance.now();\n        this.eventQueue = [];\n        this.sessionId = this.generateId();\n        this.userId = userId;\n        this.userBehavior = this.initializeUserBehavior();\n        this.storage = new _AnalyticsLocalStorageManager__WEBPACK_IMPORTED_MODULE_1__[\"default\"]();\n        this.startPerformanceMonitoring();\n        this.startPeriodicSync(intervalMs);\n        // Load existing data from localStorage\n        this.loadFromStorage();\n        // Sync on page unload\n        window.addEventListener('beforeunload', ()=>{\n            this.syncNow();\n        });\n    }\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (DrawingAnalytics);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy91dGlsL0RyYXdpbmdBbmFseXRpY3MudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFtQztBQUN1QztBQXVEMUUsTUFBTUU7SUErQkdDLGFBQXFCO1FBQzVCLE9BQU8sR0FBaUJDLE9BQWRDLEtBQUtDLEdBQUcsSUFBRyxLQUEyQyxPQUF4Q0YsS0FBS0csTUFBTSxHQUFHQyxRQUFRLENBQUMsSUFBSUMsTUFBTSxDQUFDLEdBQUc7SUFDOUQ7SUFFUUMsa0JBQXdCO1FBQy9CLHdEQUF3RDtRQUN4RCxNQUFNQyxtQkFBbUIsSUFBSSxDQUFDQyxPQUFPLENBQUNDLGVBQWU7UUFDckQsSUFBSUYsb0JBQW9CQSxpQkFBaUJHLFNBQVMsS0FBSyxJQUFJLENBQUNBLFNBQVMsRUFBRTtZQUN0RSxJQUFJLENBQUNDLFlBQVksR0FBR0o7UUFDckI7SUFDRDtJQUVRSyx5QkFBOEM7UUFDckQsT0FBTztZQUNORixXQUFXLElBQUksQ0FBQ0EsU0FBUztZQUN6QkcsUUFBUSxJQUFJLENBQUNBLE1BQU07WUFDbkJDLGNBQWNiLEtBQUtDLEdBQUc7WUFDdEJhLGNBQWM7WUFDZEMscUJBQXFCO1lBQ3JCQyxjQUFjO1lBQ2RDLGVBQWU7WUFDZkMsa0JBQWtCO1lBQ2xCQyxVQUFVO1lBQ1ZDLFdBQVc7WUFDWEMsV0FBVztZQUNYQyxrQkFBa0I7UUFDbkI7SUFDRDtJQUVRQyxrQkFBa0JDLFVBQWtCLEVBQVE7UUFDbkRDLFFBQVFDLEdBQUcsQ0FBQztRQUVaLElBQUksQ0FBQ0MsU0FBUyxHQUFHQyxZQUFZO1lBQzVCLE1BQU0sSUFBSSxDQUFDQyxPQUFPO1FBQ25CLEdBQUdMO0lBQ0o7SUFFQSxzQkFBc0I7SUFDdEIsTUFBTUssVUFBNEI7UUFDakNKLFFBQVFDLEdBQUcsQ0FBQztRQUVaLDZCQUE2QjtRQUM3QixJQUFJLENBQUNuQixPQUFPLENBQUN1QixZQUFZLENBQUMsSUFBSSxDQUFDckIsU0FBUztRQUV4Qyw4QkFBOEI7UUFDOUIsTUFBTXNC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QUVBLGlFQUFlaEMsZ0JBQWdCQSxFQUFDIiwic291cmNlcyI6WyIvVXNlcnMvZW1yZXlpbGRpcmltL0Rlc2t0b3AvZmluYWxQcm9qZWN0L2NsaWVudC9zcmMvdXRpbC9EcmF3aW5nQW5hbHl0aWNzLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBzaXplb2YgZnJvbSAnb2JqZWN0LXNpemVvZic7XG5pbXBvcnQgQW5hbHl0aWNzTG9jYWxTdG9yYWdlTWFuYWdlciBmcm9tICcuL0FuYWx5dGljc0xvY2FsU3RvcmFnZU1hbmFnZXInO1xuaW50ZXJmYWNlIERyYXdpbmdFdmVudCB7XG5cdGV2ZW50SWQ6IHN0cmluZztcblx0dGltZXN0YW1wOiBudW1iZXI7XG5cdGV2ZW50VHlwZTpcblx0XHR8ICdzdHJva2Vfc3RhcnQnXG5cdFx0fCAnc3Ryb2tlX2NvbnRpbnVlJ1xuXHRcdHwgJ3N0cm9rZV9lbmQnXG5cdFx0fCAnY2FudmFzX2NsZWFyJ1xuXHRcdHwgJ3VuZG8nXG5cdFx0fCAncmVkbyc7XG5cdHN0cm9rZUlkPzogc3RyaW5nO1xuXHRjb29yZGluYXRlcz86IHsgeDogbnVtYmVyOyB5OiBudW1iZXIgfTtcblx0cHJlc3N1cmU/OiBudW1iZXI7XG5cdHRvb2w/OiBzdHJpbmc7XG5cdGNvbG9yPzogc3RyaW5nO1xuXHRicnVzaFNpemU/OiBudW1iZXI7XG5cdHVzZXJJZD86IHN0cmluZztcblx0c2Vzc2lvbklkOiBzdHJpbmc7XG59XG5cbmludGVyZmFjZSBOZXR3b3JrTWV0cmljcyB7XG5cdGV2ZW50SWQ6IHN0cmluZztcblx0dGltZXN0YW1wOiBudW1iZXI7XG5cdHJ0dDogbnVtYmVyO1xuXHRhY2tub3dsZWRnZWQ6IGJvb2xlYW47XG5cdHJldHJ5Q291bnQ6IG51bWJlcjtcblx0cGF5bG9hZFNpemU6IG51bWJlcjtcblx0Y29ubmVjdGlvblF1YWxpdHk6ICdleGNlbGxlbnQnIHwgJ2dvb2QnIHwgJ2ZhaXInIHwgJ2RlY2VudCcgfCAncG9vcic7XG59XG5cbmludGVyZmFjZSBQZXJmb3JtYW5jZU1ldHJpY3Mge1xuXHR0aW1lc3RhbXA6IG51bWJlcjtcblx0ZnBzOiBudW1iZXI7XG5cdG1lbW9yeVVzYWdlOiBudW1iZXI7XG5cdGNhbnZhc1JlbmRlclRpbWU6IG51bWJlcjtcblx0ZXZlbnRQcm9jZXNzaW5nVGltZTogbnVtYmVyO1xuXHRxdWV1ZWRFdmVudHM6IG51bWJlcjtcbn1cblxuaW50ZXJmYWNlIFVzZXJCZWhhdmlvck1ldHJpY3Mge1xuXHRzZXNzaW9uSWQ6IHN0cmluZztcblx0dXNlcklkPzogc3RyaW5nO1xuXHRzZXNzaW9uU3RhcnQ6IG51bWJlcjtcblx0dG90YWxTdHJva2VzOiBudW1iZXI7XG5cdGF2ZXJhZ2VTdHJva2VMZW5ndGg6IG51bWJlcjtcblx0bW9zdFVzZWRUb29sOiBzdHJpbmc7XG5cdG1vc3RVc2VkQ29sb3I6IHN0cmluZztcblx0dG90YWxEcmF3aW5nVGltZTogbnVtYmVyO1xuXHRpZGxlVGltZTogbnVtYmVyO1xuXHR1bmRvQ291bnQ6IG51bWJlcjtcblx0cmVkb0NvdW50OiBudW1iZXI7XG5cdGNhbnZhc0NsZWFyQ291bnQ6IG51bWJlcjtcbn1cblxuY2xhc3MgRHJhd2luZ0FuYWx5dGljcyB7XG5cdHByaXZhdGUgc2Vzc2lvbklkOiBzdHJpbmc7XG5cdHByaXZhdGUgc3RvcmFnZTogQW5hbHl0aWNzTG9jYWxTdG9yYWdlTWFuYWdlcjtcblx0cHJpdmF0ZSB1c2VySWQ/OiBzdHJpbmc7XG5cdHByaXZhdGUgZXZlbnRzOiBEcmF3aW5nRXZlbnRbXSA9IFtdO1xuXHRwcml2YXRlIHN5bmNUaW1lcjogTm9kZUpTLlRpbWVvdXQ7XG5cdHByaXZhdGUgbmV0d29ya01ldHJpY3M6IE5ldHdvcmtNZXRyaWNzW10gPSBbXTtcblx0cHJpdmF0ZSBwZXJmb3JtYW5jZU1ldHJpY3M6IFBlcmZvcm1hbmNlTWV0cmljc1tdID0gW107XG5cdHByaXZhdGUgdXNlckJlaGF2aW9yOiBVc2VyQmVoYXZpb3JNZXRyaWNzO1xuXHRwcml2YXRlIGxhc3RBY3Rpdml0eTogbnVtYmVyID0gRGF0ZS5ub3coKTtcblx0cHJpdmF0ZSBjdXJyZW50U3Ryb2tlU3RhcnQ/OiBudW1iZXI7XG5cdHByaXZhdGUgZnJhbWVDb3VudCA9IDA7XG5cdHByaXZhdGUgbGFzdEZQU0NoZWNrID0gcGVyZm9ybWFuY2Uubm93KCk7XG5cdHByaXZhdGUgZXZlbnRRdWV1ZTogYW55W10gPSBbXTtcblxuXHRjb25zdHJ1Y3Rvcih1c2VySWQ/OiBzdHJpbmcsIGludGVydmFsTXM6IG51bWJlciA9IDMwMDAwKSB7XG5cdFx0dGhpcy5zZXNzaW9uSWQgPSB0aGlzLmdlbmVyYXRlSWQoKTtcblx0XHR0aGlzLnVzZXJJZCA9IHVzZXJJZDtcblx0XHR0aGlzLnVzZXJCZWhhdmlvciA9IHRoaXMuaW5pdGlhbGl6ZVVzZXJCZWhhdmlvcigpO1xuXHRcdHRoaXMuc3RvcmFnZSA9IG5ldyBBbmFseXRpY3NMb2NhbFN0b3JhZ2VNYW5hZ2VyKCk7XG5cdFx0dGhpcy5zdGFydFBlcmZvcm1hbmNlTW9uaXRvcmluZygpO1xuXHRcdHRoaXMuc3RhcnRQZXJpb2RpY1N5bmMoaW50ZXJ2YWxNcyk7XG5cdFx0Ly8gTG9hZCBleGlzdGluZyBkYXRhIGZyb20gbG9jYWxTdG9yYWdlXG5cdFx0dGhpcy5sb2FkRnJvbVN0b3JhZ2UoKTtcblxuXHRcdC8vIFN5bmMgb24gcGFnZSB1bmxvYWRcblx0XHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignYmVmb3JldW5sb2FkJywgKCkgPT4ge1xuXHRcdFx0dGhpcy5zeW5jTm93KCk7XG5cdFx0fSk7XG5cdH1cblxuXHRwcml2YXRlIGdlbmVyYXRlSWQoKTogc3RyaW5nIHtcblx0XHRyZXR1cm4gYCR7RGF0ZS5ub3coKX0tJHtNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHIoMiwgOSl9YDtcblx0fVxuXG5cdHByaXZhdGUgbG9hZEZyb21TdG9yYWdlKCk6IHZvaWQge1xuXHRcdC8vIExvYWQgZXhpc3RpbmcgZGF0YSBpZiBhbnkgKHVzZWZ1bCBmb3IgcGFnZSByZWZyZXNoZXMpXG5cdFx0Y29uc3QgZXhpc3RpbmdCZWhhdmlvciA9IHRoaXMuc3RvcmFnZS5nZXRVc2VyQmVoYXZpb3IoKTtcblx0XHRpZiAoZXhpc3RpbmdCZWhhdmlvciAmJiBleGlzdGluZ0JlaGF2aW9yLnNlc3Npb25JZCA9PT0gdGhpcy5zZXNzaW9uSWQpIHtcblx0XHRcdHRoaXMudXNlckJlaGF2aW9yID0gZXhpc3RpbmdCZWhhdmlvcjtcblx0XHR9XG5cdH1cblxuXHRwcml2YXRlIGluaXRpYWxpemVVc2VyQmVoYXZpb3IoKTogVXNlckJlaGF2aW9yTWV0cmljcyB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHNlc3Npb25JZDogdGhpcy5zZXNzaW9uSWQsXG5cdFx0XHR1c2VySWQ6IHRoaXMudXNlcklkLFxuXHRcdFx0c2Vzc2lvblN0YXJ0OiBEYXRlLm5vdygpLFxuXHRcdFx0dG90YWxTdHJva2VzOiAwLFxuXHRcdFx0YXZlcmFnZVN0cm9rZUxlbmd0aDogMCxcblx0XHRcdG1vc3RVc2VkVG9vbDogJycsXG5cdFx0XHRtb3N0VXNlZENvbG9yOiAnJyxcblx0XHRcdHRvdGFsRHJhd2luZ1RpbWU6IDAsXG5cdFx0XHRpZGxlVGltZTogMCxcblx0XHRcdHVuZG9Db3VudDogMCxcblx0XHRcdHJlZG9Db3VudDogMCxcblx0XHRcdGNhbnZhc0NsZWFyQ291bnQ6IDAsXG5cdFx0fTtcblx0fVxuXG5cdHByaXZhdGUgc3RhcnRQZXJpb2RpY1N5bmMoaW50ZXJ2YWxNczogbnVtYmVyKTogdm9pZCB7XG5cdFx0Y29uc29sZS5sb2coJ3N0YXJ0UGVyaW9kaWNTeW5jJyk7XG5cblx0XHR0aGlzLnN5bmNUaW1lciA9IHNldEludGVydmFsKGFzeW5jICgpID0+IHtcblx0XHRcdGF3YWl0IHRoaXMuc3luY05vdygpO1xuXHRcdH0sIGludGVydmFsTXMpO1xuXHR9XG5cblx0Ly8gTWFudWFsIHN5bmMgdHJpZ2dlclxuXHRhc3luYyBzeW5jTm93KCk6IFByb21pc2U8Ym9vbGVhbj4ge1xuXHRcdGNvbnNvbGUubG9nKCdTdGFydGluZyBhbmFseXRpY3Mgc3luYy4uLicpO1xuXG5cdFx0Ly8gUXVldWUgY3VycmVudCBzZXNzaW9uIGRhdGFcblx0XHR0aGlzLnN0b3JhZ2UucXVldWVGb3JTeW5jKHRoaXMuc2Vzc2lvbklkKTtcblxuXHRcdC8vIFRyeSB0byBzeW5jIGFsbCBxdWV1ZWQgZGF0YVxuXHRcdGNvbnN0IHN5bmNRdWV1ZSA9IHRoaXMuc3RvcmFnZS5nZXRTeW5jUXVldWUoKTtcblx0XHRsZXQgc3luY2VkQ291bnQgPSAwO1xuXG5cdFx0Ly8gdG9kbyBzZW5kIHRvIHRoZSBiYWNrZW5kXG5cdFx0Ly8gZm9yIChjb25zdCBwYXlsb2FkIG9mIHN5bmNRdWV1ZSkge1xuXHRcdC8vIGlmIChzdWNjZXNzKSB7XG5cdFx0Ly8gXHR0aGlzLnN0b3JhZ2UuY2xlYXJTeW5jZWREYXRhKHBheWxvYWQudGltZXN0YW1wKTtcblx0XHQvLyBcdHN5bmNlZENvdW50Kys7XG5cdFx0Ly8gfSBlbHNlIHtcblx0XHQvLyBcdGJyZWFrOyAvLyBTdG9wIG9uIGZpcnN0IGZhaWx1cmUgdG8gbWFpbnRhaW4gb3JkZXJcblx0XHQvLyB9XG5cdFx0Ly8gfVxuXG5cdFx0aWYgKHN5bmNlZENvdW50ID4gMCkge1xuXHRcdFx0Y29uc29sZS5sb2coYFN5bmNlZCAke3N5bmNlZENvdW50fSBhbmFseXRpY3MgcGF5bG9hZHNgKTtcblx0XHRcdC8vIENsZWFyIGxvY2FsIGRhdGEgYWZ0ZXIgc3VjY2Vzc2Z1bCBzeW5jXG5cdFx0XHR0aGlzLnN0b3JhZ2UuY2xlYXJMb2NhbERhdGEoKTtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdC8vIEVuaGFuY2VkIGRyYXdpbmcgZXZlbnQgbG9nZ2luZyB3aXRoIGNvbXByZWhlbnNpdmUgZGF0YVxuXHRsb2dEcmF3aW5nRXZlbnQoXG5cdFx0ZXZlbnRUeXBlOiBEcmF3aW5nRXZlbnRbJ2V2ZW50VHlwZSddLFxuXHRcdGRhdGE6IHtcblx0XHRcdGNvb3JkaW5hdGVzPzogeyB4OiBudW1iZXI7IHk6IG51bWJlciB9O1xuXHRcdFx0cHJlc3N1cmU/OiBudW1iZXI7XG5cdFx0XHR0b29sPzogc3RyaW5nO1xuXHRcdFx0Y29sb3I/OiBzdHJpbmc7XG5cdFx0XHRicnVzaFNpemU/OiBudW1iZXI7XG5cdFx0XHRzdHJva2VJZD86IHN0cmluZztcblx0XHR9ID0ge31cblx0KTogc3RyaW5nIHtcblx0XHRjb25zdCBldmVudElkID0gdGhpcy5nZW5lcmF0ZUlkKCk7XG5cdFx0Y29uc3QgdGltZXN0YW1wID0gRGF0ZS5ub3coKTtcblxuXHRcdGNvbnN0IGV2ZW50OiBEcmF3aW5nRXZlbnQgPSB7XG5cdFx0XHRldmVudElkLFxuXHRcdFx0dGltZXN0YW1wLFxuXHRcdFx0ZXZlbnRUeXBlLFxuXHRcdFx0c2Vzc2lvbklkOiB0aGlzLnNlc3Npb25JZCxcblx0XHRcdHVzZXJJZDogdGhpcy51c2VySWQsXG5cdFx0XHQuLi5kYXRhLFxuXHRcdH07XG5cblx0XHR0aGlzLmV2ZW50cy5wdXNoKGV2ZW50KTtcblx0XHR0aGlzLnVwZGF0ZVVzZXJCZWhhdmlvcihldmVudCk7XG5cdFx0dGhpcy5sYXN0QWN0aXZpdHkgPSB0aW1lc3RhbXA7XG5cblx0XHQvLyBMb2cgdG8gY29uc29sZSB3aXRoIHN0cnVjdHVyZWQgZm9ybWF0XG5cdFx0Ly8gY29uc29sZS5ncm91cChgRHJhd2luZyBFdmVudDogJHtldmVudFR5cGV9YCk7XG5cdFx0Ly8gY29uc29sZS5sb2coJ0V2ZW50IElEOicsIGV2ZW50SWQpO1xuXHRcdC8vIGNvbnNvbGUubG9nKCdUaW1lc3RhbXA6JywgbmV3IERhdGUodGltZXN0YW1wKS50b0lTT1N0cmluZygpKTtcblx0XHQvLyBjb25zb2xlLmxvZygnRGF0YTonLCBkYXRhKTtcblx0XHRjb25zb2xlLmdyb3VwRW5kKCk7XG5cdFx0dGhpcy5zdG9yYWdlLmFwcGVuZERhdGEodGhpcy5zdG9yYWdlLlNUT1JBR0VfS0VZUy5FVkVOVFMsIGV2ZW50KTtcblxuXHRcdHJldHVybiBldmVudElkO1xuXHR9XG5cblx0Ly8gRW5oYW5jZWQgbmV0d29yayBsb2dnaW5nIHdpdGggcXVhbGl0eSBhc3Nlc3NtZW50XG5cdGxvZ05ldHdvcmtFdmVudChcblx0XHRldmVudElkOiBzdHJpbmcsXG5cdFx0c3RhcnRUaW1lOiBudW1iZXIsXG5cdFx0YWNrbm93bGVkZ2VkOiBib29sZWFuLFxuXHRcdHBheWxvYWRTaXplOiBudW1iZXIsXG5cdFx0cmV0cnlDb3VudDogbnVtYmVyID0gMFxuXHQpOiB2b2lkIHtcblx0XHRjb25zdCBydHQgPSBwZXJmb3JtYW5jZS5ub3coKSAtIHN0YXJ0VGltZTtcblx0XHRjb25zdCBjb25uZWN0aW9uUXVhbGl0eSA9IHRoaXMuYXNzZXNzQ29ubmVjdGlvblF1YWxpdHkocnR0KTtcblxuXHRcdGNvbnN0IG5ldHdvcmtNZXRyaWM6IE5ldHdvcmtNZXRyaWNzID0ge1xuXHRcdFx0ZXZlbnRJZCxcblx0XHRcdHRpbWVzdGFtcDogRGF0ZS5ub3coKSxcblx0XHRcdHJ0dCxcblx0XHRcdGFja25vd2xlZGdlZCxcblx0XHRcdHJldHJ5Q291bnQsXG5cdFx0XHRwYXlsb2FkU2l6ZSxcblx0XHRcdGNvbm5lY3Rpb25RdWFsaXR5LFxuXHRcdH07XG5cblx0XHR0aGlzLm5ldHdvcmtNZXRyaWNzLnB1c2gobmV0d29ya01ldHJpYyk7XG5cblx0XHQvLyBjb25zb2xlLmdyb3VwKGBOZXR3b3JrIEV2ZW50YCk7XG5cdFx0Ly8gY29uc29sZS5sb2coJ0V2ZW50IElEOicsIGV2ZW50SWQpO1xuXHRcdC8vIGNvbnNvbGUubG9nKCdSVFQ6JywgYCR7cnR0LnRvRml4ZWQoMil9bXNgKTtcblx0XHQvLyBjb25zb2xlLmxvZygnUXVhbGl0eTonLCBjb25uZWN0aW9uUXVhbGl0eSk7XG5cdFx0Ly8gY29uc29sZS5sb2coJ1BheWxvYWQgU2l6ZTonLCBgJHtwYXlsb2FkU2l6ZX0gYnl0ZXNgKTtcblx0XHQvLyBjb25zb2xlLmxvZygnQWNrbm93bGVkZ2VkOicsIGFja25vd2xlZGdlZCk7XG5cdFx0dGhpcy5zdG9yYWdlLmFwcGVuZERhdGEodGhpcy5zdG9yYWdlLlNUT1JBR0VfS0VZUy5ORVRXT1JLLCBuZXR3b3JrTWV0cmljKTtcblx0XHRpZiAocmV0cnlDb3VudCA+IDApIGNvbnNvbGUud2FybignUmV0cnkgQ291bnQ6JywgcmV0cnlDb3VudCk7XG5cdFx0Y29uc29sZS5ncm91cEVuZCgpO1xuXHR9XG5cblx0cHJpdmF0ZSBhc3Nlc3NDb25uZWN0aW9uUXVhbGl0eShcblx0XHRydHQ6IG51bWJlclxuXHQpOiBOZXR3b3JrTWV0cmljc1snY29ubmVjdGlvblF1YWxpdHknXSB7XG5cdFx0aWYgKHJ0dCA8IDUwKSByZXR1cm4gJ2V4Y2VsbGVudCc7XG5cdFx0aWYgKHJ0dCA8IDEwMCkgcmV0dXJuICdnb29kJztcblx0XHRpZiAocnR0IDwgMjAwKSByZXR1cm4gJ2ZhaXInO1xuXHRcdGlmIChydHQgPCA1MDApIHJldHVybiAnZGVjZW50Jztcblx0XHRyZXR1cm4gJ3Bvb3InO1xuXHR9XG5cblx0Ly8gUGVyZm9ybWFuY2UgbW9uaXRvcmluZ1xuXHRwcml2YXRlIHN0YXJ0UGVyZm9ybWFuY2VNb25pdG9yaW5nKCk6IHZvaWQge1xuXHRcdGlmIChcblx0XHRcdHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnIHx8XG5cdFx0XHR0eXBlb2YgcmVxdWVzdEFuaW1hdGlvbkZyYW1lID09PSAndW5kZWZpbmVkJ1xuXHRcdCkge1xuXHRcdFx0Y29uc29sZS53YXJuKCdQZXJmb3JtYW5jZSBtb25pdG9yaW5nIG5vdCBhdmFpbGFibGUgaW4gdGhpcyBlbnZpcm9ubWVudCcpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHRjb25zdCBtb25pdG9yID0gKCkgPT4ge1xuXHRcdFx0Y29uc3Qgbm93ID0gcGVyZm9ybWFuY2Uubm93KCk7XG5cdFx0XHRjb25zdCBkZWx0YVRpbWUgPSBub3cgLSB0aGlzLmxhc3RGUFNDaGVjaztcblxuXHRcdFx0aWYgKGRlbHRhVGltZSA+PSAxMDAwKSB7XG5cdFx0XHRcdC8vIGlmIGl0cyBiZWVuIGEgc2Vjb25kXG5cdFx0XHRcdGNvbnN0IGZwcyA9ICh0aGlzLmZyYW1lQ291bnQgKiAxMDAwKSAvIGRlbHRhVGltZTtcblx0XHRcdFx0Y29uc3QgbWVtb3J5VXNhZ2UgPSAocGVyZm9ybWFuY2UgYXMgYW55KS5tZW1vcnk/LnVzZWRKU0hlYXBTaXplIHx8IDA7XG5cblx0XHRcdFx0Y29uc3QgcGVyZk1ldHJpYzogUGVyZm9ybWFuY2VNZXRyaWNzID0ge1xuXHRcdFx0XHRcdHRpbWVzdGFtcDogRGF0ZS5ub3coKSxcblx0XHRcdFx0XHRmcHM6IE1hdGgucm91bmQoZnBzKSxcblx0XHRcdFx0XHRtZW1vcnlVc2FnZSxcblx0XHRcdFx0XHRjYW52YXNSZW5kZXJUaW1lOiAwLCAvLyBZb3UnbGwgbmVlZCB0byBtZWFzdXJlIHRoaXMgaW4geW91ciByZW5kZXIgbG9vcFxuXHRcdFx0XHRcdGV2ZW50UHJvY2Vzc2luZ1RpbWU6IDAsIC8vIE1lYXN1cmUgaW4geW91ciBldmVudCBoYW5kbGVyc1xuXHRcdFx0XHRcdHF1ZXVlZEV2ZW50czogdGhpcy5ldmVudFF1ZXVlLmxlbmd0aCxcblx0XHRcdFx0fTtcblxuXHRcdFx0XHR0aGlzLnBlcmZvcm1hbmNlTWV0cmljcy5wdXNoKHBlcmZNZXRyaWMpO1xuXHRcdFx0XHR0aGlzLmZyYW1lQ291bnQgPSAwO1xuXHRcdFx0XHR0aGlzLmxhc3RGUFNDaGVjayA9IG5vdztcblxuXHRcdFx0XHQvLyBMb2cgcGVyZm9ybWFuY2Ugd2FybmluZ3Ncblx0XHRcdFx0aWYgKGZwcyA8IDMwKSB7XG5cdFx0XHRcdFx0Y29uc29sZS53YXJuKGBMb3cgRlBTIGRldGVjdGVkOiAke2Zwcy50b0ZpeGVkKDEpfWApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICh0aGlzLmV2ZW50UXVldWUubGVuZ3RoID4gMTApIHtcblx0XHRcdFx0XHRjb25zb2xlLndhcm4oYEV2ZW50IHF1ZXVlIGJhY2tsb2c6ICR7dGhpcy5ldmVudFF1ZXVlLmxlbmd0aH0gZXZlbnRzYCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0dGhpcy5mcmFtZUNvdW50Kys7XG5cdFx0XHR0aGlzLnN0b3JhZ2UuYXBwZW5kRGF0YSh0aGlzLnN0b3JhZ2UuU1RPUkFHRV9LRVlTLk5FVFdPUkssIG5ldHdvcmtNZXRyaWMpO1xuXHRcdFx0cmVxdWVzdEFuaW1hdGlvbkZyYW1lKG1vbml0b3IpO1xuXHRcdH07XG5cblx0XHRyZXF1ZXN0QW5pbWF0aW9uRnJhbWUobW9uaXRvcik7XG5cdH1cblxuXHQvLyBVcGRhdGUgdXNlciBiZWhhdmlvciBtZXRyaWNzXG5cdHByaXZhdGUgdXBkYXRlVXNlckJlaGF2aW9yKGV2ZW50OiBEcmF3aW5nRXZlbnQpOiB2b2lkIHtcblx0XHRzd2l0Y2ggKGV2ZW50LmV2ZW50VHlwZSkge1xuXHRcdFx0Y2FzZSAnc3Ryb2tlX3N0YXJ0Jzpcblx0XHRcdFx0dGhpcy51c2VyQmVoYXZpb3IudG90YWxTdHJva2VzKys7XG5cdFx0XHRcdHRoaXMuY3VycmVudFN0cm9rZVN0YXJ0ID0gZXZlbnQudGltZXN0YW1wO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgJ3N0cm9rZV9lbmQnOlxuXHRcdFx0XHRpZiAodGhpcy5jdXJyZW50U3Ryb2tlU3RhcnQpIHtcblx0XHRcdFx0XHRjb25zdCBzdHJva2VEdXJhdGlvbiA9IGV2ZW50LnRpbWVzdGFtcCAtIHRoaXMuY3VycmVudFN0cm9rZVN0YXJ0O1xuXHRcdFx0XHRcdHRoaXMudXNlckJlaGF2aW9yLnRvdGFsRHJhd2luZ1RpbWUgKz0gc3Ryb2tlRHVyYXRpb247XG5cdFx0XHRcdH1cblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICd1bmRvJzpcblx0XHRcdFx0dGhpcy51c2VyQmVoYXZpb3IudW5kb0NvdW50Kys7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAncmVkbyc6XG5cdFx0XHRcdHRoaXMudXNlckJlaGF2aW9yLnJlZG9Db3VudCsrO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgJ2NhbnZhc19jbGVhcic6XG5cdFx0XHRcdHRoaXMudXNlckJlaGF2aW9yLmNhbnZhc0NsZWFyQ291bnQrKztcblx0XHRcdFx0YnJlYWs7XG5cdFx0fVxuXHR9XG5cblx0Ly8gRW5oYW5jZWQgc29ja2V0IGVtaXNzaW9uIHdpdGggY29tcHJlaGVuc2l2ZSBsb2dnaW5nXG5cdGVtaXRXaXRoTG9nZ2luZyhcblx0XHRzb2NrZXQ6IGFueSxcblx0XHRldmVudE5hbWU6IHN0cmluZyxcblx0XHRkYXRhOiBhbnksXG5cdFx0b3B0aW9uczoge1xuXHRcdFx0dGltZW91dD86IG51bWJlcjtcblx0XHRcdHJldHJ5Q291bnQ/OiBudW1iZXI7XG5cdFx0XHRwcmlvcml0eT86ICdoaWdoJyB8ICdub3JtYWwnIHwgJ2xvdyc7XG5cdFx0fSA9IHt9XG5cdCk6IFByb21pc2U8Ym9vbGVhbj4ge1xuXHRcdHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuXHRcdFx0Y29uc3Qgc3RhcnRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG5cdFx0XHRjb25zdCBldmVudElkID0gdGhpcy5sb2dEcmF3aW5nRXZlbnQoJ3N0cm9rZV9jb250aW51ZScsIGRhdGEpO1xuXHRcdFx0Y29uc3QgcGF5bG9hZFNpemUgPSBzaXplb2YoZGF0YSk7XG5cdFx0XHRsZXQgcmV0cnlDb3VudCA9IDA7XG5cdFx0XHRjb25zdCBtYXhSZXRyaWVzID0gb3B0aW9ucy5yZXRyeUNvdW50IHx8IDM7XG5cblx0XHRcdGNvbnN0IGF0dGVtcHQgPSAoKSA9PiB7XG5cdFx0XHRcdHNvY2tldC5lbWl0KGV2ZW50TmFtZSwgZGF0YSwgKGFjazogYm9vbGVhbikgPT4ge1xuXHRcdFx0XHRcdHRoaXMubG9nTmV0d29ya0V2ZW50KFxuXHRcdFx0XHRcdFx0ZXZlbnRJZCxcblx0XHRcdFx0XHRcdHN0YXJ0VGltZSxcblx0XHRcdFx0XHRcdGFjayxcblx0XHRcdFx0XHRcdHBheWxvYWRTaXplLFxuXHRcdFx0XHRcdFx0cmV0cnlDb3VudFxuXHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHRpZiAoYWNrKSB7XG5cdFx0XHRcdFx0XHRyZXNvbHZlKHRydWUpO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAocmV0cnlDb3VudCA8IG1heFJldHJpZXMpIHtcblx0XHRcdFx0XHRcdHJldHJ5Q291bnQrKztcblx0XHRcdFx0XHRcdGNvbnNvbGUud2Fybihcblx0XHRcdFx0XHRcdFx0YFJldHJ5aW5nIGV2ZW50ICR7ZXZlbnRJZH0gKGF0dGVtcHQgJHtyZXRyeUNvdW50fS8ke21heFJldHJpZXN9KWBcblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRzZXRUaW1lb3V0KGF0dGVtcHQsIDEwMCAqIHJldHJ5Q291bnQpOyAvLyBFeHBvbmVudGlhbCBiYWNrb2ZmXG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoXG5cdFx0XHRcdFx0XHRcdGBFdmVudCAke2V2ZW50SWR9IGZhaWxlZCBhZnRlciAke21heFJldHJpZXN9IHJldHJpZXNgXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0cmVzb2x2ZShmYWxzZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHRcdH07XG5cblx0XHRcdGF0dGVtcHQoKTtcblx0XHR9KTtcblx0fVxuXG5cdC8vIERhdGEgZXhwb3J0IGFuZCBhbmFseXNpcyBtZXRob2RzXG5cdGV4cG9ydEFuYWx5dGljcygpOiB7XG5cdFx0c2Vzc2lvbjogVXNlckJlaGF2aW9yTWV0cmljcztcblx0XHRldmVudHM6IERyYXdpbmdFdmVudFtdO1xuXHRcdG5ldHdvcms6IE5ldHdvcmtNZXRyaWNzW107XG5cdFx0cGVyZm9ybWFuY2U6IFBlcmZvcm1hbmNlTWV0cmljc1tdO1xuXHRcdHN1bW1hcnk6IGFueTtcblx0fSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHNlc3Npb246IHRoaXMudXNlckJlaGF2aW9yLFxuXHRcdFx0ZXZlbnRzOiB0aGlzLmV2ZW50cyxcblx0XHRcdG5ldHdvcms6IHRoaXMubmV0d29ya01ldHJpY3MsXG5cdFx0XHRwZXJmb3JtYW5jZTogdGhpcy5wZXJmb3JtYW5jZU1ldHJpY3MsXG5cdFx0XHRzdW1tYXJ5OiB0aGlzLmdlbmVyYXRlU3VtbWFyeSgpLFxuXHRcdH07XG5cdH1cblxuXHRwcml2YXRlIGdlbmVyYXRlU3VtbWFyeSgpIHtcblx0XHRjb25zdCB0b3RhbEV2ZW50cyA9IHRoaXMuZXZlbnRzLmxlbmd0aDtcblx0XHRjb25zdCBhdmdSVFQgPVxuXHRcdFx0dGhpcy5uZXR3b3JrTWV0cmljcy5yZWR1Y2UoKHN1bSwgbSkgPT4gc3VtICsgbS5ydHQsIDApIC9cblx0XHRcdFx0dGhpcy5uZXR3b3JrTWV0cmljcy5sZW5ndGggfHwgMDtcblx0XHRjb25zdCBhY2tub3dsZWRnZWRNZXNzYWdlcyA9IHRoaXMubmV0d29ya01ldHJpY3MuZmlsdGVyKFxuXHRcdFx0KG0pID0+IG0uYWNrbm93bGVkZ2VkXG5cdFx0KTtcblx0XHRjb25zdCBuYWNrTWVzc2FnZXMgPSB0aGlzLm5ldHdvcmtNZXRyaWNzLmZpbHRlcigobSkgPT4gIW0uYWNrbm93bGVkZ2VkKTtcblx0XHRjb25zdCBmYWlsZWREYXRhU2VuZCA9IG5hY2tNZXNzYWdlcy5yZWR1Y2UoXG5cdFx0XHQoc3VtOiBudW1iZXIsIGk6IE5ldHdvcmtNZXRyaWNzKSA9PiBzdW0gKyBpLnBheWxvYWRTaXplLFxuXHRcdFx0MFxuXHRcdCk7XG5cblx0XHRjb25zdCBzdWNjZXNzUmF0ZSA9XG5cdFx0XHQoYWNrbm93bGVkZ2VkTWVzc2FnZXMubGVuZ3RoIC8gdGhpcy5uZXR3b3JrTWV0cmljcy5sZW5ndGgpICogMTAwIHx8IDA7XG5cdFx0Y29uc3QgdG90YWxEYXRhU2VuZCA9IGFja25vd2xlZGdlZE1lc3NhZ2VzLnJlZHVjZShcblx0XHRcdChzdW06IG51bWJlciwgaTogTmV0d29ya01ldHJpY3MpID0+IHN1bSArIGkucGF5bG9hZFNpemUsXG5cdFx0XHQwXG5cdFx0KTtcblx0XHRjb25zdCB0b3RhbERhdGFBdHRlbXB0ZWQgPSB0b3RhbERhdGFTZW5kICsgZmFpbGVkRGF0YVNlbmQ7XG5cdFx0Y29uc3QgZGF0YUVmZmljaWVuY3lSYXRlID0gKHRvdGFsRGF0YVNlbmQgLyB0b3RhbERhdGFBdHRlbXB0ZWQpICogMTAwO1xuXHRcdGNvbnN0IGF2Z1N1Y2Nlc3NmdWxQYXlsb2FkU2l6ZSA9XG5cdFx0XHR0b3RhbERhdGFTZW5kIC8gYWNrbm93bGVkZ2VkTWVzc2FnZXMubGVuZ3RoO1xuXHRcdGNvbnN0IGF2Z0ZhaWxlZFBheWxvYWRTaXplID0gZmFpbGVkRGF0YVNlbmQgLyBuYWNrTWVzc2FnZXMubGVuZ3RoO1xuXG5cdFx0Y29uc3QgYXZnRlBTID1cblx0XHRcdHRoaXMucGVyZm9ybWFuY2VNZXRyaWNzLnJlZHVjZSgoc3VtLCBtKSA9PiBzdW0gKyBtLmZwcywgMCkgL1xuXHRcdFx0XHR0aGlzLnBlcmZvcm1hbmNlTWV0cmljcy5sZW5ndGggfHwgMDtcblxuXHRcdHJldHVybiB7XG5cdFx0XHR0b3RhbEV2ZW50cyxcblx0XHRcdGF2Z1JUVDogTWF0aC5yb3VuZChhdmdSVFQgKiAxMDApIC8gMTAwLFxuXHRcdFx0c3VjY2Vzc1JhdGU6IE1hdGgucm91bmQoc3VjY2Vzc1JhdGUgKiAxMDApIC8gMTAwLFxuXHRcdFx0YXZnRlBTOiBNYXRoLnJvdW5kKGF2Z0ZQUyksXG5cdFx0XHR0b3RhbERhdGFTZW5kOiBNYXRoLnJvdW5kKHRvdGFsRGF0YVNlbmQpLFxuXHRcdFx0ZGF0YUVmZmljaWVuY3lSYXRlOiBNYXRoLnJvdW5kKGRhdGFFZmZpY2llbmN5UmF0ZSksXG5cdFx0XHRhdmdTdWNjZXNzZnVsUGF5bG9hZFNpemU6IE1hdGgucm91bmQoYXZnU3VjY2Vzc2Z1bFBheWxvYWRTaXplKSxcblx0XHRcdGF2Z0ZhaWxlZFBheWxvYWRTaXplOiBNYXRoLnJvdW5kKGF2Z0ZhaWxlZFBheWxvYWRTaXplKSxcblx0XHRcdHNlc3Npb25EdXJhdGlvbjogRGF0ZS5ub3coKSAtIHRoaXMudXNlckJlaGF2aW9yLnNlc3Npb25TdGFydCxcblx0XHRcdG5ldHdvcmtRdWFsaXR5RGlzdHJpYnV0aW9uOiB0aGlzLmdldE5ldHdvcmtRdWFsaXR5RGlzdHJpYnV0aW9uKCksXG5cdFx0fTtcblx0fVxuXG5cdHByaXZhdGUgZ2V0TmV0d29ya1F1YWxpdHlEaXN0cmlidXRpb24oKSB7XG5cdFx0Y29uc3QgZGlzdHJpYnV0aW9uID0geyBleGNlbGxlbnQ6IDAsIGdvb2Q6IDAsIGZhaXI6IDAsIHBvb3I6IDAsIGRlY2VudDogMCB9O1xuXHRcdHRoaXMubmV0d29ya01ldHJpY3MuZm9yRWFjaCgobWV0cmljKSA9PiB7XG5cdFx0XHRkaXN0cmlidXRpb25bbWV0cmljLmNvbm5lY3Rpb25RdWFsaXR5XSsrO1xuXHRcdH0pO1xuXHRcdHJldHVybiBkaXN0cmlidXRpb247XG5cdH1cblxuXHQvLyBSZWFsLXRpbWUgbW9uaXRvcmluZyBkYXNoYm9hcmQgKGNvbnNvbGUtYmFzZWQpXG5cdHN0YXJ0UmVhbHRpbWVNb25pdG9yaW5nKGludGVydmFsTXM6IG51bWJlciA9IDUwMDApOiB2b2lkIHtcblx0XHRzZXRJbnRlcnZhbCgoKSA9PiB7XG5cdFx0XHRjb25zdCBzdW1tYXJ5ID0gdGhpcy5nZW5lcmF0ZVN1bW1hcnkoKTtcblx0XHRcdGNvbnNvbGUubG9nKFxuXHRcdFx0XHQnU2Vzc2lvbiBEdXJhdGlvbjonLFxuXHRcdFx0XHRgJHtNYXRoLnJvdW5kKHN1bW1hcnkuc2Vzc2lvbkR1cmF0aW9uIC8gMTAwMCl9c2Bcblx0XHRcdCk7XG5cdFx0XHRjb25zb2xlLmxvZygnbG9jYWwgc3RvcmFnZScsIHRoaXMuc3RvcmFnZS5nZXRTdG9yYWdlSW5mbygpKTtcblxuXHRcdFx0Ly8gY29uc29sZS5sb2coJ1RvdGFsIEV2ZW50czonLCBzdW1tYXJ5LnRvdGFsRXZlbnRzKTtcblx0XHRcdC8vIGNvbnNvbGUubG9nKCdBdmVyYWdlIFJUVDonLCBgJHtzdW1tYXJ5LmF2Z1JUVH1tc2ApO1xuXHRcdFx0Ly8gY29uc29sZS5sb2coJ1N1Y2Nlc3MgUmF0ZTonLCBgJHtzdW1tYXJ5LnN1Y2Nlc3NSYXRlfSVgKTtcblx0XHRcdC8vIGNvbnNvbGUubG9nKCdBdmVyYWdlIEZQUzonLCBzdW1tYXJ5LmF2Z0ZQUyk7XG5cdFx0XHQvLyBjb25zb2xlLmxvZygnTmV0d29yayBRdWFsaXR5OicsIHN1bW1hcnkubmV0d29ya1F1YWxpdHlEaXN0cmlidXRpb24pO1xuXG5cdFx0XHRjb25zb2xlLmdyb3VwRW5kKCk7XG5cdFx0fSwgaW50ZXJ2YWxNcyk7XG5cdH1cblx0Ly8gQ2xlYW51cFxuXHRkZXN0cm95KCk6IHZvaWQge1xuXHRcdGlmICh0aGlzLnN5bmNUaW1lcikge1xuXHRcdFx0Y2xlYXJJbnRlcnZhbCh0aGlzLnN5bmNUaW1lcik7XG5cdFx0fVxuXHRcdHRoaXMuc3luY05vdygpOyAvLyBGaW5hbCBzeW5jXG5cdH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgRHJhd2luZ0FuYWx5dGljcztcbiJdLCJuYW1lcyI6WyJzaXplb2YiLCJBbmFseXRpY3NMb2NhbFN0b3JhZ2VNYW5hZ2VyIiwiRHJhd2luZ0FuYWx5dGljcyIsImdlbmVyYXRlSWQiLCJNYXRoIiwiRGF0ZSIsIm5vdyIsInJhbmRvbSIsInRvU3RyaW5nIiwic3Vic3RyIiwibG9hZEZyb21TdG9yYWdlIiwiZXhpc3RpbmdCZWhhdmlvciIsInN0b3JhZ2UiLCJnZXRVc2VyQmVoYXZpb3IiLCJzZXNzaW9uSWQiLCJ1c2VyQmVoYXZpb3IiLCJpbml0aWFsaXplVXNlckJlaGF2aW9yIiwidXNlcklkIiwic2Vzc2lvblN0YXJ0IiwidG90YWxTdHJva2VzIiwiYXZlcmFnZVN0cm9rZUxlbmd0aCIsIm1vc3RVc2VkVG9vbCIsIm1vc3RVc2VkQ29sb3IiLCJ0b3RhbERyYXdpbmdUaW1lIiwiaWRsZVRpbWUiLCJ1bmRvQ291bnQiLCJyZWRvQ291bnQiLCJjYW52YXNDbGVhckNvdW50Iiwic3RhcnRQZXJpb2RpY1N5bmMiLCJpbnRlcnZhbE1zIiwiY29uc29sZSIsImxvZyIsInN5bmNUaW1lciIsInNldEludGVydmFsIiwic3luY05vdyIsInF1ZXVlRm9yU3luYyIsInN5bmNRdWV1ZSIsImdldFN5bmNRdWV1ZSIsInN5bmNlZENvdW50IiwiY2xlYXJMb2NhbERhdGEiLCJsb2dEcmF3aW5nRXZlbnQiLCJldmVudFR5cGUiLCJkYXRhIiwiZXZlbnRJZCIsInRpbWVzdGFtcCIsImV2ZW50IiwiZXZlbnRzIiwicHVzaCIsInVwZGF0ZVVzZXJCZWhhdmlvciIsImxhc3RBY3Rpdml0eSIsImdyb3VwRW5kIiwiYXBwZW5kRGF0YSIsIlNUT1JBR0VfS0VZUyIsIkVWRU5UUyIsImxvZ05ldHdvcmtFdmVudCIsInN0YXJ0VGltZSIsImFja25vd2xlZGdlZCIsInBheWxvYWRTaXplIiwicmV0cnlDb3VudCIsInJ0dCIsInBlcmZvcm1hbmNlIiwiY29ubmVjdGlvblF1YWxpdHkiLCJhc3Nlc3NDb25uZWN0aW9uUXVhbGl0eSIsIm5ldHdvcmtNZXRyaWMiLCJuZXR3b3JrTWV0cmljcyIsIk5FVFdPUksiLCJ3YXJuIiwic3RhcnRQZXJmb3JtYW5jZU1vbml0b3JpbmciLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJtb25pdG9yIiwiZGVsdGFUaW1lIiwibGFzdEZQU0NoZWNrIiwiZnBzIiwiZnJhbWVDb3VudCIsIm1lbW9yeVVzYWdlIiwibWVtb3J5IiwidXNlZEpTSGVhcFNpemUiLCJwZXJmTWV0cmljIiwicm91bmQiLCJjYW52YXNSZW5kZXJUaW1lIiwiZXZlbnRQcm9jZXNzaW5nVGltZSIsInF1ZXVlZEV2ZW50cyIsImV2ZW50UXVldWUiLCJsZW5ndGgiLCJwZXJmb3JtYW5jZU1ldHJpY3MiLCJ0b0ZpeGVkIiwiY3VycmVudFN0cm9rZVN0YXJ0Iiwic3Ryb2tlRHVyYXRpb24iLCJlbWl0V2l0aExvZ2dpbmciLCJzb2NrZXQiLCJldmVudE5hbWUiLCJvcHRpb25zIiwiUHJvbWlzZSIsInJlc29sdmUiLCJtYXhSZXRyaWVzIiwiYXR0ZW1wdCIsImVtaXQiLCJhY2siLCJzZXRUaW1lb3V0IiwiZXJyb3IiLCJleHBvcnRBbmFseXRpY3MiLCJzZXNzaW9uIiwibmV0d29yayIsInN1bW1hcnkiLCJnZW5lcmF0ZVN1bW1hcnkiLCJ0b3RhbEV2ZW50cyIsImF2Z1JUVCIsInJlZHVjZSIsInN1bSIsIm0iLCJhY2tub3dsZWRnZWRNZXNzYWdlcyIsImZpbHRlciIsIm5hY2tNZXNzYWdlcyIsImZhaWxlZERhdGFTZW5kIiwiaSIsInN1Y2Nlc3NSYXRlIiwidG90YWxEYXRhU2VuZCIsInRvdGFsRGF0YUF0dGVtcHRlZCIsImRhdGFFZmZpY2llbmN5UmF0ZSIsImF2Z1N1Y2Nlc3NmdWxQYXlsb2FkU2l6ZSIsImF2Z0ZhaWxlZFBheWxvYWRTaXplIiwiYXZnRlBTIiwic2Vzc2lvbkR1cmF0aW9uIiwibmV0d29ya1F1YWxpdHlEaXN0cmlidXRpb24iLCJnZXROZXR3b3JrUXVhbGl0eURpc3RyaWJ1dGlvbiIsImRpc3RyaWJ1dGlvbiIsImV4Y2VsbGVudCIsImdvb2QiLCJmYWlyIiwicG9vciIsImRlY2VudCIsImZvckVhY2giLCJtZXRyaWMiLCJzdGFydFJlYWx0aW1lTW9uaXRvcmluZyIsImdldFN0b3JhZ2VJbmZvIiwiZGVzdHJveSIsImNsZWFySW50ZXJ2YWwiLCJjb25zdHJ1Y3RvciIsIndpbmRvdyIsImFkZEV2ZW50TGlzdGVuZXIiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/util/DrawingAnalytics.ts\n"));

/***/ })

});