"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/util/DrawingAnalytics.ts":
/*!**************************************!*\
  !*** ./src/util/DrawingAnalytics.ts ***!
  \**************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var object_sizeof__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! object-sizeof */ \"(app-pages-browser)/../node_modules/object-sizeof/indexv2.js\");\n/* harmony import */ var object_sizeof__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(object_sizeof__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _AnalyticsLocalStorageManager__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./AnalyticsLocalStorageManager */ \"(app-pages-browser)/./src/util/AnalyticsLocalStorageManager.ts\");\n\n\nclass DrawingAnalytics {\n    generateId() {\n        return \"\".concat(Date.now(), \"-\").concat(Math.random().toString(36).substr(2, 9));\n    }\n    loadFromStorage() {\n        // Load existing data if any (useful for page refreshes)\n        const existingBehavior = this.storage.getUserBehavior();\n        if (existingBehavior && existingBehavior.sessionId === this.sessionId) {\n            this.userBehavior = existingBehavior;\n        }\n    }\n    initializeUserBehavior() {\n        return {\n            sessionId: this.sessionId,\n            userId: this.userId,\n            sessionStart: Date.now(),\n            totalStrokes: 0,\n            averageStrokeLength: 0,\n            mostUsedTool: '',\n            mostUsedColor: '',\n            totalDrawingTime: 0,\n            idleTime: 0,\n            undoCount: 0,\n            redoCount: 0,\n            canvasClearCount: 0\n        };\n    }\n    startPeriodicSync(intervalMs) {\n        console.log('startPeriodicSync');\n        this.syncTimer = setInterval(async ()=>{\n            await this.syncNow();\n        }, intervalMs);\n    }\n    // Manual sync trigger\n    async syncNow() {\n        console.log('Starting analytics sync...');\n        // Queue current session data\n        this.storage.queueForSync(this.sessionId);\n        // Try to sync all queued data\n        const syncQueue = this.storage.getSyncQueue();\n        let syncedCount = 0;\n        // todo send to the backend\n        // for (const payload of syncQueue) {\n        // if (success) {\n        // \tthis.storage.clearSyncedData(payload.timestamp);\n        // \tsyncedCount++;\n        // } else {\n        // \tbreak; // Stop on first failure to maintain order\n        // }\n        // }\n        if (syncedCount > 0) {\n            console.log(\"Synced \".concat(syncedCount, \" analytics payloads\"));\n            // Clear local data after successful sync\n            this.storage.clearLocalData();\n            return true;\n        }\n        return false;\n    }\n    // Enhanced drawing event logging with comprehensive data\n    logDrawingEvent(eventType) {\n        let data = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n        const eventId = this.generateId();\n        const timestamp = Date.now();\n        const event = {\n            eventId,\n            timestamp,\n            eventType,\n            sessionId: this.sessionId,\n            userId: this.userId,\n            ...data\n        };\n        this.events.push(event);\n        this.updateUserBehavior(event);\n        this.lastActivity = timestamp;\n        // Log to console with structured format\n        // console.group(`Drawing Event: ${eventType}`);\n        // console.log('Event ID:', eventId);\n        // console.log('Timestamp:', new Date(timestamp).toISOString());\n        // console.log('Data:', data);\n        console.groupEnd();\n        this.storage.appendData(this.storage.STORAGE_KEYS.EVENTS);\n        return eventId;\n    }\n    // Enhanced network logging with quality assessment\n    logNetworkEvent(eventId, startTime, acknowledged, payloadSize) {\n        let retryCount = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 0;\n        const rtt = performance.now() - startTime;\n        const connectionQuality = this.assessConnectionQuality(rtt);\n        const networkMetric = {\n            eventId,\n            timestamp: Date.now(),\n            rtt,\n            acknowledged,\n            retryCount,\n            payloadSize,\n            connectionQuality\n        };\n        this.networkMetrics.push(networkMetric);\n        // console.group(`Network Event`);\n        // console.log('Event ID:', eventId);\n        // console.log('RTT:', `${rtt.toFixed(2)}ms`);\n        // console.log('Quality:', connectionQuality);\n        // console.log('Payload Size:', `${payloadSize} bytes`);\n        // console.log('Acknowledged:', acknowledged);\n        if (retryCount > 0) console.warn('Retry Count:', retryCount);\n        console.groupEnd();\n    }\n    assessConnectionQuality(rtt) {\n        if (rtt < 50) return 'excellent';\n        if (rtt < 100) return 'good';\n        if (rtt < 200) return 'fair';\n        if (rtt < 500) return 'decent';\n        return 'poor';\n    }\n    // Performance monitoring\n    startPerformanceMonitoring() {\n        if ( false || typeof requestAnimationFrame === 'undefined') {\n            console.warn('Performance monitoring not available in this environment');\n            return;\n        }\n        const monitor = ()=>{\n            const now = performance.now();\n            const deltaTime = now - this.lastFPSCheck;\n            if (deltaTime >= 1000) {\n                var _performance_memory;\n                // if its been a second\n                const fps = this.frameCount * 1000 / deltaTime;\n                const memoryUsage = ((_performance_memory = performance.memory) === null || _performance_memory === void 0 ? void 0 : _performance_memory.usedJSHeapSize) || 0;\n                const perfMetric = {\n                    timestamp: Date.now(),\n                    fps: Math.round(fps),\n                    memoryUsage,\n                    canvasRenderTime: 0,\n                    eventProcessingTime: 0,\n                    queuedEvents: this.eventQueue.length\n                };\n                this.performanceMetrics.push(perfMetric);\n                this.frameCount = 0;\n                this.lastFPSCheck = now;\n                // Log performance warnings\n                if (fps < 30) {\n                    console.warn(\"Low FPS detected: \".concat(fps.toFixed(1)));\n                }\n                if (this.eventQueue.length > 10) {\n                    console.warn(\"Event queue backlog: \".concat(this.eventQueue.length, \" events\"));\n                }\n            }\n            this.frameCount++;\n            requestAnimationFrame(monitor);\n        };\n        requestAnimationFrame(monitor);\n    }\n    // Update user behavior metrics\n    updateUserBehavior(event) {\n        switch(event.eventType){\n            case 'stroke_start':\n                this.userBehavior.totalStrokes++;\n                this.currentStrokeStart = event.timestamp;\n                break;\n            case 'stroke_end':\n                if (this.currentStrokeStart) {\n                    const strokeDuration = event.timestamp - this.currentStrokeStart;\n                    this.userBehavior.totalDrawingTime += strokeDuration;\n                }\n                break;\n            case 'undo':\n                this.userBehavior.undoCount++;\n                break;\n            case 'redo':\n                this.userBehavior.redoCount++;\n                break;\n            case 'canvas_clear':\n                this.userBehavior.canvasClearCount++;\n                break;\n        }\n    }\n    // Enhanced socket emission with comprehensive logging\n    emitWithLogging(socket, eventName, data) {\n        let options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};\n        return new Promise((resolve)=>{\n            const startTime = performance.now();\n            const eventId = this.logDrawingEvent('stroke_continue', data);\n            const payloadSize = object_sizeof__WEBPACK_IMPORTED_MODULE_0___default()(data);\n            let retryCount = 0;\n            const maxRetries = options.retryCount || 3;\n            const attempt = ()=>{\n                socket.emit(eventName, data, (ack)=>{\n                    this.logNetworkEvent(eventId, startTime, ack, payloadSize, retryCount);\n                    if (ack) {\n                        resolve(true);\n                    } else if (retryCount < maxRetries) {\n                        retryCount++;\n                        console.warn(\"Retrying event \".concat(eventId, \" (attempt \").concat(retryCount, \"/\").concat(maxRetries, \")\"));\n                        setTimeout(attempt, 100 * retryCount); // Exponential backoff\n                    } else {\n                        console.error(\"Event \".concat(eventId, \" failed after \").concat(maxRetries, \" retries\"));\n                        resolve(false);\n                    }\n                });\n            };\n            attempt();\n        });\n    }\n    // Data export and analysis methods\n    exportAnalytics() {\n        return {\n            session: this.userBehavior,\n            events: this.events,\n            network: this.networkMetrics,\n            performance: this.performanceMetrics,\n            summary: this.generateSummary()\n        };\n    }\n    generateSummary() {\n        const totalEvents = this.events.length;\n        const avgRTT = this.networkMetrics.reduce((sum, m)=>sum + m.rtt, 0) / this.networkMetrics.length || 0;\n        const acknowledgedMessages = this.networkMetrics.filter((m)=>m.acknowledged);\n        const nackMessages = this.networkMetrics.filter((m)=>!m.acknowledged);\n        const failedDataSend = nackMessages.reduce((sum, i)=>sum + i.payloadSize, 0);\n        const successRate = acknowledgedMessages.length / this.networkMetrics.length * 100 || 0;\n        const totalDataSend = acknowledgedMessages.reduce((sum, i)=>sum + i.payloadSize, 0);\n        const totalDataAttempted = totalDataSend + failedDataSend;\n        const dataEfficiencyRate = totalDataSend / totalDataAttempted * 100;\n        const avgSuccessfulPayloadSize = totalDataSend / acknowledgedMessages.length;\n        const avgFailedPayloadSize = failedDataSend / nackMessages.length;\n        const avgFPS = this.performanceMetrics.reduce((sum, m)=>sum + m.fps, 0) / this.performanceMetrics.length || 0;\n        return {\n            totalEvents,\n            avgRTT: Math.round(avgRTT * 100) / 100,\n            successRate: Math.round(successRate * 100) / 100,\n            avgFPS: Math.round(avgFPS),\n            totalDataSend: Math.round(totalDataSend),\n            dataEfficiencyRate: Math.round(dataEfficiencyRate),\n            avgSuccessfulPayloadSize: Math.round(avgSuccessfulPayloadSize),\n            avgFailedPayloadSize: Math.round(avgFailedPayloadSize),\n            sessionDuration: Date.now() - this.userBehavior.sessionStart,\n            networkQualityDistribution: this.getNetworkQualityDistribution()\n        };\n    }\n    getNetworkQualityDistribution() {\n        const distribution = {\n            excellent: 0,\n            good: 0,\n            fair: 0,\n            poor: 0,\n            decent: 0\n        };\n        this.networkMetrics.forEach((metric)=>{\n            distribution[metric.connectionQuality]++;\n        });\n        return distribution;\n    }\n    // Real-time monitoring dashboard (console-based)\n    startRealtimeMonitoring() {\n        let intervalMs = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 5000;\n        setInterval(()=>{\n            const summary = this.generateSummary();\n            console.log('Session Duration:', \"\".concat(Math.round(summary.sessionDuration / 1000), \"s\"));\n            console.log('local storage', this.storage.getStorageInfo());\n            // console.log('Total Events:', summary.totalEvents);\n            // console.log('Average RTT:', `${summary.avgRTT}ms`);\n            // console.log('Success Rate:', `${summary.successRate}%`);\n            // console.log('Average FPS:', summary.avgFPS);\n            // console.log('Network Quality:', summary.networkQualityDistribution);\n            console.groupEnd();\n        }, intervalMs);\n    }\n    // Cleanup\n    destroy() {\n        if (this.syncTimer) {\n            clearInterval(this.syncTimer);\n        }\n        this.syncNow(); // Final sync\n    }\n    constructor(userId, intervalMs = 30000){\n        this.events = [];\n        this.networkMetrics = [];\n        this.performanceMetrics = [];\n        this.lastActivity = Date.now();\n        this.frameCount = 0;\n        this.lastFPSCheck = performance.now();\n        this.eventQueue = [];\n        this.sessionId = this.generateId();\n        this.userId = userId;\n        this.userBehavior = this.initializeUserBehavior();\n        this.storage = new _AnalyticsLocalStorageManager__WEBPACK_IMPORTED_MODULE_1__[\"default\"]();\n        this.startPerformanceMonitoring();\n        this.startPeriodicSync(intervalMs);\n        // Load existing data from localStorage\n        this.loadFromStorage();\n        // Sync on page unload\n        window.addEventListener('beforeunload', ()=>{\n            this.syncNow();\n        });\n    }\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (DrawingAnalytics);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy91dGlsL0RyYXdpbmdBbmFseXRpY3MudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFtQztBQUN1QztBQXVEMUUsTUFBTUU7SUErQkdDLGFBQXFCO1FBQzVCLE9BQU8sR0FBaUJDLE9BQWRDLEtBQUtDLEdBQUcsSUFBRyxLQUEyQyxPQUF4Q0YsS0FBS0csTUFBTSxHQUFHQyxRQUFRLENBQUMsSUFBSUMsTUFBTSxDQUFDLEdBQUc7SUFDOUQ7SUFFUUMsa0JBQXdCO1FBQy9CLHdEQUF3RDtRQUN4RCxNQUFNQyxtQkFBbUIsSUFBSSxDQUFDQyxPQUFPLENBQUNDLGVBQWU7UUFDckQsSUFBSUYsb0JBQW9CQSxpQkFBaUJHLFNBQVMsS0FBSyxJQUFJLENBQUNBLFNBQVMsRUFBRTtZQUN0RSxJQUFJLENBQUNDLFlBQVksR0FBR0o7UUFDckI7SUFDRDtJQUVRSyx5QkFBOEM7UUFDckQsT0FBTztZQUNORixXQUFXLElBQUksQ0FBQ0EsU0FBUztZQUN6QkcsUUFBUSxJQUFJLENBQUNBLE1BQU07WUFDbkJDLGNBQWNiLEtBQUtDLEdBQUc7WUFDdEJhLGNBQWM7WUFDZEMscUJBQXFCO1lBQ3JCQyxjQUFjO1lBQ2RDLGVBQWU7WUFDZkMsa0JBQWtCO1lBQ2xCQyxVQUFVO1lBQ1ZDLFdBQVc7WUFDWEMsV0FBVztZQUNYQyxrQkFBa0I7UUFDbkI7SUFDRDtJQUVRQyxrQkFBa0JDLFVBQWtCLEVBQVE7UUFDbkRDLFFBQVFDLEdBQUcsQ0FBQztRQUVaLElBQUksQ0FBQ0MsU0FBUyxHQUFHQyxZQUFZO1lBQzVCLE1BQU0sSUFBSSxDQUFDQyxPQUFPO1FBQ25CLEdBQUdMO0lBQ0o7SUFFQSxzQkFBc0I7SUFDdEIsTUFBTUssVUFBNEI7UUFDakNKLFFBQVFDLEdBQUcsQ0FBQztRQUVaLDZCQUE2QjtRQUM3QixJQUFJLENBQUNuQixPQUFPLENBQUN1QixZQUFZLENBQUMsSUFBSSxDQUFDckIsU0FBUztRQUV4Qyw4QkFBOEI7UUFDOUIsTUFBTXNC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Q3RELDJEQUEyRDtZQUMzRCwrQ0FBK0M7WUFDL0MsdUVBQXVFO1lBRXZFdkcsUUFBUW9CLFFBQVE7UUFDakIsR0FBR3JCO0lBQ0o7SUFDQSxVQUFVO0lBQ1Z5RyxVQUFnQjtRQUNmLElBQUksSUFBSSxDQUFDdEcsU0FBUyxFQUFFO1lBQ25CdUcsY0FBYyxJQUFJLENBQUN2RyxTQUFTO1FBQzdCO1FBQ0EsSUFBSSxDQUFDRSxPQUFPLElBQUksYUFBYTtJQUM5QjtJQTdYQXNHLFlBQVl2SCxNQUFlLEVBQUVZLGFBQXFCLEtBQUssQ0FBRTthQVhqRGlCLFNBQXlCLEVBQUU7YUFFM0JrQixpQkFBbUMsRUFBRTthQUNyQ21CLHFCQUEyQyxFQUFFO2FBRTdDbEMsZUFBdUI1QyxLQUFLQyxHQUFHO2FBRS9Ca0UsYUFBYTthQUNiRixlQUFlVixZQUFZdEQsR0FBRzthQUM5QjJFLGFBQW9CLEVBQUU7UUFHN0IsSUFBSSxDQUFDbkUsU0FBUyxHQUFHLElBQUksQ0FBQ1gsVUFBVTtRQUNoQyxJQUFJLENBQUNjLE1BQU0sR0FBR0E7UUFDZCxJQUFJLENBQUNGLFlBQVksR0FBRyxJQUFJLENBQUNDLHNCQUFzQjtRQUMvQyxJQUFJLENBQUNKLE9BQU8sR0FBRyxJQUFJWCxxRUFBNEJBO1FBQy9DLElBQUksQ0FBQ2lFLDBCQUEwQjtRQUMvQixJQUFJLENBQUN0QyxpQkFBaUIsQ0FBQ0M7UUFDdkIsdUNBQXVDO1FBQ3ZDLElBQUksQ0FBQ25CLGVBQWU7UUFFcEIsc0JBQXNCO1FBQ3RCK0gsT0FBT0MsZ0JBQWdCLENBQUMsZ0JBQWdCO1lBQ3ZDLElBQUksQ0FBQ3hHLE9BQU87UUFDYjtJQUNEO0FBZ1hEO0FBRUEsaUVBQWVoQyxnQkFBZ0JBLEVBQUMiLCJzb3VyY2VzIjpbIi9Vc2Vycy9lbXJleWlsZGlyaW0vRGVza3RvcC9maW5hbFByb2plY3QvY2xpZW50L3NyYy91dGlsL0RyYXdpbmdBbmFseXRpY3MudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHNpemVvZiBmcm9tICdvYmplY3Qtc2l6ZW9mJztcbmltcG9ydCBBbmFseXRpY3NMb2NhbFN0b3JhZ2VNYW5hZ2VyIGZyb20gJy4vQW5hbHl0aWNzTG9jYWxTdG9yYWdlTWFuYWdlcic7XG5pbnRlcmZhY2UgRHJhd2luZ0V2ZW50IHtcblx0ZXZlbnRJZDogc3RyaW5nO1xuXHR0aW1lc3RhbXA6IG51bWJlcjtcblx0ZXZlbnRUeXBlOlxuXHRcdHwgJ3N0cm9rZV9zdGFydCdcblx0XHR8ICdzdHJva2VfY29udGludWUnXG5cdFx0fCAnc3Ryb2tlX2VuZCdcblx0XHR8ICdjYW52YXNfY2xlYXInXG5cdFx0fCAndW5kbydcblx0XHR8ICdyZWRvJztcblx0c3Ryb2tlSWQ/OiBzdHJpbmc7XG5cdGNvb3JkaW5hdGVzPzogeyB4OiBudW1iZXI7IHk6IG51bWJlciB9O1xuXHRwcmVzc3VyZT86IG51bWJlcjtcblx0dG9vbD86IHN0cmluZztcblx0Y29sb3I/OiBzdHJpbmc7XG5cdGJydXNoU2l6ZT86IG51bWJlcjtcblx0dXNlcklkPzogc3RyaW5nO1xuXHRzZXNzaW9uSWQ6IHN0cmluZztcbn1cblxuaW50ZXJmYWNlIE5ldHdvcmtNZXRyaWNzIHtcblx0ZXZlbnRJZDogc3RyaW5nO1xuXHR0aW1lc3RhbXA6IG51bWJlcjtcblx0cnR0OiBudW1iZXI7XG5cdGFja25vd2xlZGdlZDogYm9vbGVhbjtcblx0cmV0cnlDb3VudDogbnVtYmVyO1xuXHRwYXlsb2FkU2l6ZTogbnVtYmVyO1xuXHRjb25uZWN0aW9uUXVhbGl0eTogJ2V4Y2VsbGVudCcgfCAnZ29vZCcgfCAnZmFpcicgfCAnZGVjZW50JyB8ICdwb29yJztcbn1cblxuaW50ZXJmYWNlIFBlcmZvcm1hbmNlTWV0cmljcyB7XG5cdHRpbWVzdGFtcDogbnVtYmVyO1xuXHRmcHM6IG51bWJlcjtcblx0bWVtb3J5VXNhZ2U6IG51bWJlcjtcblx0Y2FudmFzUmVuZGVyVGltZTogbnVtYmVyO1xuXHRldmVudFByb2Nlc3NpbmdUaW1lOiBudW1iZXI7XG5cdHF1ZXVlZEV2ZW50czogbnVtYmVyO1xufVxuXG5pbnRlcmZhY2UgVXNlckJlaGF2aW9yTWV0cmljcyB7XG5cdHNlc3Npb25JZDogc3RyaW5nO1xuXHR1c2VySWQ/OiBzdHJpbmc7XG5cdHNlc3Npb25TdGFydDogbnVtYmVyO1xuXHR0b3RhbFN0cm9rZXM6IG51bWJlcjtcblx0YXZlcmFnZVN0cm9rZUxlbmd0aDogbnVtYmVyO1xuXHRtb3N0VXNlZFRvb2w6IHN0cmluZztcblx0bW9zdFVzZWRDb2xvcjogc3RyaW5nO1xuXHR0b3RhbERyYXdpbmdUaW1lOiBudW1iZXI7XG5cdGlkbGVUaW1lOiBudW1iZXI7XG5cdHVuZG9Db3VudDogbnVtYmVyO1xuXHRyZWRvQ291bnQ6IG51bWJlcjtcblx0Y2FudmFzQ2xlYXJDb3VudDogbnVtYmVyO1xufVxuXG5jbGFzcyBEcmF3aW5nQW5hbHl0aWNzIHtcblx0cHJpdmF0ZSBzZXNzaW9uSWQ6IHN0cmluZztcblx0cHJpdmF0ZSBzdG9yYWdlOiBBbmFseXRpY3NMb2NhbFN0b3JhZ2VNYW5hZ2VyO1xuXHRwcml2YXRlIHVzZXJJZD86IHN0cmluZztcblx0cHJpdmF0ZSBldmVudHM6IERyYXdpbmdFdmVudFtdID0gW107XG5cdHByaXZhdGUgc3luY1RpbWVyOiBOb2RlSlMuVGltZW91dDtcblx0cHJpdmF0ZSBuZXR3b3JrTWV0cmljczogTmV0d29ya01ldHJpY3NbXSA9IFtdO1xuXHRwcml2YXRlIHBlcmZvcm1hbmNlTWV0cmljczogUGVyZm9ybWFuY2VNZXRyaWNzW10gPSBbXTtcblx0cHJpdmF0ZSB1c2VyQmVoYXZpb3I6IFVzZXJCZWhhdmlvck1ldHJpY3M7XG5cdHByaXZhdGUgbGFzdEFjdGl2aXR5OiBudW1iZXIgPSBEYXRlLm5vdygpO1xuXHRwcml2YXRlIGN1cnJlbnRTdHJva2VTdGFydD86IG51bWJlcjtcblx0cHJpdmF0ZSBmcmFtZUNvdW50ID0gMDtcblx0cHJpdmF0ZSBsYXN0RlBTQ2hlY2sgPSBwZXJmb3JtYW5jZS5ub3coKTtcblx0cHJpdmF0ZSBldmVudFF1ZXVlOiBhbnlbXSA9IFtdO1xuXG5cdGNvbnN0cnVjdG9yKHVzZXJJZD86IHN0cmluZywgaW50ZXJ2YWxNczogbnVtYmVyID0gMzAwMDApIHtcblx0XHR0aGlzLnNlc3Npb25JZCA9IHRoaXMuZ2VuZXJhdGVJZCgpO1xuXHRcdHRoaXMudXNlcklkID0gdXNlcklkO1xuXHRcdHRoaXMudXNlckJlaGF2aW9yID0gdGhpcy5pbml0aWFsaXplVXNlckJlaGF2aW9yKCk7XG5cdFx0dGhpcy5zdG9yYWdlID0gbmV3IEFuYWx5dGljc0xvY2FsU3RvcmFnZU1hbmFnZXIoKTtcblx0XHR0aGlzLnN0YXJ0UGVyZm9ybWFuY2VNb25pdG9yaW5nKCk7XG5cdFx0dGhpcy5zdGFydFBlcmlvZGljU3luYyhpbnRlcnZhbE1zKTtcblx0XHQvLyBMb2FkIGV4aXN0aW5nIGRhdGEgZnJvbSBsb2NhbFN0b3JhZ2Vcblx0XHR0aGlzLmxvYWRGcm9tU3RvcmFnZSgpO1xuXG5cdFx0Ly8gU3luYyBvbiBwYWdlIHVubG9hZFxuXHRcdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdiZWZvcmV1bmxvYWQnLCAoKSA9PiB7XG5cdFx0XHR0aGlzLnN5bmNOb3coKTtcblx0XHR9KTtcblx0fVxuXG5cdHByaXZhdGUgZ2VuZXJhdGVJZCgpOiBzdHJpbmcge1xuXHRcdHJldHVybiBgJHtEYXRlLm5vdygpfS0ke01hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cigyLCA5KX1gO1xuXHR9XG5cblx0cHJpdmF0ZSBsb2FkRnJvbVN0b3JhZ2UoKTogdm9pZCB7XG5cdFx0Ly8gTG9hZCBleGlzdGluZyBkYXRhIGlmIGFueSAodXNlZnVsIGZvciBwYWdlIHJlZnJlc2hlcylcblx0XHRjb25zdCBleGlzdGluZ0JlaGF2aW9yID0gdGhpcy5zdG9yYWdlLmdldFVzZXJCZWhhdmlvcigpO1xuXHRcdGlmIChleGlzdGluZ0JlaGF2aW9yICYmIGV4aXN0aW5nQmVoYXZpb3Iuc2Vzc2lvbklkID09PSB0aGlzLnNlc3Npb25JZCkge1xuXHRcdFx0dGhpcy51c2VyQmVoYXZpb3IgPSBleGlzdGluZ0JlaGF2aW9yO1xuXHRcdH1cblx0fVxuXG5cdHByaXZhdGUgaW5pdGlhbGl6ZVVzZXJCZWhhdmlvcigpOiBVc2VyQmVoYXZpb3JNZXRyaWNzIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0c2Vzc2lvbklkOiB0aGlzLnNlc3Npb25JZCxcblx0XHRcdHVzZXJJZDogdGhpcy51c2VySWQsXG5cdFx0XHRzZXNzaW9uU3RhcnQ6IERhdGUubm93KCksXG5cdFx0XHR0b3RhbFN0cm9rZXM6IDAsXG5cdFx0XHRhdmVyYWdlU3Ryb2tlTGVuZ3RoOiAwLFxuXHRcdFx0bW9zdFVzZWRUb29sOiAnJyxcblx0XHRcdG1vc3RVc2VkQ29sb3I6ICcnLFxuXHRcdFx0dG90YWxEcmF3aW5nVGltZTogMCxcblx0XHRcdGlkbGVUaW1lOiAwLFxuXHRcdFx0dW5kb0NvdW50OiAwLFxuXHRcdFx0cmVkb0NvdW50OiAwLFxuXHRcdFx0Y2FudmFzQ2xlYXJDb3VudDogMCxcblx0XHR9O1xuXHR9XG5cblx0cHJpdmF0ZSBzdGFydFBlcmlvZGljU3luYyhpbnRlcnZhbE1zOiBudW1iZXIpOiB2b2lkIHtcblx0XHRjb25zb2xlLmxvZygnc3RhcnRQZXJpb2RpY1N5bmMnKTtcblxuXHRcdHRoaXMuc3luY1RpbWVyID0gc2V0SW50ZXJ2YWwoYXN5bmMgKCkgPT4ge1xuXHRcdFx0YXdhaXQgdGhpcy5zeW5jTm93KCk7XG5cdFx0fSwgaW50ZXJ2YWxNcyk7XG5cdH1cblxuXHQvLyBNYW51YWwgc3luYyB0cmlnZ2VyXG5cdGFzeW5jIHN5bmNOb3coKTogUHJvbWlzZTxib29sZWFuPiB7XG5cdFx0Y29uc29sZS5sb2coJ1N0YXJ0aW5nIGFuYWx5dGljcyBzeW5jLi4uJyk7XG5cblx0XHQvLyBRdWV1ZSBjdXJyZW50IHNlc3Npb24gZGF0YVxuXHRcdHRoaXMuc3RvcmFnZS5xdWV1ZUZvclN5bmModGhpcy5zZXNzaW9uSWQpO1xuXG5cdFx0Ly8gVHJ5IHRvIHN5bmMgYWxsIHF1ZXVlZCBkYXRhXG5cdFx0Y29uc3Qgc3luY1F1ZXVlID0gdGhpcy5zdG9yYWdlLmdldFN5bmNRdWV1ZSgpO1xuXHRcdGxldCBzeW5jZWRDb3VudCA9IDA7XG5cblx0XHQvLyB0b2RvIHNlbmQgdG8gdGhlIGJhY2tlbmRcblx0XHQvLyBmb3IgKGNvbnN0IHBheWxvYWQgb2Ygc3luY1F1ZXVlKSB7XG5cdFx0Ly8gaWYgKHN1Y2Nlc3MpIHtcblx0XHQvLyBcdHRoaXMuc3RvcmFnZS5jbGVhclN5bmNlZERhdGEocGF5bG9hZC50aW1lc3RhbXApO1xuXHRcdC8vIFx0c3luY2VkQ291bnQrKztcblx0XHQvLyB9IGVsc2Uge1xuXHRcdC8vIFx0YnJlYWs7IC8vIFN0b3Agb24gZmlyc3QgZmFpbHVyZSB0byBtYWludGFpbiBvcmRlclxuXHRcdC8vIH1cblx0XHQvLyB9XG5cblx0XHRpZiAoc3luY2VkQ291bnQgPiAwKSB7XG5cdFx0XHRjb25zb2xlLmxvZyhgU3luY2VkICR7c3luY2VkQ291bnR9IGFuYWx5dGljcyBwYXlsb2Fkc2ApO1xuXHRcdFx0Ly8gQ2xlYXIgbG9jYWwgZGF0YSBhZnRlciBzdWNjZXNzZnVsIHN5bmNcblx0XHRcdHRoaXMuc3RvcmFnZS5jbGVhckxvY2FsRGF0YSgpO1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0Ly8gRW5oYW5jZWQgZHJhd2luZyBldmVudCBsb2dnaW5nIHdpdGggY29tcHJlaGVuc2l2ZSBkYXRhXG5cdGxvZ0RyYXdpbmdFdmVudChcblx0XHRldmVudFR5cGU6IERyYXdpbmdFdmVudFsnZXZlbnRUeXBlJ10sXG5cdFx0ZGF0YToge1xuXHRcdFx0Y29vcmRpbmF0ZXM/OiB7IHg6IG51bWJlcjsgeTogbnVtYmVyIH07XG5cdFx0XHRwcmVzc3VyZT86IG51bWJlcjtcblx0XHRcdHRvb2w/OiBzdHJpbmc7XG5cdFx0XHRjb2xvcj86IHN0cmluZztcblx0XHRcdGJydXNoU2l6ZT86IG51bWJlcjtcblx0XHRcdHN0cm9rZUlkPzogc3RyaW5nO1xuXHRcdH0gPSB7fVxuXHQpOiBzdHJpbmcge1xuXHRcdGNvbnN0IGV2ZW50SWQgPSB0aGlzLmdlbmVyYXRlSWQoKTtcblx0XHRjb25zdCB0aW1lc3RhbXAgPSBEYXRlLm5vdygpO1xuXG5cdFx0Y29uc3QgZXZlbnQ6IERyYXdpbmdFdmVudCA9IHtcblx0XHRcdGV2ZW50SWQsXG5cdFx0XHR0aW1lc3RhbXAsXG5cdFx0XHRldmVudFR5cGUsXG5cdFx0XHRzZXNzaW9uSWQ6IHRoaXMuc2Vzc2lvbklkLFxuXHRcdFx0dXNlcklkOiB0aGlzLnVzZXJJZCxcblx0XHRcdC4uLmRhdGEsXG5cdFx0fTtcblxuXHRcdHRoaXMuZXZlbnRzLnB1c2goZXZlbnQpO1xuXHRcdHRoaXMudXBkYXRlVXNlckJlaGF2aW9yKGV2ZW50KTtcblx0XHR0aGlzLmxhc3RBY3Rpdml0eSA9IHRpbWVzdGFtcDtcblxuXHRcdC8vIExvZyB0byBjb25zb2xlIHdpdGggc3RydWN0dXJlZCBmb3JtYXRcblx0XHQvLyBjb25zb2xlLmdyb3VwKGBEcmF3aW5nIEV2ZW50OiAke2V2ZW50VHlwZX1gKTtcblx0XHQvLyBjb25zb2xlLmxvZygnRXZlbnQgSUQ6JywgZXZlbnRJZCk7XG5cdFx0Ly8gY29uc29sZS5sb2coJ1RpbWVzdGFtcDonLCBuZXcgRGF0ZSh0aW1lc3RhbXApLnRvSVNPU3RyaW5nKCkpO1xuXHRcdC8vIGNvbnNvbGUubG9nKCdEYXRhOicsIGRhdGEpO1xuXHRcdGNvbnNvbGUuZ3JvdXBFbmQoKTtcblx0XHR0aGlzLnN0b3JhZ2UuYXBwZW5kRGF0YSh0aGlzLnN0b3JhZ2UuU1RPUkFHRV9LRVlTLkVWRU5UUyk7XG5cblx0XHRyZXR1cm4gZXZlbnRJZDtcblx0fVxuXG5cdC8vIEVuaGFuY2VkIG5ldHdvcmsgbG9nZ2luZyB3aXRoIHF1YWxpdHkgYXNzZXNzbWVudFxuXHRsb2dOZXR3b3JrRXZlbnQoXG5cdFx0ZXZlbnRJZDogc3RyaW5nLFxuXHRcdHN0YXJ0VGltZTogbnVtYmVyLFxuXHRcdGFja25vd2xlZGdlZDogYm9vbGVhbixcblx0XHRwYXlsb2FkU2l6ZTogbnVtYmVyLFxuXHRcdHJldHJ5Q291bnQ6IG51bWJlciA9IDBcblx0KTogdm9pZCB7XG5cdFx0Y29uc3QgcnR0ID0gcGVyZm9ybWFuY2Uubm93KCkgLSBzdGFydFRpbWU7XG5cdFx0Y29uc3QgY29ubmVjdGlvblF1YWxpdHkgPSB0aGlzLmFzc2Vzc0Nvbm5lY3Rpb25RdWFsaXR5KHJ0dCk7XG5cblx0XHRjb25zdCBuZXR3b3JrTWV0cmljOiBOZXR3b3JrTWV0cmljcyA9IHtcblx0XHRcdGV2ZW50SWQsXG5cdFx0XHR0aW1lc3RhbXA6IERhdGUubm93KCksXG5cdFx0XHRydHQsXG5cdFx0XHRhY2tub3dsZWRnZWQsXG5cdFx0XHRyZXRyeUNvdW50LFxuXHRcdFx0cGF5bG9hZFNpemUsXG5cdFx0XHRjb25uZWN0aW9uUXVhbGl0eSxcblx0XHR9O1xuXG5cdFx0dGhpcy5uZXR3b3JrTWV0cmljcy5wdXNoKG5ldHdvcmtNZXRyaWMpO1xuXG5cdFx0Ly8gY29uc29sZS5ncm91cChgTmV0d29yayBFdmVudGApO1xuXHRcdC8vIGNvbnNvbGUubG9nKCdFdmVudCBJRDonLCBldmVudElkKTtcblx0XHQvLyBjb25zb2xlLmxvZygnUlRUOicsIGAke3J0dC50b0ZpeGVkKDIpfW1zYCk7XG5cdFx0Ly8gY29uc29sZS5sb2coJ1F1YWxpdHk6JywgY29ubmVjdGlvblF1YWxpdHkpO1xuXHRcdC8vIGNvbnNvbGUubG9nKCdQYXlsb2FkIFNpemU6JywgYCR7cGF5bG9hZFNpemV9IGJ5dGVzYCk7XG5cdFx0Ly8gY29uc29sZS5sb2coJ0Fja25vd2xlZGdlZDonLCBhY2tub3dsZWRnZWQpO1xuXHRcdGlmIChyZXRyeUNvdW50ID4gMCkgY29uc29sZS53YXJuKCdSZXRyeSBDb3VudDonLCByZXRyeUNvdW50KTtcblx0XHRjb25zb2xlLmdyb3VwRW5kKCk7XG5cdH1cblxuXHRwcml2YXRlIGFzc2Vzc0Nvbm5lY3Rpb25RdWFsaXR5KFxuXHRcdHJ0dDogbnVtYmVyXG5cdCk6IE5ldHdvcmtNZXRyaWNzWydjb25uZWN0aW9uUXVhbGl0eSddIHtcblx0XHRpZiAocnR0IDwgNTApIHJldHVybiAnZXhjZWxsZW50Jztcblx0XHRpZiAocnR0IDwgMTAwKSByZXR1cm4gJ2dvb2QnO1xuXHRcdGlmIChydHQgPCAyMDApIHJldHVybiAnZmFpcic7XG5cdFx0aWYgKHJ0dCA8IDUwMCkgcmV0dXJuICdkZWNlbnQnO1xuXHRcdHJldHVybiAncG9vcic7XG5cdH1cblxuXHQvLyBQZXJmb3JtYW5jZSBtb25pdG9yaW5nXG5cdHByaXZhdGUgc3RhcnRQZXJmb3JtYW5jZU1vbml0b3JpbmcoKTogdm9pZCB7XG5cdFx0aWYgKFxuXHRcdFx0dHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgfHxcblx0XHRcdHR5cGVvZiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPT09ICd1bmRlZmluZWQnXG5cdFx0KSB7XG5cdFx0XHRjb25zb2xlLndhcm4oJ1BlcmZvcm1hbmNlIG1vbml0b3Jpbmcgbm90IGF2YWlsYWJsZSBpbiB0aGlzIGVudmlyb25tZW50Jyk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdGNvbnN0IG1vbml0b3IgPSAoKSA9PiB7XG5cdFx0XHRjb25zdCBub3cgPSBwZXJmb3JtYW5jZS5ub3coKTtcblx0XHRcdGNvbnN0IGRlbHRhVGltZSA9IG5vdyAtIHRoaXMubGFzdEZQU0NoZWNrO1xuXG5cdFx0XHRpZiAoZGVsdGFUaW1lID49IDEwMDApIHtcblx0XHRcdFx0Ly8gaWYgaXRzIGJlZW4gYSBzZWNvbmRcblx0XHRcdFx0Y29uc3QgZnBzID0gKHRoaXMuZnJhbWVDb3VudCAqIDEwMDApIC8gZGVsdGFUaW1lO1xuXHRcdFx0XHRjb25zdCBtZW1vcnlVc2FnZSA9IChwZXJmb3JtYW5jZSBhcyBhbnkpLm1lbW9yeT8udXNlZEpTSGVhcFNpemUgfHwgMDtcblxuXHRcdFx0XHRjb25zdCBwZXJmTWV0cmljOiBQZXJmb3JtYW5jZU1ldHJpY3MgPSB7XG5cdFx0XHRcdFx0dGltZXN0YW1wOiBEYXRlLm5vdygpLFxuXHRcdFx0XHRcdGZwczogTWF0aC5yb3VuZChmcHMpLFxuXHRcdFx0XHRcdG1lbW9yeVVzYWdlLFxuXHRcdFx0XHRcdGNhbnZhc1JlbmRlclRpbWU6IDAsIC8vIFlvdSdsbCBuZWVkIHRvIG1lYXN1cmUgdGhpcyBpbiB5b3VyIHJlbmRlciBsb29wXG5cdFx0XHRcdFx0ZXZlbnRQcm9jZXNzaW5nVGltZTogMCwgLy8gTWVhc3VyZSBpbiB5b3VyIGV2ZW50IGhhbmRsZXJzXG5cdFx0XHRcdFx0cXVldWVkRXZlbnRzOiB0aGlzLmV2ZW50UXVldWUubGVuZ3RoLFxuXHRcdFx0XHR9O1xuXG5cdFx0XHRcdHRoaXMucGVyZm9ybWFuY2VNZXRyaWNzLnB1c2gocGVyZk1ldHJpYyk7XG5cdFx0XHRcdHRoaXMuZnJhbWVDb3VudCA9IDA7XG5cdFx0XHRcdHRoaXMubGFzdEZQU0NoZWNrID0gbm93O1xuXG5cdFx0XHRcdC8vIExvZyBwZXJmb3JtYW5jZSB3YXJuaW5nc1xuXHRcdFx0XHRpZiAoZnBzIDwgMzApIHtcblx0XHRcdFx0XHRjb25zb2xlLndhcm4oYExvdyBGUFMgZGV0ZWN0ZWQ6ICR7ZnBzLnRvRml4ZWQoMSl9YCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHRoaXMuZXZlbnRRdWV1ZS5sZW5ndGggPiAxMCkge1xuXHRcdFx0XHRcdGNvbnNvbGUud2FybihgRXZlbnQgcXVldWUgYmFja2xvZzogJHt0aGlzLmV2ZW50UXVldWUubGVuZ3RofSBldmVudHNgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLmZyYW1lQ291bnQrKztcblx0XHRcdHJlcXVlc3RBbmltYXRpb25GcmFtZShtb25pdG9yKTtcblx0XHR9O1xuXG5cdFx0cmVxdWVzdEFuaW1hdGlvbkZyYW1lKG1vbml0b3IpO1xuXHR9XG5cblx0Ly8gVXBkYXRlIHVzZXIgYmVoYXZpb3IgbWV0cmljc1xuXHRwcml2YXRlIHVwZGF0ZVVzZXJCZWhhdmlvcihldmVudDogRHJhd2luZ0V2ZW50KTogdm9pZCB7XG5cdFx0c3dpdGNoIChldmVudC5ldmVudFR5cGUpIHtcblx0XHRcdGNhc2UgJ3N0cm9rZV9zdGFydCc6XG5cdFx0XHRcdHRoaXMudXNlckJlaGF2aW9yLnRvdGFsU3Ryb2tlcysrO1xuXHRcdFx0XHR0aGlzLmN1cnJlbnRTdHJva2VTdGFydCA9IGV2ZW50LnRpbWVzdGFtcDtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICdzdHJva2VfZW5kJzpcblx0XHRcdFx0aWYgKHRoaXMuY3VycmVudFN0cm9rZVN0YXJ0KSB7XG5cdFx0XHRcdFx0Y29uc3Qgc3Ryb2tlRHVyYXRpb24gPSBldmVudC50aW1lc3RhbXAgLSB0aGlzLmN1cnJlbnRTdHJva2VTdGFydDtcblx0XHRcdFx0XHR0aGlzLnVzZXJCZWhhdmlvci50b3RhbERyYXdpbmdUaW1lICs9IHN0cm9rZUR1cmF0aW9uO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAndW5kbyc6XG5cdFx0XHRcdHRoaXMudXNlckJlaGF2aW9yLnVuZG9Db3VudCsrO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgJ3JlZG8nOlxuXHRcdFx0XHR0aGlzLnVzZXJCZWhhdmlvci5yZWRvQ291bnQrKztcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICdjYW52YXNfY2xlYXInOlxuXHRcdFx0XHR0aGlzLnVzZXJCZWhhdmlvci5jYW52YXNDbGVhckNvdW50Kys7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdH1cblx0fVxuXG5cdC8vIEVuaGFuY2VkIHNvY2tldCBlbWlzc2lvbiB3aXRoIGNvbXByZWhlbnNpdmUgbG9nZ2luZ1xuXHRlbWl0V2l0aExvZ2dpbmcoXG5cdFx0c29ja2V0OiBhbnksXG5cdFx0ZXZlbnROYW1lOiBzdHJpbmcsXG5cdFx0ZGF0YTogYW55LFxuXHRcdG9wdGlvbnM6IHtcblx0XHRcdHRpbWVvdXQ/OiBudW1iZXI7XG5cdFx0XHRyZXRyeUNvdW50PzogbnVtYmVyO1xuXHRcdFx0cHJpb3JpdHk/OiAnaGlnaCcgfCAnbm9ybWFsJyB8ICdsb3cnO1xuXHRcdH0gPSB7fVxuXHQpOiBQcm9taXNlPGJvb2xlYW4+IHtcblx0XHRyZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcblx0XHRcdGNvbnN0IHN0YXJ0VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuXHRcdFx0Y29uc3QgZXZlbnRJZCA9IHRoaXMubG9nRHJhd2luZ0V2ZW50KCdzdHJva2VfY29udGludWUnLCBkYXRhKTtcblx0XHRcdGNvbnN0IHBheWxvYWRTaXplID0gc2l6ZW9mKGRhdGEpO1xuXHRcdFx0bGV0IHJldHJ5Q291bnQgPSAwO1xuXHRcdFx0Y29uc3QgbWF4UmV0cmllcyA9IG9wdGlvbnMucmV0cnlDb3VudCB8fCAzO1xuXG5cdFx0XHRjb25zdCBhdHRlbXB0ID0gKCkgPT4ge1xuXHRcdFx0XHRzb2NrZXQuZW1pdChldmVudE5hbWUsIGRhdGEsIChhY2s6IGJvb2xlYW4pID0+IHtcblx0XHRcdFx0XHR0aGlzLmxvZ05ldHdvcmtFdmVudChcblx0XHRcdFx0XHRcdGV2ZW50SWQsXG5cdFx0XHRcdFx0XHRzdGFydFRpbWUsXG5cdFx0XHRcdFx0XHRhY2ssXG5cdFx0XHRcdFx0XHRwYXlsb2FkU2l6ZSxcblx0XHRcdFx0XHRcdHJldHJ5Q291bnRcblx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdFx0aWYgKGFjaykge1xuXHRcdFx0XHRcdFx0cmVzb2x2ZSh0cnVlKTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKHJldHJ5Q291bnQgPCBtYXhSZXRyaWVzKSB7XG5cdFx0XHRcdFx0XHRyZXRyeUNvdW50Kys7XG5cdFx0XHRcdFx0XHRjb25zb2xlLndhcm4oXG5cdFx0XHRcdFx0XHRcdGBSZXRyeWluZyBldmVudCAke2V2ZW50SWR9IChhdHRlbXB0ICR7cmV0cnlDb3VudH0vJHttYXhSZXRyaWVzfSlgXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0c2V0VGltZW91dChhdHRlbXB0LCAxMDAgKiByZXRyeUNvdW50KTsgLy8gRXhwb25lbnRpYWwgYmFja29mZlxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRjb25zb2xlLmVycm9yKFxuXHRcdFx0XHRcdFx0XHRgRXZlbnQgJHtldmVudElkfSBmYWlsZWQgYWZ0ZXIgJHttYXhSZXRyaWVzfSByZXRyaWVzYFxuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdHJlc29sdmUoZmFsc2UpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cdFx0XHR9O1xuXG5cdFx0XHRhdHRlbXB0KCk7XG5cdFx0fSk7XG5cdH1cblxuXHQvLyBEYXRhIGV4cG9ydCBhbmQgYW5hbHlzaXMgbWV0aG9kc1xuXHRleHBvcnRBbmFseXRpY3MoKToge1xuXHRcdHNlc3Npb246IFVzZXJCZWhhdmlvck1ldHJpY3M7XG5cdFx0ZXZlbnRzOiBEcmF3aW5nRXZlbnRbXTtcblx0XHRuZXR3b3JrOiBOZXR3b3JrTWV0cmljc1tdO1xuXHRcdHBlcmZvcm1hbmNlOiBQZXJmb3JtYW5jZU1ldHJpY3NbXTtcblx0XHRzdW1tYXJ5OiBhbnk7XG5cdH0ge1xuXHRcdHJldHVybiB7XG5cdFx0XHRzZXNzaW9uOiB0aGlzLnVzZXJCZWhhdmlvcixcblx0XHRcdGV2ZW50czogdGhpcy5ldmVudHMsXG5cdFx0XHRuZXR3b3JrOiB0aGlzLm5ldHdvcmtNZXRyaWNzLFxuXHRcdFx0cGVyZm9ybWFuY2U6IHRoaXMucGVyZm9ybWFuY2VNZXRyaWNzLFxuXHRcdFx0c3VtbWFyeTogdGhpcy5nZW5lcmF0ZVN1bW1hcnkoKSxcblx0XHR9O1xuXHR9XG5cblx0cHJpdmF0ZSBnZW5lcmF0ZVN1bW1hcnkoKSB7XG5cdFx0Y29uc3QgdG90YWxFdmVudHMgPSB0aGlzLmV2ZW50cy5sZW5ndGg7XG5cdFx0Y29uc3QgYXZnUlRUID1cblx0XHRcdHRoaXMubmV0d29ya01ldHJpY3MucmVkdWNlKChzdW0sIG0pID0+IHN1bSArIG0ucnR0LCAwKSAvXG5cdFx0XHRcdHRoaXMubmV0d29ya01ldHJpY3MubGVuZ3RoIHx8IDA7XG5cdFx0Y29uc3QgYWNrbm93bGVkZ2VkTWVzc2FnZXMgPSB0aGlzLm5ldHdvcmtNZXRyaWNzLmZpbHRlcihcblx0XHRcdChtKSA9PiBtLmFja25vd2xlZGdlZFxuXHRcdCk7XG5cdFx0Y29uc3QgbmFja01lc3NhZ2VzID0gdGhpcy5uZXR3b3JrTWV0cmljcy5maWx0ZXIoKG0pID0+ICFtLmFja25vd2xlZGdlZCk7XG5cdFx0Y29uc3QgZmFpbGVkRGF0YVNlbmQgPSBuYWNrTWVzc2FnZXMucmVkdWNlKFxuXHRcdFx0KHN1bTogbnVtYmVyLCBpOiBOZXR3b3JrTWV0cmljcykgPT4gc3VtICsgaS5wYXlsb2FkU2l6ZSxcblx0XHRcdDBcblx0XHQpO1xuXG5cdFx0Y29uc3Qgc3VjY2Vzc1JhdGUgPVxuXHRcdFx0KGFja25vd2xlZGdlZE1lc3NhZ2VzLmxlbmd0aCAvIHRoaXMubmV0d29ya01ldHJpY3MubGVuZ3RoKSAqIDEwMCB8fCAwO1xuXHRcdGNvbnN0IHRvdGFsRGF0YVNlbmQgPSBhY2tub3dsZWRnZWRNZXNzYWdlcy5yZWR1Y2UoXG5cdFx0XHQoc3VtOiBudW1iZXIsIGk6IE5ldHdvcmtNZXRyaWNzKSA9PiBzdW0gKyBpLnBheWxvYWRTaXplLFxuXHRcdFx0MFxuXHRcdCk7XG5cdFx0Y29uc3QgdG90YWxEYXRhQXR0ZW1wdGVkID0gdG90YWxEYXRhU2VuZCArIGZhaWxlZERhdGFTZW5kO1xuXHRcdGNvbnN0IGRhdGFFZmZpY2llbmN5UmF0ZSA9ICh0b3RhbERhdGFTZW5kIC8gdG90YWxEYXRhQXR0ZW1wdGVkKSAqIDEwMDtcblx0XHRjb25zdCBhdmdTdWNjZXNzZnVsUGF5bG9hZFNpemUgPVxuXHRcdFx0dG90YWxEYXRhU2VuZCAvIGFja25vd2xlZGdlZE1lc3NhZ2VzLmxlbmd0aDtcblx0XHRjb25zdCBhdmdGYWlsZWRQYXlsb2FkU2l6ZSA9IGZhaWxlZERhdGFTZW5kIC8gbmFja01lc3NhZ2VzLmxlbmd0aDtcblxuXHRcdGNvbnN0IGF2Z0ZQUyA9XG5cdFx0XHR0aGlzLnBlcmZvcm1hbmNlTWV0cmljcy5yZWR1Y2UoKHN1bSwgbSkgPT4gc3VtICsgbS5mcHMsIDApIC9cblx0XHRcdFx0dGhpcy5wZXJmb3JtYW5jZU1ldHJpY3MubGVuZ3RoIHx8IDA7XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0dG90YWxFdmVudHMsXG5cdFx0XHRhdmdSVFQ6IE1hdGgucm91bmQoYXZnUlRUICogMTAwKSAvIDEwMCxcblx0XHRcdHN1Y2Nlc3NSYXRlOiBNYXRoLnJvdW5kKHN1Y2Nlc3NSYXRlICogMTAwKSAvIDEwMCxcblx0XHRcdGF2Z0ZQUzogTWF0aC5yb3VuZChhdmdGUFMpLFxuXHRcdFx0dG90YWxEYXRhU2VuZDogTWF0aC5yb3VuZCh0b3RhbERhdGFTZW5kKSxcblx0XHRcdGRhdGFFZmZpY2llbmN5UmF0ZTogTWF0aC5yb3VuZChkYXRhRWZmaWNpZW5jeVJhdGUpLFxuXHRcdFx0YXZnU3VjY2Vzc2Z1bFBheWxvYWRTaXplOiBNYXRoLnJvdW5kKGF2Z1N1Y2Nlc3NmdWxQYXlsb2FkU2l6ZSksXG5cdFx0XHRhdmdGYWlsZWRQYXlsb2FkU2l6ZTogTWF0aC5yb3VuZChhdmdGYWlsZWRQYXlsb2FkU2l6ZSksXG5cdFx0XHRzZXNzaW9uRHVyYXRpb246IERhdGUubm93KCkgLSB0aGlzLnVzZXJCZWhhdmlvci5zZXNzaW9uU3RhcnQsXG5cdFx0XHRuZXR3b3JrUXVhbGl0eURpc3RyaWJ1dGlvbjogdGhpcy5nZXROZXR3b3JrUXVhbGl0eURpc3RyaWJ1dGlvbigpLFxuXHRcdH07XG5cdH1cblxuXHRwcml2YXRlIGdldE5ldHdvcmtRdWFsaXR5RGlzdHJpYnV0aW9uKCkge1xuXHRcdGNvbnN0IGRpc3RyaWJ1dGlvbiA9IHsgZXhjZWxsZW50OiAwLCBnb29kOiAwLCBmYWlyOiAwLCBwb29yOiAwLCBkZWNlbnQ6IDAgfTtcblx0XHR0aGlzLm5ldHdvcmtNZXRyaWNzLmZvckVhY2goKG1ldHJpYykgPT4ge1xuXHRcdFx0ZGlzdHJpYnV0aW9uW21ldHJpYy5jb25uZWN0aW9uUXVhbGl0eV0rKztcblx0XHR9KTtcblx0XHRyZXR1cm4gZGlzdHJpYnV0aW9uO1xuXHR9XG5cblx0Ly8gUmVhbC10aW1lIG1vbml0b3JpbmcgZGFzaGJvYXJkIChjb25zb2xlLWJhc2VkKVxuXHRzdGFydFJlYWx0aW1lTW9uaXRvcmluZyhpbnRlcnZhbE1zOiBudW1iZXIgPSA1MDAwKTogdm9pZCB7XG5cdFx0c2V0SW50ZXJ2YWwoKCkgPT4ge1xuXHRcdFx0Y29uc3Qgc3VtbWFyeSA9IHRoaXMuZ2VuZXJhdGVTdW1tYXJ5KCk7XG5cdFx0XHRjb25zb2xlLmxvZyhcblx0XHRcdFx0J1Nlc3Npb24gRHVyYXRpb246Jyxcblx0XHRcdFx0YCR7TWF0aC5yb3VuZChzdW1tYXJ5LnNlc3Npb25EdXJhdGlvbiAvIDEwMDApfXNgXG5cdFx0XHQpO1xuXHRcdFx0Y29uc29sZS5sb2coJ2xvY2FsIHN0b3JhZ2UnLCB0aGlzLnN0b3JhZ2UuZ2V0U3RvcmFnZUluZm8oKSk7XG5cblx0XHRcdC8vIGNvbnNvbGUubG9nKCdUb3RhbCBFdmVudHM6Jywgc3VtbWFyeS50b3RhbEV2ZW50cyk7XG5cdFx0XHQvLyBjb25zb2xlLmxvZygnQXZlcmFnZSBSVFQ6JywgYCR7c3VtbWFyeS5hdmdSVFR9bXNgKTtcblx0XHRcdC8vIGNvbnNvbGUubG9nKCdTdWNjZXNzIFJhdGU6JywgYCR7c3VtbWFyeS5zdWNjZXNzUmF0ZX0lYCk7XG5cdFx0XHQvLyBjb25zb2xlLmxvZygnQXZlcmFnZSBGUFM6Jywgc3VtbWFyeS5hdmdGUFMpO1xuXHRcdFx0Ly8gY29uc29sZS5sb2coJ05ldHdvcmsgUXVhbGl0eTonLCBzdW1tYXJ5Lm5ldHdvcmtRdWFsaXR5RGlzdHJpYnV0aW9uKTtcblxuXHRcdFx0Y29uc29sZS5ncm91cEVuZCgpO1xuXHRcdH0sIGludGVydmFsTXMpO1xuXHR9XG5cdC8vIENsZWFudXBcblx0ZGVzdHJveSgpOiB2b2lkIHtcblx0XHRpZiAodGhpcy5zeW5jVGltZXIpIHtcblx0XHRcdGNsZWFySW50ZXJ2YWwodGhpcy5zeW5jVGltZXIpO1xuXHRcdH1cblx0XHR0aGlzLnN5bmNOb3coKTsgLy8gRmluYWwgc3luY1xuXHR9XG59XG5cbmV4cG9ydCBkZWZhdWx0IERyYXdpbmdBbmFseXRpY3M7XG4iXSwibmFtZXMiOlsic2l6ZW9mIiwiQW5hbHl0aWNzTG9jYWxTdG9yYWdlTWFuYWdlciIsIkRyYXdpbmdBbmFseXRpY3MiLCJnZW5lcmF0ZUlkIiwiTWF0aCIsIkRhdGUiLCJub3ciLCJyYW5kb20iLCJ0b1N0cmluZyIsInN1YnN0ciIsImxvYWRGcm9tU3RvcmFnZSIsImV4aXN0aW5nQmVoYXZpb3IiLCJzdG9yYWdlIiwiZ2V0VXNlckJlaGF2aW9yIiwic2Vzc2lvbklkIiwidXNlckJlaGF2aW9yIiwiaW5pdGlhbGl6ZVVzZXJCZWhhdmlvciIsInVzZXJJZCIsInNlc3Npb25TdGFydCIsInRvdGFsU3Ryb2tlcyIsImF2ZXJhZ2VTdHJva2VMZW5ndGgiLCJtb3N0VXNlZFRvb2wiLCJtb3N0VXNlZENvbG9yIiwidG90YWxEcmF3aW5nVGltZSIsImlkbGVUaW1lIiwidW5kb0NvdW50IiwicmVkb0NvdW50IiwiY2FudmFzQ2xlYXJDb3VudCIsInN0YXJ0UGVyaW9kaWNTeW5jIiwiaW50ZXJ2YWxNcyIsImNvbnNvbGUiLCJsb2ciLCJzeW5jVGltZXIiLCJzZXRJbnRlcnZhbCIsInN5bmNOb3ciLCJxdWV1ZUZvclN5bmMiLCJzeW5jUXVldWUiLCJnZXRTeW5jUXVldWUiLCJzeW5jZWRDb3VudCIsImNsZWFyTG9jYWxEYXRhIiwibG9nRHJhd2luZ0V2ZW50IiwiZXZlbnRUeXBlIiwiZGF0YSIsImV2ZW50SWQiLCJ0aW1lc3RhbXAiLCJldmVudCIsImV2ZW50cyIsInB1c2giLCJ1cGRhdGVVc2VyQmVoYXZpb3IiLCJsYXN0QWN0aXZpdHkiLCJncm91cEVuZCIsImFwcGVuZERhdGEiLCJTVE9SQUdFX0tFWVMiLCJFVkVOVFMiLCJsb2dOZXR3b3JrRXZlbnQiLCJzdGFydFRpbWUiLCJhY2tub3dsZWRnZWQiLCJwYXlsb2FkU2l6ZSIsInJldHJ5Q291bnQiLCJydHQiLCJwZXJmb3JtYW5jZSIsImNvbm5lY3Rpb25RdWFsaXR5IiwiYXNzZXNzQ29ubmVjdGlvblF1YWxpdHkiLCJuZXR3b3JrTWV0cmljIiwibmV0d29ya01ldHJpY3MiLCJ3YXJuIiwic3RhcnRQZXJmb3JtYW5jZU1vbml0b3JpbmciLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJtb25pdG9yIiwiZGVsdGFUaW1lIiwibGFzdEZQU0NoZWNrIiwiZnBzIiwiZnJhbWVDb3VudCIsIm1lbW9yeVVzYWdlIiwibWVtb3J5IiwidXNlZEpTSGVhcFNpemUiLCJwZXJmTWV0cmljIiwicm91bmQiLCJjYW52YXNSZW5kZXJUaW1lIiwiZXZlbnRQcm9jZXNzaW5nVGltZSIsInF1ZXVlZEV2ZW50cyIsImV2ZW50UXVldWUiLCJsZW5ndGgiLCJwZXJmb3JtYW5jZU1ldHJpY3MiLCJ0b0ZpeGVkIiwiY3VycmVudFN0cm9rZVN0YXJ0Iiwic3Ryb2tlRHVyYXRpb24iLCJlbWl0V2l0aExvZ2dpbmciLCJzb2NrZXQiLCJldmVudE5hbWUiLCJvcHRpb25zIiwiUHJvbWlzZSIsInJlc29sdmUiLCJtYXhSZXRyaWVzIiwiYXR0ZW1wdCIsImVtaXQiLCJhY2siLCJzZXRUaW1lb3V0IiwiZXJyb3IiLCJleHBvcnRBbmFseXRpY3MiLCJzZXNzaW9uIiwibmV0d29yayIsInN1bW1hcnkiLCJnZW5lcmF0ZVN1bW1hcnkiLCJ0b3RhbEV2ZW50cyIsImF2Z1JUVCIsInJlZHVjZSIsInN1bSIsIm0iLCJhY2tub3dsZWRnZWRNZXNzYWdlcyIsImZpbHRlciIsIm5hY2tNZXNzYWdlcyIsImZhaWxlZERhdGFTZW5kIiwiaSIsInN1Y2Nlc3NSYXRlIiwidG90YWxEYXRhU2VuZCIsInRvdGFsRGF0YUF0dGVtcHRlZCIsImRhdGFFZmZpY2llbmN5UmF0ZSIsImF2Z1N1Y2Nlc3NmdWxQYXlsb2FkU2l6ZSIsImF2Z0ZhaWxlZFBheWxvYWRTaXplIiwiYXZnRlBTIiwic2Vzc2lvbkR1cmF0aW9uIiwibmV0d29ya1F1YWxpdHlEaXN0cmlidXRpb24iLCJnZXROZXR3b3JrUXVhbGl0eURpc3RyaWJ1dGlvbiIsImRpc3RyaWJ1dGlvbiIsImV4Y2VsbGVudCIsImdvb2QiLCJmYWlyIiwicG9vciIsImRlY2VudCIsImZvckVhY2giLCJtZXRyaWMiLCJzdGFydFJlYWx0aW1lTW9uaXRvcmluZyIsImdldFN0b3JhZ2VJbmZvIiwiZGVzdHJveSIsImNsZWFySW50ZXJ2YWwiLCJjb25zdHJ1Y3RvciIsIndpbmRvdyIsImFkZEV2ZW50TGlzdGVuZXIiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/util/DrawingAnalytics.ts\n"));

/***/ })

});