"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/util/DrawingAnalytics.ts":
/*!**************************************!*\
  !*** ./src/util/DrawingAnalytics.ts ***!
  \**************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var object_sizeof__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! object-sizeof */ \"(app-pages-browser)/../node_modules/object-sizeof/indexv2.js\");\n/* harmony import */ var object_sizeof__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(object_sizeof__WEBPACK_IMPORTED_MODULE_0__);\n\nclass DrawingAnalytics {\n    generateId() {\n        return \"\".concat(Date.now(), \"-\").concat(Math.random().toString(36).substr(2, 9));\n    }\n    initializeUserBehavior() {\n        return {\n            sessionId: this.sessionId,\n            userId: this.userId,\n            sessionStart: Date.now(),\n            totalStrokes: 0,\n            averageStrokeLength: 0,\n            mostUsedTool: '',\n            mostUsedColor: '',\n            totalDrawingTime: 0,\n            idleTime: 0,\n            undoCount: 0,\n            redoCount: 0,\n            canvasClearCount: 0\n        };\n    }\n    startPeriodicSync(intervalMs) {\n        this.syncTimer = setInterval(async ()=>{\n            await this.syncNow();\n        }, intervalMs);\n    }\n    // Manual sync trigger\n    async syncNow() {\n        console.log('Starting analytics sync...');\n        // Queue current session data\n        this.storage.queueForSync(this.sessionId);\n        // Try to sync all queued data\n        const syncQueue = this.storage.getSyncQueue();\n        let syncedCount = 0;\n        for (const payload of syncQueue){\n            // todo send to the backend\n            if (success) {\n                this.storage.clearSyncedData(payload.timestamp);\n                syncedCount++;\n            } else {\n                break; // Stop on first failure to maintain order\n            }\n        }\n        if (syncedCount > 0) {\n            console.log(\"Synced \".concat(syncedCount, \" analytics payloads\"));\n            // Clear local data after successful sync\n            this.storage.clearLocalData();\n            return true;\n        }\n        return false;\n    }\n    // Enhanced drawing event logging with comprehensive data\n    logDrawingEvent(eventType) {\n        let data = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n        const eventId = this.generateId();\n        const timestamp = Date.now();\n        const event = {\n            eventId,\n            timestamp,\n            eventType,\n            sessionId: this.sessionId,\n            userId: this.userId,\n            ...data\n        };\n        this.events.push(event);\n        this.updateUserBehavior(event);\n        this.lastActivity = timestamp;\n        // Log to console with structured format\n        console.group(\"\\uD83C\\uDFA8 Drawing Event: \".concat(eventType));\n        console.log('Event ID:', eventId);\n        console.log('Timestamp:', new Date(timestamp).toISOString());\n        console.log('Data:', data);\n        console.groupEnd();\n        return eventId;\n    }\n    // Enhanced network logging with quality assessment\n    logNetworkEvent(eventId, startTime, acknowledged, payloadSize) {\n        let retryCount = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 0;\n        const rtt = performance.now() - startTime;\n        const connectionQuality = this.assessConnectionQuality(rtt);\n        const networkMetric = {\n            eventId,\n            timestamp: Date.now(),\n            rtt,\n            acknowledged,\n            retryCount,\n            payloadSize,\n            connectionQuality\n        };\n        this.networkMetrics.push(networkMetric);\n        console.group(\"\\uD83D\\uDCE1 Network Event\");\n        console.log('Event ID:', eventId);\n        console.log('RTT:', \"\".concat(rtt.toFixed(2), \"ms\"));\n        console.log('Quality:', connectionQuality);\n        console.log('Payload Size:', \"\".concat(payloadSize, \" bytes\"));\n        console.log('Acknowledged:', acknowledged);\n        if (retryCount > 0) console.warn('Retry Count:', retryCount);\n        console.groupEnd();\n    }\n    assessConnectionQuality(rtt) {\n        if (rtt < 50) return 'excellent';\n        if (rtt < 100) return 'good';\n        if (rtt < 200) return 'fair';\n        if (rtt < 500) return 'decent';\n        return 'poor';\n    }\n    // Performance monitoring\n    startPerformanceMonitoring() {\n        if ( false || typeof requestAnimationFrame === 'undefined') {\n            console.warn('Performance monitoring not available in this environment');\n            return;\n        }\n        const monitor = ()=>{\n            const now = performance.now();\n            const deltaTime = now - this.lastFPSCheck;\n            if (deltaTime >= 1000) {\n                var _performance_memory;\n                // if its been a second\n                const fps = this.frameCount * 1000 / deltaTime;\n                const memoryUsage = ((_performance_memory = performance.memory) === null || _performance_memory === void 0 ? void 0 : _performance_memory.usedJSHeapSize) || 0;\n                const perfMetric = {\n                    timestamp: Date.now(),\n                    fps: Math.round(fps),\n                    memoryUsage,\n                    canvasRenderTime: 0,\n                    eventProcessingTime: 0,\n                    queuedEvents: this.eventQueue.length\n                };\n                this.performanceMetrics.push(perfMetric);\n                this.frameCount = 0;\n                this.lastFPSCheck = now;\n                // Log performance warnings\n                if (fps < 30) {\n                    console.warn(\"⚠️ Low FPS detected: \".concat(fps.toFixed(1)));\n                }\n                if (this.eventQueue.length > 10) {\n                    console.warn(\"⚠️ Event queue backlog: \".concat(this.eventQueue.length, \" events\"));\n                }\n            }\n            this.frameCount++;\n            requestAnimationFrame(monitor);\n        };\n        requestAnimationFrame(monitor);\n    }\n    // Update user behavior metrics\n    updateUserBehavior(event) {\n        switch(event.eventType){\n            case 'stroke_start':\n                this.userBehavior.totalStrokes++;\n                this.currentStrokeStart = event.timestamp;\n                break;\n            case 'stroke_end':\n                if (this.currentStrokeStart) {\n                    const strokeDuration = event.timestamp - this.currentStrokeStart;\n                    this.userBehavior.totalDrawingTime += strokeDuration;\n                }\n                break;\n            case 'undo':\n                this.userBehavior.undoCount++;\n                break;\n            case 'redo':\n                this.userBehavior.redoCount++;\n                break;\n            case 'canvas_clear':\n                this.userBehavior.canvasClearCount++;\n                break;\n        }\n    }\n    // Enhanced socket emission with comprehensive logging\n    emitWithLogging(socket, eventName, data) {\n        let options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};\n        return new Promise((resolve)=>{\n            const startTime = performance.now();\n            const eventId = this.logDrawingEvent('stroke_continue', data);\n            const payloadSize = object_sizeof__WEBPACK_IMPORTED_MODULE_0___default()(data);\n            let retryCount = 0;\n            const maxRetries = options.retryCount || 3;\n            const attempt = ()=>{\n                socket.emit(eventName, data, (ack)=>{\n                    this.logNetworkEvent(eventId, startTime, ack, payloadSize, retryCount);\n                    if (ack) {\n                        resolve(true);\n                    } else if (retryCount < maxRetries) {\n                        retryCount++;\n                        console.warn(\"\\uD83D\\uDD04 Retrying event \".concat(eventId, \" (attempt \").concat(retryCount, \"/\").concat(maxRetries, \")\"));\n                        setTimeout(attempt, 100 * retryCount); // Exponential backoff\n                    } else {\n                        console.error(\"❌ Event \".concat(eventId, \" failed after \").concat(maxRetries, \" retries\"));\n                        resolve(false);\n                    }\n                });\n            };\n            attempt();\n        });\n    }\n    // Data export and analysis methods\n    exportAnalytics() {\n        return {\n            session: this.userBehavior,\n            events: this.events,\n            network: this.networkMetrics,\n            performance: this.performanceMetrics,\n            summary: this.generateSummary()\n        };\n    }\n    generateSummary() {\n        const totalEvents = this.events.length;\n        const avgRTT = this.networkMetrics.reduce((sum, m)=>sum + m.rtt, 0) / this.networkMetrics.length || 0;\n        const acknowledgedMessages = this.networkMetrics.filter((m)=>m.acknowledged);\n        const nackMessages = this.networkMetrics.filter((m)=>!m.acknowledged);\n        const failedDataSend = nackMessages.reduce((sum, i)=>sum + i.payloadSize, 0);\n        const successRate = acknowledgedMessages.length / this.networkMetrics.length * 100 || 0;\n        const totalDataSend = acknowledgedMessages.reduce((sum, i)=>sum + i.payloadSize, 0);\n        console.log('failedDataSend,', failedDataSend);\n        const totalDataAttempted = totalDataSend + failedDataSend;\n        const dataEfficiencyRate = totalDataSend / totalDataAttempted * 100;\n        const avgSuccessfulPayloadSize = totalDataSend / acknowledgedMessages.length;\n        const avgFailedPayloadSize = failedDataSend / nackMessages.length;\n        const avgFPS = this.performanceMetrics.reduce((sum, m)=>sum + m.fps, 0) / this.performanceMetrics.length || 0;\n        return {\n            totalEvents,\n            avgRTT: Math.round(avgRTT * 100) / 100,\n            successRate: Math.round(successRate * 100) / 100,\n            avgFPS: Math.round(avgFPS),\n            totalDataSend: Math.round(totalDataSend),\n            dataEfficiencyRate: Math.round(dataEfficiencyRate),\n            avgSuccessfulPayloadSize: Math.round(avgSuccessfulPayloadSize),\n            avgFailedPayloadSize: Math.round(avgFailedPayloadSize),\n            sessionDuration: Date.now() - this.userBehavior.sessionStart,\n            networkQualityDistribution: this.getNetworkQualityDistribution()\n        };\n    }\n    getNetworkQualityDistribution() {\n        const distribution = {\n            excellent: 0,\n            good: 0,\n            fair: 0,\n            poor: 0,\n            decent: 0\n        };\n        this.networkMetrics.forEach((metric)=>{\n            distribution[metric.connectionQuality]++;\n        });\n        return distribution;\n    }\n    // Real-time monitoring dashboard (console-based)\n    startRealtimeMonitoring() {\n        let intervalMs = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 5000;\n        setInterval(()=>{\n            const summary = this.generateSummary();\n            console.log('Session Duration:', \"\".concat(Math.round(summary.sessionDuration / 1000), \"s\"));\n            console.log('Total Events:', summary.totalEvents);\n            console.log('Average RTT:', \"\".concat(summary.avgRTT, \"ms\"));\n            console.log('Success Rate:', \"\".concat(summary.successRate, \"%\"));\n            console.log('Average FPS:', summary.avgFPS);\n            console.log('Network Quality:', summary.networkQualityDistribution);\n            console.groupEnd();\n        }, intervalMs);\n    }\n    constructor(userId){\n        this.events = [];\n        this.networkMetrics = [];\n        this.performanceMetrics = [];\n        this.lastActivity = Date.now();\n        this.frameCount = 0;\n        this.lastFPSCheck = performance.now();\n        this.eventQueue = [];\n        this.sessionId = this.generateId();\n        this.userId = userId;\n        this.userBehavior = this.initializeUserBehavior();\n        this.startPerformanceMonitoring();\n    }\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (DrawingAnalytics);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy91dGlsL0RyYXdpbmdBbmFseXRpY3MudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQW1DO0FBd0RuQyxNQUFNQztJQXFCR0MsYUFBcUI7UUFDNUIsT0FBTyxHQUFpQkMsT0FBZEMsS0FBS0MsR0FBRyxJQUFHLEtBQTJDLE9BQXhDRixLQUFLRyxNQUFNLEdBQUdDLFFBQVEsQ0FBQyxJQUFJQyxNQUFNLENBQUMsR0FBRztJQUM5RDtJQUVRQyx5QkFBOEM7UUFDckQsT0FBTztZQUNOQyxXQUFXLElBQUksQ0FBQ0EsU0FBUztZQUN6QkMsUUFBUSxJQUFJLENBQUNBLE1BQU07WUFDbkJDLGNBQWNSLEtBQUtDLEdBQUc7WUFDdEJRLGNBQWM7WUFDZEMscUJBQXFCO1lBQ3JCQyxjQUFjO1lBQ2RDLGVBQWU7WUFDZkMsa0JBQWtCO1lBQ2xCQyxVQUFVO1lBQ1ZDLFdBQVc7WUFDWEMsV0FBVztZQUNYQyxrQkFBa0I7UUFDbkI7SUFDRDtJQUVRQyxrQkFBa0JDLFVBQWtCLEVBQVE7UUFDbkQsSUFBSSxDQUFDQyxTQUFTLEdBQUdDLFlBQVk7WUFDNUIsTUFBTSxJQUFJLENBQUNDLE9BQU87UUFDbkIsR0FBR0g7SUFDSjtJQUVBLHNCQUFzQjtJQUN0QixNQUFNRyxVQUE0QjtRQUNqQ0MsUUFBUUMsR0FBRyxDQUFDO1FBRVosNkJBQTZCO1FBQzdCLElBQUksQ0FBQ0MsT0FBTyxDQUFDQyxZQUFZLENBQUMsSUFBSSxDQUFDcEIsU0FBUztRQUV4Qyw4QkFBOEI7UUFDOUIsTUFBTXFCLFlBQVksSUFBSSxDQUFDRixPQUFPLENBQUNHLFlBQVk7UUFDM0MsSUFBSUMsY0FBYztRQUVsQixLQUFLLE1BQU1DLFdBQVdILFVBQVc7WUFDaEMsMkJBQTJCO1lBQzNCLElBQUlJLFNBQVM7Z0JBQ1osSUFBSSxDQUFDTixPQUFPLENBQUNPLGVBQWUsQ0FBQ0YsUUFBUUcsU0FBUztnQkFDOUNKO1lBQ0QsT0FBTztnQkFDTixPQUFPLDBDQUEwQztZQUNsRDtR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VztZQUNoRDNFLFFBQVFDLEdBQUcsQ0FBQyxnQkFBZ0IsR0FBa0IsT0FBZndFLFFBQVFHLE1BQU0sRUFBQztZQUM5QzVFLFFBQVFDLEdBQUcsQ0FBQyxpQkFBaUIsR0FBdUIsT0FBcEJ3RSxRQUFRWSxXQUFXLEVBQUM7WUFDcERyRixRQUFRQyxHQUFHLENBQUMsZ0JBQWdCd0UsUUFBUWtCLE1BQU07WUFDMUMzRixRQUFRQyxHQUFHLENBQUMsb0JBQW9Cd0UsUUFBUW9CLDBCQUEwQjtZQUVsRTdGLFFBQVF1QixRQUFRO1FBQ2pCLEdBQUczQjtJQUNKO0lBbldBNEcsWUFBWXhILE1BQWUsQ0FBRTthQVZyQmlDLFNBQXlCLEVBQUU7YUFDM0JpQixpQkFBbUMsRUFBRTthQUNyQ29CLHFCQUEyQyxFQUFFO2FBRTdDbEMsZUFBdUIzQyxLQUFLQyxHQUFHO2FBRS9CaUUsYUFBYTthQUNiRixlQUFlWCxZQUFZcEQsR0FBRzthQUM5QjBFLGFBQW9CLEVBQUU7UUFHN0IsSUFBSSxDQUFDckUsU0FBUyxHQUFHLElBQUksQ0FBQ1IsVUFBVTtRQUNoQyxJQUFJLENBQUNTLE1BQU0sR0FBR0E7UUFDZCxJQUFJLENBQUN1RSxZQUFZLEdBQUcsSUFBSSxDQUFDekUsc0JBQXNCO1FBQy9DLElBQUksQ0FBQ3VELDBCQUEwQjtJQUNoQztBQStWRDtBQUVBLGlFQUFlL0QsZ0JBQWdCQSxFQUFDIiwic291cmNlcyI6WyIvVXNlcnMvZW1yZXlpbGRpcmltL0Rlc2t0b3AvZmluYWxQcm9qZWN0L2NsaWVudC9zcmMvdXRpbC9EcmF3aW5nQW5hbHl0aWNzLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBzaXplb2YgZnJvbSAnb2JqZWN0LXNpemVvZic7XG5pbXBvcnQgQW5hbHl0aWNzTG9jYWxTdG9yYWdlTWFuYWdlciBmcm9tICcuL0FuYWx5dGljc0xvY2FsU3RvcmFnZU1hbmFnZXInO1xuaW50ZXJmYWNlIERyYXdpbmdFdmVudCB7XG5cdGV2ZW50SWQ6IHN0cmluZztcblx0dGltZXN0YW1wOiBudW1iZXI7XG5cdGV2ZW50VHlwZTpcblx0XHR8ICdzdHJva2Vfc3RhcnQnXG5cdFx0fCAnc3Ryb2tlX2NvbnRpbnVlJ1xuXHRcdHwgJ3N0cm9rZV9lbmQnXG5cdFx0fCAnY2FudmFzX2NsZWFyJ1xuXHRcdHwgJ3VuZG8nXG5cdFx0fCAncmVkbyc7XG5cdHN0cm9rZUlkPzogc3RyaW5nO1xuXHRjb29yZGluYXRlcz86IHsgeDogbnVtYmVyOyB5OiBudW1iZXIgfTtcblx0cHJlc3N1cmU/OiBudW1iZXI7XG5cdHRvb2w/OiBzdHJpbmc7XG5cdGNvbG9yPzogc3RyaW5nO1xuXHRicnVzaFNpemU/OiBudW1iZXI7XG5cdHVzZXJJZD86IHN0cmluZztcblx0c2Vzc2lvbklkOiBzdHJpbmc7XG59XG5cbmludGVyZmFjZSBOZXR3b3JrTWV0cmljcyB7XG5cdGV2ZW50SWQ6IHN0cmluZztcblx0dGltZXN0YW1wOiBudW1iZXI7XG5cdHJ0dDogbnVtYmVyO1xuXHRhY2tub3dsZWRnZWQ6IGJvb2xlYW47XG5cdHJldHJ5Q291bnQ6IG51bWJlcjtcblx0cGF5bG9hZFNpemU6IG51bWJlcjtcblx0Y29ubmVjdGlvblF1YWxpdHk6ICdleGNlbGxlbnQnIHwgJ2dvb2QnIHwgJ2ZhaXInIHwgJ2RlY2VudCcgfCAncG9vcic7XG59XG5cbmludGVyZmFjZSBQZXJmb3JtYW5jZU1ldHJpY3Mge1xuXHR0aW1lc3RhbXA6IG51bWJlcjtcblx0ZnBzOiBudW1iZXI7XG5cdG1lbW9yeVVzYWdlOiBudW1iZXI7XG5cdGNhbnZhc1JlbmRlclRpbWU6IG51bWJlcjtcblx0ZXZlbnRQcm9jZXNzaW5nVGltZTogbnVtYmVyO1xuXHRxdWV1ZWRFdmVudHM6IG51bWJlcjtcbn1cblxuaW50ZXJmYWNlIFVzZXJCZWhhdmlvck1ldHJpY3Mge1xuXHRzZXNzaW9uSWQ6IHN0cmluZztcblx0dXNlcklkPzogc3RyaW5nO1xuXHRzZXNzaW9uU3RhcnQ6IG51bWJlcjtcblx0dG90YWxTdHJva2VzOiBudW1iZXI7XG5cdGF2ZXJhZ2VTdHJva2VMZW5ndGg6IG51bWJlcjtcblx0bW9zdFVzZWRUb29sOiBzdHJpbmc7XG5cdG1vc3RVc2VkQ29sb3I6IHN0cmluZztcblx0dG90YWxEcmF3aW5nVGltZTogbnVtYmVyO1xuXHRpZGxlVGltZTogbnVtYmVyO1xuXHR1bmRvQ291bnQ6IG51bWJlcjtcblx0cmVkb0NvdW50OiBudW1iZXI7XG5cdGNhbnZhc0NsZWFyQ291bnQ6IG51bWJlcjtcbn1cblxuY2xhc3MgRHJhd2luZ0FuYWx5dGljcyB7XG5cdHByaXZhdGUgc2Vzc2lvbklkOiBzdHJpbmc7XG5cdHByaXZhdGUgc3RvcmFnZTogQW5hbHl0aWNzTG9jYWxTdG9yYWdlTWFuYWdlcjtcblx0cHJpdmF0ZSB1c2VySWQ/OiBzdHJpbmc7XG5cdHByaXZhdGUgZXZlbnRzOiBEcmF3aW5nRXZlbnRbXSA9IFtdO1xuXHRwcml2YXRlIG5ldHdvcmtNZXRyaWNzOiBOZXR3b3JrTWV0cmljc1tdID0gW107XG5cdHByaXZhdGUgcGVyZm9ybWFuY2VNZXRyaWNzOiBQZXJmb3JtYW5jZU1ldHJpY3NbXSA9IFtdO1xuXHRwcml2YXRlIHVzZXJCZWhhdmlvcjogVXNlckJlaGF2aW9yTWV0cmljcztcblx0cHJpdmF0ZSBsYXN0QWN0aXZpdHk6IG51bWJlciA9IERhdGUubm93KCk7XG5cdHByaXZhdGUgY3VycmVudFN0cm9rZVN0YXJ0PzogbnVtYmVyO1xuXHRwcml2YXRlIGZyYW1lQ291bnQgPSAwO1xuXHRwcml2YXRlIGxhc3RGUFNDaGVjayA9IHBlcmZvcm1hbmNlLm5vdygpO1xuXHRwcml2YXRlIGV2ZW50UXVldWU6IGFueVtdID0gW107XG5cblx0Y29uc3RydWN0b3IodXNlcklkPzogc3RyaW5nKSB7XG5cdFx0dGhpcy5zZXNzaW9uSWQgPSB0aGlzLmdlbmVyYXRlSWQoKTtcblx0XHR0aGlzLnVzZXJJZCA9IHVzZXJJZDtcblx0XHR0aGlzLnVzZXJCZWhhdmlvciA9IHRoaXMuaW5pdGlhbGl6ZVVzZXJCZWhhdmlvcigpO1xuXHRcdHRoaXMuc3RhcnRQZXJmb3JtYW5jZU1vbml0b3JpbmcoKTtcblx0fVxuXG5cdHByaXZhdGUgZ2VuZXJhdGVJZCgpOiBzdHJpbmcge1xuXHRcdHJldHVybiBgJHtEYXRlLm5vdygpfS0ke01hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cigyLCA5KX1gO1xuXHR9XG5cblx0cHJpdmF0ZSBpbml0aWFsaXplVXNlckJlaGF2aW9yKCk6IFVzZXJCZWhhdmlvck1ldHJpY3Mge1xuXHRcdHJldHVybiB7XG5cdFx0XHRzZXNzaW9uSWQ6IHRoaXMuc2Vzc2lvbklkLFxuXHRcdFx0dXNlcklkOiB0aGlzLnVzZXJJZCxcblx0XHRcdHNlc3Npb25TdGFydDogRGF0ZS5ub3coKSxcblx0XHRcdHRvdGFsU3Ryb2tlczogMCxcblx0XHRcdGF2ZXJhZ2VTdHJva2VMZW5ndGg6IDAsXG5cdFx0XHRtb3N0VXNlZFRvb2w6ICcnLFxuXHRcdFx0bW9zdFVzZWRDb2xvcjogJycsXG5cdFx0XHR0b3RhbERyYXdpbmdUaW1lOiAwLFxuXHRcdFx0aWRsZVRpbWU6IDAsXG5cdFx0XHR1bmRvQ291bnQ6IDAsXG5cdFx0XHRyZWRvQ291bnQ6IDAsXG5cdFx0XHRjYW52YXNDbGVhckNvdW50OiAwLFxuXHRcdH07XG5cdH1cblxuXHRwcml2YXRlIHN0YXJ0UGVyaW9kaWNTeW5jKGludGVydmFsTXM6IG51bWJlcik6IHZvaWQge1xuXHRcdHRoaXMuc3luY1RpbWVyID0gc2V0SW50ZXJ2YWwoYXN5bmMgKCkgPT4ge1xuXHRcdFx0YXdhaXQgdGhpcy5zeW5jTm93KCk7XG5cdFx0fSwgaW50ZXJ2YWxNcyk7XG5cdH1cblxuXHQvLyBNYW51YWwgc3luYyB0cmlnZ2VyXG5cdGFzeW5jIHN5bmNOb3coKTogUHJvbWlzZTxib29sZWFuPiB7XG5cdFx0Y29uc29sZS5sb2coJ1N0YXJ0aW5nIGFuYWx5dGljcyBzeW5jLi4uJyk7XG5cblx0XHQvLyBRdWV1ZSBjdXJyZW50IHNlc3Npb24gZGF0YVxuXHRcdHRoaXMuc3RvcmFnZS5xdWV1ZUZvclN5bmModGhpcy5zZXNzaW9uSWQpO1xuXG5cdFx0Ly8gVHJ5IHRvIHN5bmMgYWxsIHF1ZXVlZCBkYXRhXG5cdFx0Y29uc3Qgc3luY1F1ZXVlID0gdGhpcy5zdG9yYWdlLmdldFN5bmNRdWV1ZSgpO1xuXHRcdGxldCBzeW5jZWRDb3VudCA9IDA7XG5cblx0XHRmb3IgKGNvbnN0IHBheWxvYWQgb2Ygc3luY1F1ZXVlKSB7XG5cdFx0XHQvLyB0b2RvIHNlbmQgdG8gdGhlIGJhY2tlbmRcblx0XHRcdGlmIChzdWNjZXNzKSB7XG5cdFx0XHRcdHRoaXMuc3RvcmFnZS5jbGVhclN5bmNlZERhdGEocGF5bG9hZC50aW1lc3RhbXApO1xuXHRcdFx0XHRzeW5jZWRDb3VudCsrO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0YnJlYWs7IC8vIFN0b3Agb24gZmlyc3QgZmFpbHVyZSB0byBtYWludGFpbiBvcmRlclxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChzeW5jZWRDb3VudCA+IDApIHtcblx0XHRcdGNvbnNvbGUubG9nKGBTeW5jZWQgJHtzeW5jZWRDb3VudH0gYW5hbHl0aWNzIHBheWxvYWRzYCk7XG5cdFx0XHQvLyBDbGVhciBsb2NhbCBkYXRhIGFmdGVyIHN1Y2Nlc3NmdWwgc3luY1xuXHRcdFx0dGhpcy5zdG9yYWdlLmNsZWFyTG9jYWxEYXRhKCk7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHQvLyBFbmhhbmNlZCBkcmF3aW5nIGV2ZW50IGxvZ2dpbmcgd2l0aCBjb21wcmVoZW5zaXZlIGRhdGFcblx0bG9nRHJhd2luZ0V2ZW50KFxuXHRcdGV2ZW50VHlwZTogRHJhd2luZ0V2ZW50WydldmVudFR5cGUnXSxcblx0XHRkYXRhOiB7XG5cdFx0XHRjb29yZGluYXRlcz86IHsgeDogbnVtYmVyOyB5OiBudW1iZXIgfTtcblx0XHRcdHByZXNzdXJlPzogbnVtYmVyO1xuXHRcdFx0dG9vbD86IHN0cmluZztcblx0XHRcdGNvbG9yPzogc3RyaW5nO1xuXHRcdFx0YnJ1c2hTaXplPzogbnVtYmVyO1xuXHRcdFx0c3Ryb2tlSWQ/OiBzdHJpbmc7XG5cdFx0fSA9IHt9XG5cdCk6IHN0cmluZyB7XG5cdFx0Y29uc3QgZXZlbnRJZCA9IHRoaXMuZ2VuZXJhdGVJZCgpO1xuXHRcdGNvbnN0IHRpbWVzdGFtcCA9IERhdGUubm93KCk7XG5cblx0XHRjb25zdCBldmVudDogRHJhd2luZ0V2ZW50ID0ge1xuXHRcdFx0ZXZlbnRJZCxcblx0XHRcdHRpbWVzdGFtcCxcblx0XHRcdGV2ZW50VHlwZSxcblx0XHRcdHNlc3Npb25JZDogdGhpcy5zZXNzaW9uSWQsXG5cdFx0XHR1c2VySWQ6IHRoaXMudXNlcklkLFxuXHRcdFx0Li4uZGF0YSxcblx0XHR9O1xuXG5cdFx0dGhpcy5ldmVudHMucHVzaChldmVudCk7XG5cdFx0dGhpcy51cGRhdGVVc2VyQmVoYXZpb3IoZXZlbnQpO1xuXHRcdHRoaXMubGFzdEFjdGl2aXR5ID0gdGltZXN0YW1wO1xuXG5cdFx0Ly8gTG9nIHRvIGNvbnNvbGUgd2l0aCBzdHJ1Y3R1cmVkIGZvcm1hdFxuXHRcdGNvbnNvbGUuZ3JvdXAoYPCfjqggRHJhd2luZyBFdmVudDogJHtldmVudFR5cGV9YCk7XG5cdFx0Y29uc29sZS5sb2coJ0V2ZW50IElEOicsIGV2ZW50SWQpO1xuXHRcdGNvbnNvbGUubG9nKCdUaW1lc3RhbXA6JywgbmV3IERhdGUodGltZXN0YW1wKS50b0lTT1N0cmluZygpKTtcblx0XHRjb25zb2xlLmxvZygnRGF0YTonLCBkYXRhKTtcblx0XHRjb25zb2xlLmdyb3VwRW5kKCk7XG5cblx0XHRyZXR1cm4gZXZlbnRJZDtcblx0fVxuXG5cdC8vIEVuaGFuY2VkIG5ldHdvcmsgbG9nZ2luZyB3aXRoIHF1YWxpdHkgYXNzZXNzbWVudFxuXHRsb2dOZXR3b3JrRXZlbnQoXG5cdFx0ZXZlbnRJZDogc3RyaW5nLFxuXHRcdHN0YXJ0VGltZTogbnVtYmVyLFxuXHRcdGFja25vd2xlZGdlZDogYm9vbGVhbixcblx0XHRwYXlsb2FkU2l6ZTogbnVtYmVyLFxuXHRcdHJldHJ5Q291bnQ6IG51bWJlciA9IDBcblx0KTogdm9pZCB7XG5cdFx0Y29uc3QgcnR0ID0gcGVyZm9ybWFuY2Uubm93KCkgLSBzdGFydFRpbWU7XG5cdFx0Y29uc3QgY29ubmVjdGlvblF1YWxpdHkgPSB0aGlzLmFzc2Vzc0Nvbm5lY3Rpb25RdWFsaXR5KHJ0dCk7XG5cblx0XHRjb25zdCBuZXR3b3JrTWV0cmljOiBOZXR3b3JrTWV0cmljcyA9IHtcblx0XHRcdGV2ZW50SWQsXG5cdFx0XHR0aW1lc3RhbXA6IERhdGUubm93KCksXG5cdFx0XHRydHQsXG5cdFx0XHRhY2tub3dsZWRnZWQsXG5cdFx0XHRyZXRyeUNvdW50LFxuXHRcdFx0cGF5bG9hZFNpemUsXG5cdFx0XHRjb25uZWN0aW9uUXVhbGl0eSxcblx0XHR9O1xuXG5cdFx0dGhpcy5uZXR3b3JrTWV0cmljcy5wdXNoKG5ldHdvcmtNZXRyaWMpO1xuXG5cdFx0Y29uc29sZS5ncm91cChg8J+ToSBOZXR3b3JrIEV2ZW50YCk7XG5cdFx0Y29uc29sZS5sb2coJ0V2ZW50IElEOicsIGV2ZW50SWQpO1xuXHRcdGNvbnNvbGUubG9nKCdSVFQ6JywgYCR7cnR0LnRvRml4ZWQoMil9bXNgKTtcblx0XHRjb25zb2xlLmxvZygnUXVhbGl0eTonLCBjb25uZWN0aW9uUXVhbGl0eSk7XG5cdFx0Y29uc29sZS5sb2coJ1BheWxvYWQgU2l6ZTonLCBgJHtwYXlsb2FkU2l6ZX0gYnl0ZXNgKTtcblx0XHRjb25zb2xlLmxvZygnQWNrbm93bGVkZ2VkOicsIGFja25vd2xlZGdlZCk7XG5cdFx0aWYgKHJldHJ5Q291bnQgPiAwKSBjb25zb2xlLndhcm4oJ1JldHJ5IENvdW50OicsIHJldHJ5Q291bnQpO1xuXHRcdGNvbnNvbGUuZ3JvdXBFbmQoKTtcblx0fVxuXG5cdHByaXZhdGUgYXNzZXNzQ29ubmVjdGlvblF1YWxpdHkoXG5cdFx0cnR0OiBudW1iZXJcblx0KTogTmV0d29ya01ldHJpY3NbJ2Nvbm5lY3Rpb25RdWFsaXR5J10ge1xuXHRcdGlmIChydHQgPCA1MCkgcmV0dXJuICdleGNlbGxlbnQnO1xuXHRcdGlmIChydHQgPCAxMDApIHJldHVybiAnZ29vZCc7XG5cdFx0aWYgKHJ0dCA8IDIwMCkgcmV0dXJuICdmYWlyJztcblx0XHRpZiAocnR0IDwgNTAwKSByZXR1cm4gJ2RlY2VudCc7XG5cdFx0cmV0dXJuICdwb29yJztcblx0fVxuXG5cdC8vIFBlcmZvcm1hbmNlIG1vbml0b3Jpbmdcblx0cHJpdmF0ZSBzdGFydFBlcmZvcm1hbmNlTW9uaXRvcmluZygpOiB2b2lkIHtcblx0XHRpZiAoXG5cdFx0XHR0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyB8fFxuXHRcdFx0dHlwZW9mIHJlcXVlc3RBbmltYXRpb25GcmFtZSA9PT0gJ3VuZGVmaW5lZCdcblx0XHQpIHtcblx0XHRcdGNvbnNvbGUud2FybignUGVyZm9ybWFuY2UgbW9uaXRvcmluZyBub3QgYXZhaWxhYmxlIGluIHRoaXMgZW52aXJvbm1lbnQnKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0Y29uc3QgbW9uaXRvciA9ICgpID0+IHtcblx0XHRcdGNvbnN0IG5vdyA9IHBlcmZvcm1hbmNlLm5vdygpO1xuXHRcdFx0Y29uc3QgZGVsdGFUaW1lID0gbm93IC0gdGhpcy5sYXN0RlBTQ2hlY2s7XG5cblx0XHRcdGlmIChkZWx0YVRpbWUgPj0gMTAwMCkge1xuXHRcdFx0XHQvLyBpZiBpdHMgYmVlbiBhIHNlY29uZFxuXHRcdFx0XHRjb25zdCBmcHMgPSAodGhpcy5mcmFtZUNvdW50ICogMTAwMCkgLyBkZWx0YVRpbWU7XG5cdFx0XHRcdGNvbnN0IG1lbW9yeVVzYWdlID0gKHBlcmZvcm1hbmNlIGFzIGFueSkubWVtb3J5Py51c2VkSlNIZWFwU2l6ZSB8fCAwO1xuXG5cdFx0XHRcdGNvbnN0IHBlcmZNZXRyaWM6IFBlcmZvcm1hbmNlTWV0cmljcyA9IHtcblx0XHRcdFx0XHR0aW1lc3RhbXA6IERhdGUubm93KCksXG5cdFx0XHRcdFx0ZnBzOiBNYXRoLnJvdW5kKGZwcyksXG5cdFx0XHRcdFx0bWVtb3J5VXNhZ2UsXG5cdFx0XHRcdFx0Y2FudmFzUmVuZGVyVGltZTogMCwgLy8gWW91J2xsIG5lZWQgdG8gbWVhc3VyZSB0aGlzIGluIHlvdXIgcmVuZGVyIGxvb3Bcblx0XHRcdFx0XHRldmVudFByb2Nlc3NpbmdUaW1lOiAwLCAvLyBNZWFzdXJlIGluIHlvdXIgZXZlbnQgaGFuZGxlcnNcblx0XHRcdFx0XHRxdWV1ZWRFdmVudHM6IHRoaXMuZXZlbnRRdWV1ZS5sZW5ndGgsXG5cdFx0XHRcdH07XG5cblx0XHRcdFx0dGhpcy5wZXJmb3JtYW5jZU1ldHJpY3MucHVzaChwZXJmTWV0cmljKTtcblx0XHRcdFx0dGhpcy5mcmFtZUNvdW50ID0gMDtcblx0XHRcdFx0dGhpcy5sYXN0RlBTQ2hlY2sgPSBub3c7XG5cblx0XHRcdFx0Ly8gTG9nIHBlcmZvcm1hbmNlIHdhcm5pbmdzXG5cdFx0XHRcdGlmIChmcHMgPCAzMCkge1xuXHRcdFx0XHRcdGNvbnNvbGUud2Fybihg4pqg77iPIExvdyBGUFMgZGV0ZWN0ZWQ6ICR7ZnBzLnRvRml4ZWQoMSl9YCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHRoaXMuZXZlbnRRdWV1ZS5sZW5ndGggPiAxMCkge1xuXHRcdFx0XHRcdGNvbnNvbGUud2Fybihcblx0XHRcdFx0XHRcdGDimqDvuI8gRXZlbnQgcXVldWUgYmFja2xvZzogJHt0aGlzLmV2ZW50UXVldWUubGVuZ3RofSBldmVudHNgXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLmZyYW1lQ291bnQrKztcblx0XHRcdHJlcXVlc3RBbmltYXRpb25GcmFtZShtb25pdG9yKTtcblx0XHR9O1xuXG5cdFx0cmVxdWVzdEFuaW1hdGlvbkZyYW1lKG1vbml0b3IpO1xuXHR9XG5cblx0Ly8gVXBkYXRlIHVzZXIgYmVoYXZpb3IgbWV0cmljc1xuXHRwcml2YXRlIHVwZGF0ZVVzZXJCZWhhdmlvcihldmVudDogRHJhd2luZ0V2ZW50KTogdm9pZCB7XG5cdFx0c3dpdGNoIChldmVudC5ldmVudFR5cGUpIHtcblx0XHRcdGNhc2UgJ3N0cm9rZV9zdGFydCc6XG5cdFx0XHRcdHRoaXMudXNlckJlaGF2aW9yLnRvdGFsU3Ryb2tlcysrO1xuXHRcdFx0XHR0aGlzLmN1cnJlbnRTdHJva2VTdGFydCA9IGV2ZW50LnRpbWVzdGFtcDtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICdzdHJva2VfZW5kJzpcblx0XHRcdFx0aWYgKHRoaXMuY3VycmVudFN0cm9rZVN0YXJ0KSB7XG5cdFx0XHRcdFx0Y29uc3Qgc3Ryb2tlRHVyYXRpb24gPSBldmVudC50aW1lc3RhbXAgLSB0aGlzLmN1cnJlbnRTdHJva2VTdGFydDtcblx0XHRcdFx0XHR0aGlzLnVzZXJCZWhhdmlvci50b3RhbERyYXdpbmdUaW1lICs9IHN0cm9rZUR1cmF0aW9uO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAndW5kbyc6XG5cdFx0XHRcdHRoaXMudXNlckJlaGF2aW9yLnVuZG9Db3VudCsrO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgJ3JlZG8nOlxuXHRcdFx0XHR0aGlzLnVzZXJCZWhhdmlvci5yZWRvQ291bnQrKztcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICdjYW52YXNfY2xlYXInOlxuXHRcdFx0XHR0aGlzLnVzZXJCZWhhdmlvci5jYW52YXNDbGVhckNvdW50Kys7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdH1cblx0fVxuXG5cdC8vIEVuaGFuY2VkIHNvY2tldCBlbWlzc2lvbiB3aXRoIGNvbXByZWhlbnNpdmUgbG9nZ2luZ1xuXHRlbWl0V2l0aExvZ2dpbmcoXG5cdFx0c29ja2V0OiBhbnksXG5cdFx0ZXZlbnROYW1lOiBzdHJpbmcsXG5cdFx0ZGF0YTogYW55LFxuXHRcdG9wdGlvbnM6IHtcblx0XHRcdHRpbWVvdXQ/OiBudW1iZXI7XG5cdFx0XHRyZXRyeUNvdW50PzogbnVtYmVyO1xuXHRcdFx0cHJpb3JpdHk/OiAnaGlnaCcgfCAnbm9ybWFsJyB8ICdsb3cnO1xuXHRcdH0gPSB7fVxuXHQpOiBQcm9taXNlPGJvb2xlYW4+IHtcblx0XHRyZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcblx0XHRcdGNvbnN0IHN0YXJ0VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuXHRcdFx0Y29uc3QgZXZlbnRJZCA9IHRoaXMubG9nRHJhd2luZ0V2ZW50KCdzdHJva2VfY29udGludWUnLCBkYXRhKTtcblx0XHRcdGNvbnN0IHBheWxvYWRTaXplID0gc2l6ZW9mKGRhdGEpO1xuXHRcdFx0bGV0IHJldHJ5Q291bnQgPSAwO1xuXHRcdFx0Y29uc3QgbWF4UmV0cmllcyA9IG9wdGlvbnMucmV0cnlDb3VudCB8fCAzO1xuXG5cdFx0XHRjb25zdCBhdHRlbXB0ID0gKCkgPT4ge1xuXHRcdFx0XHRzb2NrZXQuZW1pdChldmVudE5hbWUsIGRhdGEsIChhY2s6IGJvb2xlYW4pID0+IHtcblx0XHRcdFx0XHR0aGlzLmxvZ05ldHdvcmtFdmVudChcblx0XHRcdFx0XHRcdGV2ZW50SWQsXG5cdFx0XHRcdFx0XHRzdGFydFRpbWUsXG5cdFx0XHRcdFx0XHRhY2ssXG5cdFx0XHRcdFx0XHRwYXlsb2FkU2l6ZSxcblx0XHRcdFx0XHRcdHJldHJ5Q291bnRcblx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdFx0aWYgKGFjaykge1xuXHRcdFx0XHRcdFx0cmVzb2x2ZSh0cnVlKTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKHJldHJ5Q291bnQgPCBtYXhSZXRyaWVzKSB7XG5cdFx0XHRcdFx0XHRyZXRyeUNvdW50Kys7XG5cdFx0XHRcdFx0XHRjb25zb2xlLndhcm4oXG5cdFx0XHRcdFx0XHRcdGDwn5SEIFJldHJ5aW5nIGV2ZW50ICR7ZXZlbnRJZH0gKGF0dGVtcHQgJHtyZXRyeUNvdW50fS8ke21heFJldHJpZXN9KWBcblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRzZXRUaW1lb3V0KGF0dGVtcHQsIDEwMCAqIHJldHJ5Q291bnQpOyAvLyBFeHBvbmVudGlhbCBiYWNrb2ZmXG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoXG5cdFx0XHRcdFx0XHRcdGDinYwgRXZlbnQgJHtldmVudElkfSBmYWlsZWQgYWZ0ZXIgJHttYXhSZXRyaWVzfSByZXRyaWVzYFxuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdHJlc29sdmUoZmFsc2UpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cdFx0XHR9O1xuXG5cdFx0XHRhdHRlbXB0KCk7XG5cdFx0fSk7XG5cdH1cblxuXHQvLyBEYXRhIGV4cG9ydCBhbmQgYW5hbHlzaXMgbWV0aG9kc1xuXHRleHBvcnRBbmFseXRpY3MoKToge1xuXHRcdHNlc3Npb246IFVzZXJCZWhhdmlvck1ldHJpY3M7XG5cdFx0ZXZlbnRzOiBEcmF3aW5nRXZlbnRbXTtcblx0XHRuZXR3b3JrOiBOZXR3b3JrTWV0cmljc1tdO1xuXHRcdHBlcmZvcm1hbmNlOiBQZXJmb3JtYW5jZU1ldHJpY3NbXTtcblx0XHRzdW1tYXJ5OiBhbnk7XG5cdH0ge1xuXHRcdHJldHVybiB7XG5cdFx0XHRzZXNzaW9uOiB0aGlzLnVzZXJCZWhhdmlvcixcblx0XHRcdGV2ZW50czogdGhpcy5ldmVudHMsXG5cdFx0XHRuZXR3b3JrOiB0aGlzLm5ldHdvcmtNZXRyaWNzLFxuXHRcdFx0cGVyZm9ybWFuY2U6IHRoaXMucGVyZm9ybWFuY2VNZXRyaWNzLFxuXHRcdFx0c3VtbWFyeTogdGhpcy5nZW5lcmF0ZVN1bW1hcnkoKSxcblx0XHR9O1xuXHR9XG5cblx0cHJpdmF0ZSBnZW5lcmF0ZVN1bW1hcnkoKSB7XG5cdFx0Y29uc3QgdG90YWxFdmVudHMgPSB0aGlzLmV2ZW50cy5sZW5ndGg7XG5cdFx0Y29uc3QgYXZnUlRUID1cblx0XHRcdHRoaXMubmV0d29ya01ldHJpY3MucmVkdWNlKChzdW0sIG0pID0+IHN1bSArIG0ucnR0LCAwKSAvXG5cdFx0XHRcdHRoaXMubmV0d29ya01ldHJpY3MubGVuZ3RoIHx8IDA7XG5cdFx0Y29uc3QgYWNrbm93bGVkZ2VkTWVzc2FnZXMgPSB0aGlzLm5ldHdvcmtNZXRyaWNzLmZpbHRlcihcblx0XHRcdChtKSA9PiBtLmFja25vd2xlZGdlZFxuXHRcdCk7XG5cdFx0Y29uc3QgbmFja01lc3NhZ2VzID0gdGhpcy5uZXR3b3JrTWV0cmljcy5maWx0ZXIoKG0pID0+ICFtLmFja25vd2xlZGdlZCk7XG5cdFx0Y29uc3QgZmFpbGVkRGF0YVNlbmQgPSBuYWNrTWVzc2FnZXMucmVkdWNlKFxuXHRcdFx0KHN1bTogbnVtYmVyLCBpOiBOZXR3b3JrTWV0cmljcykgPT4gc3VtICsgaS5wYXlsb2FkU2l6ZSxcblx0XHRcdDBcblx0XHQpO1xuXG5cdFx0Y29uc3Qgc3VjY2Vzc1JhdGUgPVxuXHRcdFx0KGFja25vd2xlZGdlZE1lc3NhZ2VzLmxlbmd0aCAvIHRoaXMubmV0d29ya01ldHJpY3MubGVuZ3RoKSAqIDEwMCB8fCAwO1xuXHRcdGNvbnN0IHRvdGFsRGF0YVNlbmQgPSBhY2tub3dsZWRnZWRNZXNzYWdlcy5yZWR1Y2UoXG5cdFx0XHQoc3VtOiBudW1iZXIsIGk6IE5ldHdvcmtNZXRyaWNzKSA9PiBzdW0gKyBpLnBheWxvYWRTaXplLFxuXHRcdFx0MFxuXHRcdCk7XG5cdFx0Y29uc29sZS5sb2coJ2ZhaWxlZERhdGFTZW5kLCcsIGZhaWxlZERhdGFTZW5kKTtcblx0XHRjb25zdCB0b3RhbERhdGFBdHRlbXB0ZWQgPSB0b3RhbERhdGFTZW5kICsgZmFpbGVkRGF0YVNlbmQ7XG5cdFx0Y29uc3QgZGF0YUVmZmljaWVuY3lSYXRlID0gKHRvdGFsRGF0YVNlbmQgLyB0b3RhbERhdGFBdHRlbXB0ZWQpICogMTAwO1xuXHRcdGNvbnN0IGF2Z1N1Y2Nlc3NmdWxQYXlsb2FkU2l6ZSA9XG5cdFx0XHR0b3RhbERhdGFTZW5kIC8gYWNrbm93bGVkZ2VkTWVzc2FnZXMubGVuZ3RoO1xuXHRcdGNvbnN0IGF2Z0ZhaWxlZFBheWxvYWRTaXplID0gZmFpbGVkRGF0YVNlbmQgLyBuYWNrTWVzc2FnZXMubGVuZ3RoO1xuXG5cdFx0Y29uc3QgYXZnRlBTID1cblx0XHRcdHRoaXMucGVyZm9ybWFuY2VNZXRyaWNzLnJlZHVjZSgoc3VtLCBtKSA9PiBzdW0gKyBtLmZwcywgMCkgL1xuXHRcdFx0XHR0aGlzLnBlcmZvcm1hbmNlTWV0cmljcy5sZW5ndGggfHwgMDtcblxuXHRcdHJldHVybiB7XG5cdFx0XHR0b3RhbEV2ZW50cyxcblx0XHRcdGF2Z1JUVDogTWF0aC5yb3VuZChhdmdSVFQgKiAxMDApIC8gMTAwLFxuXHRcdFx0c3VjY2Vzc1JhdGU6IE1hdGgucm91bmQoc3VjY2Vzc1JhdGUgKiAxMDApIC8gMTAwLFxuXHRcdFx0YXZnRlBTOiBNYXRoLnJvdW5kKGF2Z0ZQUyksXG5cdFx0XHR0b3RhbERhdGFTZW5kOiBNYXRoLnJvdW5kKHRvdGFsRGF0YVNlbmQpLFxuXHRcdFx0ZGF0YUVmZmljaWVuY3lSYXRlOiBNYXRoLnJvdW5kKGRhdGFFZmZpY2llbmN5UmF0ZSksXG5cdFx0XHRhdmdTdWNjZXNzZnVsUGF5bG9hZFNpemU6IE1hdGgucm91bmQoYXZnU3VjY2Vzc2Z1bFBheWxvYWRTaXplKSxcblx0XHRcdGF2Z0ZhaWxlZFBheWxvYWRTaXplOiBNYXRoLnJvdW5kKGF2Z0ZhaWxlZFBheWxvYWRTaXplKSxcblx0XHRcdHNlc3Npb25EdXJhdGlvbjogRGF0ZS5ub3coKSAtIHRoaXMudXNlckJlaGF2aW9yLnNlc3Npb25TdGFydCxcblx0XHRcdG5ldHdvcmtRdWFsaXR5RGlzdHJpYnV0aW9uOiB0aGlzLmdldE5ldHdvcmtRdWFsaXR5RGlzdHJpYnV0aW9uKCksXG5cdFx0fTtcblx0fVxuXG5cdHByaXZhdGUgZ2V0TmV0d29ya1F1YWxpdHlEaXN0cmlidXRpb24oKSB7XG5cdFx0Y29uc3QgZGlzdHJpYnV0aW9uID0geyBleGNlbGxlbnQ6IDAsIGdvb2Q6IDAsIGZhaXI6IDAsIHBvb3I6IDAsIGRlY2VudDogMCB9O1xuXHRcdHRoaXMubmV0d29ya01ldHJpY3MuZm9yRWFjaCgobWV0cmljKSA9PiB7XG5cdFx0XHRkaXN0cmlidXRpb25bbWV0cmljLmNvbm5lY3Rpb25RdWFsaXR5XSsrO1xuXHRcdH0pO1xuXHRcdHJldHVybiBkaXN0cmlidXRpb247XG5cdH1cblxuXHQvLyBSZWFsLXRpbWUgbW9uaXRvcmluZyBkYXNoYm9hcmQgKGNvbnNvbGUtYmFzZWQpXG5cdHN0YXJ0UmVhbHRpbWVNb25pdG9yaW5nKGludGVydmFsTXM6IG51bWJlciA9IDUwMDApOiB2b2lkIHtcblx0XHRzZXRJbnRlcnZhbCgoKSA9PiB7XG5cdFx0XHRjb25zdCBzdW1tYXJ5ID0gdGhpcy5nZW5lcmF0ZVN1bW1hcnkoKTtcblx0XHRcdGNvbnNvbGUubG9nKFxuXHRcdFx0XHQnU2Vzc2lvbiBEdXJhdGlvbjonLFxuXHRcdFx0XHRgJHtNYXRoLnJvdW5kKHN1bW1hcnkuc2Vzc2lvbkR1cmF0aW9uIC8gMTAwMCl9c2Bcblx0XHRcdCk7XG5cdFx0XHRjb25zb2xlLmxvZygnVG90YWwgRXZlbnRzOicsIHN1bW1hcnkudG90YWxFdmVudHMpO1xuXHRcdFx0Y29uc29sZS5sb2coJ0F2ZXJhZ2UgUlRUOicsIGAke3N1bW1hcnkuYXZnUlRUfW1zYCk7XG5cdFx0XHRjb25zb2xlLmxvZygnU3VjY2VzcyBSYXRlOicsIGAke3N1bW1hcnkuc3VjY2Vzc1JhdGV9JWApO1xuXHRcdFx0Y29uc29sZS5sb2coJ0F2ZXJhZ2UgRlBTOicsIHN1bW1hcnkuYXZnRlBTKTtcblx0XHRcdGNvbnNvbGUubG9nKCdOZXR3b3JrIFF1YWxpdHk6Jywgc3VtbWFyeS5uZXR3b3JrUXVhbGl0eURpc3RyaWJ1dGlvbik7XG5cblx0XHRcdGNvbnNvbGUuZ3JvdXBFbmQoKTtcblx0XHR9LCBpbnRlcnZhbE1zKTtcblx0fVxufVxuXG5leHBvcnQgZGVmYXVsdCBEcmF3aW5nQW5hbHl0aWNzO1xuIl0sIm5hbWVzIjpbInNpemVvZiIsIkRyYXdpbmdBbmFseXRpY3MiLCJnZW5lcmF0ZUlkIiwiTWF0aCIsIkRhdGUiLCJub3ciLCJyYW5kb20iLCJ0b1N0cmluZyIsInN1YnN0ciIsImluaXRpYWxpemVVc2VyQmVoYXZpb3IiLCJzZXNzaW9uSWQiLCJ1c2VySWQiLCJzZXNzaW9uU3RhcnQiLCJ0b3RhbFN0cm9rZXMiLCJhdmVyYWdlU3Ryb2tlTGVuZ3RoIiwibW9zdFVzZWRUb29sIiwibW9zdFVzZWRDb2xvciIsInRvdGFsRHJhd2luZ1RpbWUiLCJpZGxlVGltZSIsInVuZG9Db3VudCIsInJlZG9Db3VudCIsImNhbnZhc0NsZWFyQ291bnQiLCJzdGFydFBlcmlvZGljU3luYyIsImludGVydmFsTXMiLCJzeW5jVGltZXIiLCJzZXRJbnRlcnZhbCIsInN5bmNOb3ciLCJjb25zb2xlIiwibG9nIiwic3RvcmFnZSIsInF1ZXVlRm9yU3luYyIsInN5bmNRdWV1ZSIsImdldFN5bmNRdWV1ZSIsInN5bmNlZENvdW50IiwicGF5bG9hZCIsInN1Y2Nlc3MiLCJjbGVhclN5bmNlZERhdGEiLCJ0aW1lc3RhbXAiLCJjbGVhckxvY2FsRGF0YSIsImxvZ0RyYXdpbmdFdmVudCIsImV2ZW50VHlwZSIsImRhdGEiLCJldmVudElkIiwiZXZlbnQiLCJldmVudHMiLCJwdXNoIiwidXBkYXRlVXNlckJlaGF2aW9yIiwibGFzdEFjdGl2aXR5IiwiZ3JvdXAiLCJ0b0lTT1N0cmluZyIsImdyb3VwRW5kIiwibG9nTmV0d29ya0V2ZW50Iiwic3RhcnRUaW1lIiwiYWNrbm93bGVkZ2VkIiwicGF5bG9hZFNpemUiLCJyZXRyeUNvdW50IiwicnR0IiwicGVyZm9ybWFuY2UiLCJjb25uZWN0aW9uUXVhbGl0eSIsImFzc2Vzc0Nvbm5lY3Rpb25RdWFsaXR5IiwibmV0d29ya01ldHJpYyIsIm5ldHdvcmtNZXRyaWNzIiwidG9GaXhlZCIsIndhcm4iLCJzdGFydFBlcmZvcm1hbmNlTW9uaXRvcmluZyIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsIm1vbml0b3IiLCJkZWx0YVRpbWUiLCJsYXN0RlBTQ2hlY2siLCJmcHMiLCJmcmFtZUNvdW50IiwibWVtb3J5VXNhZ2UiLCJtZW1vcnkiLCJ1c2VkSlNIZWFwU2l6ZSIsInBlcmZNZXRyaWMiLCJyb3VuZCIsImNhbnZhc1JlbmRlclRpbWUiLCJldmVudFByb2Nlc3NpbmdUaW1lIiwicXVldWVkRXZlbnRzIiwiZXZlbnRRdWV1ZSIsImxlbmd0aCIsInBlcmZvcm1hbmNlTWV0cmljcyIsInVzZXJCZWhhdmlvciIsImN1cnJlbnRTdHJva2VTdGFydCIsInN0cm9rZUR1cmF0aW9uIiwiZW1pdFdpdGhMb2dnaW5nIiwic29ja2V0IiwiZXZlbnROYW1lIiwib3B0aW9ucyIsIlByb21pc2UiLCJyZXNvbHZlIiwibWF4UmV0cmllcyIsImF0dGVtcHQiLCJlbWl0IiwiYWNrIiwic2V0VGltZW91dCIsImVycm9yIiwiZXhwb3J0QW5hbHl0aWNzIiwic2Vzc2lvbiIsIm5ldHdvcmsiLCJzdW1tYXJ5IiwiZ2VuZXJhdGVTdW1tYXJ5IiwidG90YWxFdmVudHMiLCJhdmdSVFQiLCJyZWR1Y2UiLCJzdW0iLCJtIiwiYWNrbm93bGVkZ2VkTWVzc2FnZXMiLCJmaWx0ZXIiLCJuYWNrTWVzc2FnZXMiLCJmYWlsZWREYXRhU2VuZCIsImkiLCJzdWNjZXNzUmF0ZSIsInRvdGFsRGF0YVNlbmQiLCJ0b3RhbERhdGFBdHRlbXB0ZWQiLCJkYXRhRWZmaWNpZW5jeVJhdGUiLCJhdmdTdWNjZXNzZnVsUGF5bG9hZFNpemUiLCJhdmdGYWlsZWRQYXlsb2FkU2l6ZSIsImF2Z0ZQUyIsInNlc3Npb25EdXJhdGlvbiIsIm5ldHdvcmtRdWFsaXR5RGlzdHJpYnV0aW9uIiwiZ2V0TmV0d29ya1F1YWxpdHlEaXN0cmlidXRpb24iLCJkaXN0cmlidXRpb24iLCJleGNlbGxlbnQiLCJnb29kIiwiZmFpciIsInBvb3IiLCJkZWNlbnQiLCJmb3JFYWNoIiwibWV0cmljIiwic3RhcnRSZWFsdGltZU1vbml0b3JpbmciLCJjb25zdHJ1Y3RvciJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/util/DrawingAnalytics.ts\n"));

/***/ })

});