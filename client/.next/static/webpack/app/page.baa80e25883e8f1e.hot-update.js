"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/util/AnalyticsLocalStorageManager.ts":
/*!**************************************************!*\
  !*** ./src/util/AnalyticsLocalStorageManager.ts ***!
  \**************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var object_sizeof__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! object-sizeof */ \"(app-pages-browser)/../node_modules/object-sizeof/indexv2.js\");\n/* harmony import */ var object_sizeof__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(object_sizeof__WEBPACK_IMPORTED_MODULE_0__);\n\nclass AnalyticsLocalStorageManager {\n    // Store data with size management\n    storeData(key, data) {\n        try {\n            const serialized = JSON.stringify(data);\n            console.log('sizeof serialized:', object_sizeof__WEBPACK_IMPORTED_MODULE_0___default()(serialized));\n            const sizeInMB = new Blob([\n                serialized\n            ]).size / (1024 * 1024);\n            console.log('sizeof sizeInMB:', sizeInMB);\n            // If data is getting too large (>5MB), keep only recent items\n            if (sizeInMB > 5) {\n                const recentData = data.slice(-1000); // Keep last 1000 items\n                localStorage.setItem(key, JSON.stringify(recentData));\n                console.warn(\"\\uD83D\\uDCE6 Storage size exceeded for \".concat(key, \", keeping recent \").concat(recentData.length, \" items\"));\n            } else {\n                localStorage.setItem(key, serialized);\n            }\n        } catch (error) {\n            console.error(\"❌ Failed to store \".concat(key, \":\"), error);\n            this.handleStorageError(key, data);\n        }\n    }\n    getData(key) {\n        try {\n            const data = localStorage.getItem(key);\n            return data ? JSON.parse(data) : [];\n        } catch (error) {\n            console.error(\"❌ Failed to retrieve \".concat(key, \":\"), error);\n            return [];\n        }\n    }\n    appendData(key, newItem) {\n        const existing = this.getData(key);\n        existing.push(newItem);\n        this.storeData(key, existing);\n    }\n    updateUserBehavior(behavior) {\n        localStorage.setItem(this.STORAGE_KEYS.USER_BEHAVIOR, JSON.stringify(behavior));\n    }\n    getUserBehavior() {\n        const data = localStorage.getItem(this.STORAGE_KEYS.USER_BEHAVIOR);\n        return data ? JSON.parse(data) : null;\n    }\n    // Queue data for syncing\n    queueForSync(sessionId) {\n        const payload = {\n            sessionId,\n            events: this.getData(this.STORAGE_KEYS.EVENTS),\n            networkMetrics: this.getData(this.STORAGE_KEYS.NETWORK),\n            performanceMetrics: this.getData(this.STORAGE_KEYS.PERFORMANCE),\n            userBehavior: this.getUserBehavior() || {},\n            timestamp: Date.now()\n        };\n        const syncQueue = this.getData(this.STORAGE_KEYS.SYNC_QUEUE);\n        syncQueue.push(payload);\n        this.storeData(this.STORAGE_KEYS.SYNC_QUEUE, syncQueue);\n    }\n    getSyncQueue() {\n        return this.getData(this.STORAGE_KEYS.SYNC_QUEUE);\n    }\n    clearSyncedData(timestamp) {\n        const queue = this.getSyncQueue().filter((item)=>item.timestamp > timestamp);\n        this.storeData(this.STORAGE_KEYS.SYNC_QUEUE, queue);\n    }\n    clearLocalData() {\n        Object.values(this.STORAGE_KEYS).forEach((key)=>{\n            if (key !== this.STORAGE_KEYS.SYNC_QUEUE) {\n                localStorage.removeItem(key);\n            }\n        });\n    }\n    handleStorageError(key, data) {\n        // Try to clear old data and retry\n        if (Array.isArray(data) && data.length > 100) {\n            const reducedData = data.slice(-50);\n            try {\n                localStorage.setItem(key, JSON.stringify(reducedData));\n                console.warn(\"Reduced \".concat(key, \" data size and retried\"));\n            } catch (e) {\n                console.error(\"Critical storage error for \".concat(key));\n            }\n        }\n    }\n    getStorageInfo() {\n        const info = Object.entries(this.STORAGE_KEYS).map((param)=>{\n            let [name, key] = param;\n            const data = localStorage.getItem(key);\n            const size = data ? new Blob([\n                data\n            ]).size : 0;\n            return {\n                name,\n                key,\n                size: \"\".concat((size / 1024).toFixed(2), \" KB\"),\n                items: data ? JSON.parse(data).length || 1 : 0\n            };\n        });\n        return info;\n    }\n    constructor(){\n        this.STORAGE_KEYS = {\n            EVENTS: 'drawing_analytics_events',\n            NETWORK: 'drawing_analytics_network',\n            PERFORMANCE: 'drawing_analytics_performance',\n            USER_BEHAVIOR: 'drawing_analytics_behavior',\n            SYNC_QUEUE: 'drawing_analytics_sync_queue',\n            LAST_SYNC: 'drawing_analytics_last_sync'\n        };\n    }\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (AnalyticsLocalStorageManager);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy91dGlsL0FuYWx5dGljc0xvY2FsU3RvcmFnZU1hbmFnZXIudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQW1DO0FBaUVuQyxNQUFNQztJQVVMLGtDQUFrQztJQUNsQ0MsVUFBYUMsR0FBVyxFQUFFQyxJQUFTLEVBQVE7UUFDMUMsSUFBSTtZQUNILE1BQU1DLGFBQWFDLEtBQUtDLFNBQVMsQ0FBQ0g7WUFDbENJLFFBQVFDLEdBQUcsQ0FBQyxzQkFBc0JULG9EQUFNQSxDQUFDSztZQUV6QyxNQUFNSyxXQUFXLElBQUlDLEtBQUs7Z0JBQUNOO2FBQVcsRUFBRU8sSUFBSSxHQUFJLFFBQU8sSUFBRztZQUMxREosUUFBUUMsR0FBRyxDQUFDLG9CQUFvQkM7WUFFaEMsOERBQThEO1lBQzlELElBQUlBLFdBQVcsR0FBRztnQkFDakIsTUFBTUcsYUFBYVQsS0FBS1UsS0FBSyxDQUFDLENBQUMsT0FBTyx1QkFBdUI7Z0JBQzdEQyxhQUFhQyxPQUFPLENBQUNiLEtBQUtHLEtBQUtDLFNBQVMsQ0FBQ007Z0JBQ3pDTCxRQUFRUyxJQUFJLENBQ1gsMENBQXVESixPQUF2QlYsS0FBSSxxQkFBcUMsT0FBbEJVLFdBQVdLLE1BQU0sRUFBQztZQUUzRSxPQUFPO2dCQUNOSCxhQUFhQyxPQUFPLENBQUNiLEtBQUtFO1lBQzNCO1FBQ0QsRUFBRSxPQUFPYyxPQUFPO1lBQ2ZYLFFBQVFXLEtBQUssQ0FBQyxxQkFBeUIsT0FBSmhCLEtBQUksTUFBSWdCO1lBQzNDLElBQUksQ0FBQ0Msa0JBQWtCLENBQUNqQixLQUFLQztRQUM5QjtJQUNEO0lBRUFpQixRQUFXbEIsR0FBVyxFQUFPO1FBQzVCLElBQUk7WUFDSCxNQUFNQyxPQUFPVyxhQUFhTyxPQUFPLENBQUNuQjtZQUNsQyxPQUFPQyxPQUFPRSxLQUFLaUIsS0FBSyxDQUFDbkIsUUFBUSxFQUFFO1FBQ3BDLEVBQUUsT0FBT2UsT0FBTztZQUNmWCxRQUFRVyxLQUFLLENBQUMsd0JBQTRCLE9BQUpoQixLQUFJLE1BQUlnQjtZQUM5QyxPQUFPLEVBQUU7UUFDVjtJQUNEO0lBRUFLLFdBQWNyQixHQUFXLEVBQUVzQixPQUFVLEVBQVE7UUFDNUMsTUFBTUMsV0FBVyxJQUFJLENBQUNMLE9BQU8sQ0FBSWxCO1FBQ2pDdUIsU0FBU0MsSUFBSSxDQUFDRjtRQUNkLElBQUksQ0FBQ3ZCLFNBQVMsQ0FBQ0MsS0FBS3VCO0lBQ3JCO0lBRUFFLG1CQUFtQkMsUUFBNkIsRUFBUTtRQUN2RGQsYUFBYUMsT0FBTyxDQUNuQixJQUFJLENBQUNjLFlBQVksQ0FBQ0MsYUFBYSxFQUMvQnpCLEtBQUtDLFNBQVMsQ0FBQ3NCO0lBRWpCO0lBRUFHLGtCQUE4QztRQUM3QyxNQUFNNUIsT0FBT1csYUFBYU8sT0FBTyxDQUFDLElBQUksQ0FBQ1EsWUFBWSxDQUFDQyxhQUFhO1FBQ2pFLE9BQU8zQixPQUFPRSxLQUFLaUIsS0FBSyxDQUFDbkIsUUFBUTtJQUNsQztJQUVBLHlCQUF5QjtJQUN6QjZCLGFBQWFDLFNBQWlCLEVBQVE7UUFDckMsTUFBTUMsVUFBNEI7WUFDakNEO1lBQ0FFLFFBQVEsSUFBSSxDQUFDZixPQUFPLENBQWUsSUFBSSxDQUFDUyxZQUFZLENBQUNPLE1BQU07WUFDM0RDLGdCQUFnQixJQUFJLENBQUNqQixPQUFPLENBQWlCLElBQUksQ0FBQ1MsWUFBWSxDQUFDUyxPQUFPO1lBQ3RFQyxvQkFBb0IsSUFBSSxDQUFDbkIsT0FBTyxDQUMvQixJQUFJLENBQUNTLFlBQVksQ0FBQ1csV0FBVztZQUU5QkMsY0FBYyxJQUFJLENBQUNWLGVBQWUsTUFBTyxDQUFDO1lBQzFDVyxXQUFXQyxLQUFLQyxHQUFHO1FBQ3BCO1FBRUEsTUFBTUMsWUFBWSxJQUFJLENBQUN6QixPQUFPLENBQzdCLElBQUksQ0FBQ1MsWUFBWSxDQUFDaUIsVUFBVTtRQUU3QkQsVUFBVW5CLElBQUksQ0FBQ1E7UUFDZixJQUFJLENBQUNqQyxTQUFTLENBQUMsSUFBSSxDQUFDNEIsWUFBWSxDQUFDaUIsVUFBVSxFQUFFRDtJQUM5QztJQUVBRSxlQUFtQztRQUNsQyxPQUFPLElBQUksQ0FBQzNCLE9BQU8sQ0FBbUIsSUFBSSxDQUFDUyxZQUFZLENBQUNpQixVQUFVO0lBQ25FO0lBRUFFLGdCQUFnQk4sU0FBaUIsRUFBUTtRQUN4QyxNQUFNTyxRQUFRLElBQUksQ0FBQ0YsWUFBWSxHQUFHRyxNQUFNLENBQ3ZDLENBQUNDLE9BQVNBLEtBQUtULFNBQVMsR0FBR0E7UUFFNUIsSUFBSSxDQUFDekMsU0FBUyxDQUFDLElBQUksQ0FBQzRCLFlBQVksQ0FBQ2lCLFVBQVUsRUFBRUc7SUFDOUM7SUFFQUcsaUJBQXVCO1FBQ3RCQyxPQUFPQyxNQUFNLENBQUMsSUFBSSxDQUFDekIsWUFBWSxFQUFFMEIsT0FBTyxDQUFDLENBQUNyRDtZQUN6QyxJQUFJQSxRQUFRLElBQUksQ0FBQzJCLFlBQVksQ0FBQ2lCLFVBQVUsRUFBRTtnQkFDekNoQyxhQUFhMEMsVUFBVSxDQUFDdEQ7WUFDekI7UUFDRDtJQUNEO0lBRVFpQixtQkFBc0JqQixHQUFXLEVBQUVDLElBQVMsRUFBUTtRQUMzRCxrQ0FBa0M7UUFDbEMsSUFBSXNELE1BQU1DLE9BQU8sQ0FBQ3ZELFNBQVNBLEtBQUtjLE1BQU0sR0FBRyxLQUFLO1lBQzdDLE1BQU0wQyxjQUFjeEQsS0FBS1UsS0FBSyxDQUFDLENBQUM7WUFDaEMsSUFBSTtnQkFDSEMsYUFBYUMsT0FBTyxDQUFDYixLQUFLRyxLQUFLQyxTQUFTLENBQUNxRDtnQkFDekNwRCxRQUFRUyxJQUFJLENBQUMsV0FBZSxPQUFKZCxLQUFJO1lBQzdCLEVBQUUsVUFBTTtnQkFDUEssUUFBUVcsS0FBSyxDQUFDLDhCQUFrQyxPQUFKaEI7WUFDN0M7UUFDRDtJQUNEO0lBRUEwRCxpQkFBaUI7UUFDaEIsTUFBTUMsT0FBT1IsT0FBT1MsT0FBTyxDQUFDLElBQUksQ0FBQ2pDLFlBQVksRUFBRWtDLEdBQUcsQ0FBQztnQkFBQyxDQUFDQyxNQUFNOUQsSUFBSTtZQUM5RCxNQUFNQyxPQUFPVyxhQUFhTyxPQUFPLENBQUNuQjtZQUNsQyxNQUFNUyxPQUFPUixPQUFPLElBQUlPLEtBQUs7Z0JBQUNQO2FBQUssRUFBRVEsSUFBSSxHQUFHO1lBQzVDLE9BQU87Z0JBQ05xRDtnQkFDQTlEO2dCQUNBUyxNQUFNLEdBQTRCLE9BQXpCLENBQUNBLE9BQU8sSUFBRyxFQUFHc0QsT0FBTyxDQUFDLElBQUc7Z0JBQ2xDQyxPQUFPL0QsT0FBT0UsS0FBS2lCLEtBQUssQ0FBQ25CLE1BQU1jLE1BQU0sSUFBSSxJQUFJO1lBQzlDO1FBQ0Q7UUFDQSxPQUFPNEM7SUFDUjs7YUE5SGlCaEMsZUFBZTtZQUMvQk8sUUFBUTtZQUNSRSxTQUFTO1lBQ1RFLGFBQWE7WUFDYlYsZUFBZTtZQUNmZ0IsWUFBWTtZQUNacUIsV0FBVztRQUNaOztBQXdIRDtBQUVBLGlFQUFlbkUsNEJBQTRCQSxFQUFDIiwic291cmNlcyI6WyIvVXNlcnMvZW1yZXlpbGRpcmltL0Rlc2t0b3AvZmluYWxQcm9qZWN0L2NsaWVudC9zcmMvdXRpbC9BbmFseXRpY3NMb2NhbFN0b3JhZ2VNYW5hZ2VyLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBzaXplb2YgZnJvbSAnb2JqZWN0LXNpemVvZic7XG5cbmludGVyZmFjZSBEcmF3aW5nRXZlbnQge1xuXHRldmVudElkOiBzdHJpbmc7XG5cdHRpbWVzdGFtcDogbnVtYmVyO1xuXHRldmVudFR5cGU6XG5cdFx0fCAnc3Ryb2tlX3N0YXJ0J1xuXHRcdHwgJ3N0cm9rZV9jb250aW51ZSdcblx0XHR8ICdzdHJva2VfZW5kJ1xuXHRcdHwgJ2NhbnZhc19jbGVhcidcblx0XHR8ICd1bmRvJ1xuXHRcdHwgJ3JlZG8nO1xuXHRzdHJva2VJZD86IHN0cmluZztcblx0Y29vcmRpbmF0ZXM/OiB7IHg6IG51bWJlcjsgeTogbnVtYmVyIH07XG5cdHByZXNzdXJlPzogbnVtYmVyO1xuXHR0b29sPzogc3RyaW5nO1xuXHRjb2xvcj86IHN0cmluZztcblx0YnJ1c2hTaXplPzogbnVtYmVyO1xuXHR1c2VySWQ/OiBzdHJpbmc7XG5cdHNlc3Npb25JZDogc3RyaW5nO1xufVxuXG5pbnRlcmZhY2UgTmV0d29ya01ldHJpY3Mge1xuXHRldmVudElkOiBzdHJpbmc7XG5cdHRpbWVzdGFtcDogbnVtYmVyO1xuXHRydHQ6IG51bWJlcjtcblx0YWNrbm93bGVkZ2VkOiBib29sZWFuO1xuXHRyZXRyeUNvdW50OiBudW1iZXI7XG5cdHBheWxvYWRTaXplOiBudW1iZXI7XG5cdGNvbm5lY3Rpb25RdWFsaXR5OiAnZXhjZWxsZW50JyB8ICdnb29kJyB8ICdmYWlyJyB8ICdkZWNlbnQnIHwgJ3Bvb3InO1xufVxuXG5pbnRlcmZhY2UgUGVyZm9ybWFuY2VNZXRyaWNzIHtcblx0dGltZXN0YW1wOiBudW1iZXI7XG5cdGZwczogbnVtYmVyO1xuXHRtZW1vcnlVc2FnZTogbnVtYmVyO1xuXHRjYW52YXNSZW5kZXJUaW1lOiBudW1iZXI7XG5cdGV2ZW50UHJvY2Vzc2luZ1RpbWU6IG51bWJlcjtcblx0cXVldWVkRXZlbnRzOiBudW1iZXI7XG59XG5cbmludGVyZmFjZSBVc2VyQmVoYXZpb3JNZXRyaWNzIHtcblx0c2Vzc2lvbklkOiBzdHJpbmc7XG5cdHVzZXJJZD86IHN0cmluZztcblx0c2Vzc2lvblN0YXJ0OiBudW1iZXI7XG5cdHRvdGFsU3Ryb2tlczogbnVtYmVyO1xuXHRhdmVyYWdlU3Ryb2tlTGVuZ3RoOiBudW1iZXI7XG5cdG1vc3RVc2VkVG9vbDogc3RyaW5nO1xuXHRtb3N0VXNlZENvbG9yOiBzdHJpbmc7XG5cdHRvdGFsRHJhd2luZ1RpbWU6IG51bWJlcjtcblx0aWRsZVRpbWU6IG51bWJlcjtcblx0dW5kb0NvdW50OiBudW1iZXI7XG5cdHJlZG9Db3VudDogbnVtYmVyO1xuXHRjYW52YXNDbGVhckNvdW50OiBudW1iZXI7XG59XG5cbmludGVyZmFjZSBBbmFseXRpY3NQYXlsb2FkIHtcblx0c2Vzc2lvbklkOiBzdHJpbmc7XG5cdGV2ZW50czogRHJhd2luZ0V2ZW50W107XG5cdG5ldHdvcmtNZXRyaWNzOiBOZXR3b3JrTWV0cmljc1tdO1xuXHRwZXJmb3JtYW5jZU1ldHJpY3M6IFBlcmZvcm1hbmNlTWV0cmljc1tdO1xuXHR1c2VyQmVoYXZpb3I6IFVzZXJCZWhhdmlvck1ldHJpY3M7XG5cdHRpbWVzdGFtcDogbnVtYmVyO1xufVxuXG5jbGFzcyBBbmFseXRpY3NMb2NhbFN0b3JhZ2VNYW5hZ2VyIHtcblx0cHJpdmF0ZSByZWFkb25seSBTVE9SQUdFX0tFWVMgPSB7XG5cdFx0RVZFTlRTOiAnZHJhd2luZ19hbmFseXRpY3NfZXZlbnRzJyxcblx0XHRORVRXT1JLOiAnZHJhd2luZ19hbmFseXRpY3NfbmV0d29yaycsXG5cdFx0UEVSRk9STUFOQ0U6ICdkcmF3aW5nX2FuYWx5dGljc19wZXJmb3JtYW5jZScsXG5cdFx0VVNFUl9CRUhBVklPUjogJ2RyYXdpbmdfYW5hbHl0aWNzX2JlaGF2aW9yJyxcblx0XHRTWU5DX1FVRVVFOiAnZHJhd2luZ19hbmFseXRpY3Nfc3luY19xdWV1ZScsXG5cdFx0TEFTVF9TWU5DOiAnZHJhd2luZ19hbmFseXRpY3NfbGFzdF9zeW5jJyxcblx0fTtcblxuXHQvLyBTdG9yZSBkYXRhIHdpdGggc2l6ZSBtYW5hZ2VtZW50XG5cdHN0b3JlRGF0YTxUPihrZXk6IHN0cmluZywgZGF0YTogVFtdKTogdm9pZCB7XG5cdFx0dHJ5IHtcblx0XHRcdGNvbnN0IHNlcmlhbGl6ZWQgPSBKU09OLnN0cmluZ2lmeShkYXRhKTtcblx0XHRcdGNvbnNvbGUubG9nKCdzaXplb2Ygc2VyaWFsaXplZDonLCBzaXplb2Yoc2VyaWFsaXplZCkpO1xuXG5cdFx0XHRjb25zdCBzaXplSW5NQiA9IG5ldyBCbG9iKFtzZXJpYWxpemVkXSkuc2l6ZSAvICgxMDI0ICogMTAyNCk7XG5cdFx0XHRjb25zb2xlLmxvZygnc2l6ZW9mIHNpemVJbk1COicsIHNpemVJbk1CKTtcblxuXHRcdFx0Ly8gSWYgZGF0YSBpcyBnZXR0aW5nIHRvbyBsYXJnZSAoPjVNQiksIGtlZXAgb25seSByZWNlbnQgaXRlbXNcblx0XHRcdGlmIChzaXplSW5NQiA+IDUpIHtcblx0XHRcdFx0Y29uc3QgcmVjZW50RGF0YSA9IGRhdGEuc2xpY2UoLTEwMDApOyAvLyBLZWVwIGxhc3QgMTAwMCBpdGVtc1xuXHRcdFx0XHRsb2NhbFN0b3JhZ2Uuc2V0SXRlbShrZXksIEpTT04uc3RyaW5naWZ5KHJlY2VudERhdGEpKTtcblx0XHRcdFx0Y29uc29sZS53YXJuKFxuXHRcdFx0XHRcdGDwn5OmIFN0b3JhZ2Ugc2l6ZSBleGNlZWRlZCBmb3IgJHtrZXl9LCBrZWVwaW5nIHJlY2VudCAke3JlY2VudERhdGEubGVuZ3RofSBpdGVtc2Bcblx0XHRcdFx0KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGxvY2FsU3RvcmFnZS5zZXRJdGVtKGtleSwgc2VyaWFsaXplZCk7XG5cdFx0XHR9XG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdGNvbnNvbGUuZXJyb3IoYOKdjCBGYWlsZWQgdG8gc3RvcmUgJHtrZXl9OmAsIGVycm9yKTtcblx0XHRcdHRoaXMuaGFuZGxlU3RvcmFnZUVycm9yKGtleSwgZGF0YSk7XG5cdFx0fVxuXHR9XG5cblx0Z2V0RGF0YTxUPihrZXk6IHN0cmluZyk6IFRbXSB7XG5cdFx0dHJ5IHtcblx0XHRcdGNvbnN0IGRhdGEgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShrZXkpO1xuXHRcdFx0cmV0dXJuIGRhdGEgPyBKU09OLnBhcnNlKGRhdGEpIDogW107XG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdGNvbnNvbGUuZXJyb3IoYOKdjCBGYWlsZWQgdG8gcmV0cmlldmUgJHtrZXl9OmAsIGVycm9yKTtcblx0XHRcdHJldHVybiBbXTtcblx0XHR9XG5cdH1cblxuXHRhcHBlbmREYXRhPFQ+KGtleTogc3RyaW5nLCBuZXdJdGVtOiBUKTogdm9pZCB7XG5cdFx0Y29uc3QgZXhpc3RpbmcgPSB0aGlzLmdldERhdGE8VD4oa2V5KTtcblx0XHRleGlzdGluZy5wdXNoKG5ld0l0ZW0pO1xuXHRcdHRoaXMuc3RvcmVEYXRhKGtleSwgZXhpc3RpbmcpO1xuXHR9XG5cblx0dXBkYXRlVXNlckJlaGF2aW9yKGJlaGF2aW9yOiBVc2VyQmVoYXZpb3JNZXRyaWNzKTogdm9pZCB7XG5cdFx0bG9jYWxTdG9yYWdlLnNldEl0ZW0oXG5cdFx0XHR0aGlzLlNUT1JBR0VfS0VZUy5VU0VSX0JFSEFWSU9SLFxuXHRcdFx0SlNPTi5zdHJpbmdpZnkoYmVoYXZpb3IpXG5cdFx0KTtcblx0fVxuXG5cdGdldFVzZXJCZWhhdmlvcigpOiBVc2VyQmVoYXZpb3JNZXRyaWNzIHwgbnVsbCB7XG5cdFx0Y29uc3QgZGF0YSA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKHRoaXMuU1RPUkFHRV9LRVlTLlVTRVJfQkVIQVZJT1IpO1xuXHRcdHJldHVybiBkYXRhID8gSlNPTi5wYXJzZShkYXRhKSA6IG51bGw7XG5cdH1cblxuXHQvLyBRdWV1ZSBkYXRhIGZvciBzeW5jaW5nXG5cdHF1ZXVlRm9yU3luYyhzZXNzaW9uSWQ6IHN0cmluZyk6IHZvaWQge1xuXHRcdGNvbnN0IHBheWxvYWQ6IEFuYWx5dGljc1BheWxvYWQgPSB7XG5cdFx0XHRzZXNzaW9uSWQsXG5cdFx0XHRldmVudHM6IHRoaXMuZ2V0RGF0YTxEcmF3aW5nRXZlbnQ+KHRoaXMuU1RPUkFHRV9LRVlTLkVWRU5UUyksXG5cdFx0XHRuZXR3b3JrTWV0cmljczogdGhpcy5nZXREYXRhPE5ldHdvcmtNZXRyaWNzPih0aGlzLlNUT1JBR0VfS0VZUy5ORVRXT1JLKSxcblx0XHRcdHBlcmZvcm1hbmNlTWV0cmljczogdGhpcy5nZXREYXRhPFBlcmZvcm1hbmNlTWV0cmljcz4oXG5cdFx0XHRcdHRoaXMuU1RPUkFHRV9LRVlTLlBFUkZPUk1BTkNFXG5cdFx0XHQpLFxuXHRcdFx0dXNlckJlaGF2aW9yOiB0aGlzLmdldFVzZXJCZWhhdmlvcigpIHx8ICh7fSBhcyBVc2VyQmVoYXZpb3JNZXRyaWNzKSxcblx0XHRcdHRpbWVzdGFtcDogRGF0ZS5ub3coKSxcblx0XHR9O1xuXG5cdFx0Y29uc3Qgc3luY1F1ZXVlID0gdGhpcy5nZXREYXRhPEFuYWx5dGljc1BheWxvYWQ+KFxuXHRcdFx0dGhpcy5TVE9SQUdFX0tFWVMuU1lOQ19RVUVVRVxuXHRcdCk7XG5cdFx0c3luY1F1ZXVlLnB1c2gocGF5bG9hZCk7XG5cdFx0dGhpcy5zdG9yZURhdGEodGhpcy5TVE9SQUdFX0tFWVMuU1lOQ19RVUVVRSwgc3luY1F1ZXVlKTtcblx0fVxuXG5cdGdldFN5bmNRdWV1ZSgpOiBBbmFseXRpY3NQYXlsb2FkW10ge1xuXHRcdHJldHVybiB0aGlzLmdldERhdGE8QW5hbHl0aWNzUGF5bG9hZD4odGhpcy5TVE9SQUdFX0tFWVMuU1lOQ19RVUVVRSk7XG5cdH1cblxuXHRjbGVhclN5bmNlZERhdGEodGltZXN0YW1wOiBudW1iZXIpOiB2b2lkIHtcblx0XHRjb25zdCBxdWV1ZSA9IHRoaXMuZ2V0U3luY1F1ZXVlKCkuZmlsdGVyKFxuXHRcdFx0KGl0ZW0pID0+IGl0ZW0udGltZXN0YW1wID4gdGltZXN0YW1wXG5cdFx0KTtcblx0XHR0aGlzLnN0b3JlRGF0YSh0aGlzLlNUT1JBR0VfS0VZUy5TWU5DX1FVRVVFLCBxdWV1ZSk7XG5cdH1cblxuXHRjbGVhckxvY2FsRGF0YSgpOiB2b2lkIHtcblx0XHRPYmplY3QudmFsdWVzKHRoaXMuU1RPUkFHRV9LRVlTKS5mb3JFYWNoKChrZXkpID0+IHtcblx0XHRcdGlmIChrZXkgIT09IHRoaXMuU1RPUkFHRV9LRVlTLlNZTkNfUVVFVUUpIHtcblx0XHRcdFx0bG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oa2V5KTtcblx0XHRcdH1cblx0XHR9KTtcblx0fVxuXG5cdHByaXZhdGUgaGFuZGxlU3RvcmFnZUVycm9yPFQ+KGtleTogc3RyaW5nLCBkYXRhOiBUW10pOiB2b2lkIHtcblx0XHQvLyBUcnkgdG8gY2xlYXIgb2xkIGRhdGEgYW5kIHJldHJ5XG5cdFx0aWYgKEFycmF5LmlzQXJyYXkoZGF0YSkgJiYgZGF0YS5sZW5ndGggPiAxMDApIHtcblx0XHRcdGNvbnN0IHJlZHVjZWREYXRhID0gZGF0YS5zbGljZSgtNTApO1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0bG9jYWxTdG9yYWdlLnNldEl0ZW0oa2V5LCBKU09OLnN0cmluZ2lmeShyZWR1Y2VkRGF0YSkpO1xuXHRcdFx0XHRjb25zb2xlLndhcm4oYFJlZHVjZWQgJHtrZXl9IGRhdGEgc2l6ZSBhbmQgcmV0cmllZGApO1xuXHRcdFx0fSBjYXRjaCB7XG5cdFx0XHRcdGNvbnNvbGUuZXJyb3IoYENyaXRpY2FsIHN0b3JhZ2UgZXJyb3IgZm9yICR7a2V5fWApO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdGdldFN0b3JhZ2VJbmZvKCkge1xuXHRcdGNvbnN0IGluZm8gPSBPYmplY3QuZW50cmllcyh0aGlzLlNUT1JBR0VfS0VZUykubWFwKChbbmFtZSwga2V5XSkgPT4ge1xuXHRcdFx0Y29uc3QgZGF0YSA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKGtleSk7XG5cdFx0XHRjb25zdCBzaXplID0gZGF0YSA/IG5ldyBCbG9iKFtkYXRhXSkuc2l6ZSA6IDA7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRuYW1lLFxuXHRcdFx0XHRrZXksXG5cdFx0XHRcdHNpemU6IGAkeyhzaXplIC8gMTAyNCkudG9GaXhlZCgyKX0gS0JgLFxuXHRcdFx0XHRpdGVtczogZGF0YSA/IEpTT04ucGFyc2UoZGF0YSkubGVuZ3RoIHx8IDEgOiAwLFxuXHRcdFx0fTtcblx0XHR9KTtcblx0XHRyZXR1cm4gaW5mbztcblx0fVxufVxuXG5leHBvcnQgZGVmYXVsdCBBbmFseXRpY3NMb2NhbFN0b3JhZ2VNYW5hZ2VyO1xuIl0sIm5hbWVzIjpbInNpemVvZiIsIkFuYWx5dGljc0xvY2FsU3RvcmFnZU1hbmFnZXIiLCJzdG9yZURhdGEiLCJrZXkiLCJkYXRhIiwic2VyaWFsaXplZCIsIkpTT04iLCJzdHJpbmdpZnkiLCJjb25zb2xlIiwibG9nIiwic2l6ZUluTUIiLCJCbG9iIiwic2l6ZSIsInJlY2VudERhdGEiLCJzbGljZSIsImxvY2FsU3RvcmFnZSIsInNldEl0ZW0iLCJ3YXJuIiwibGVuZ3RoIiwiZXJyb3IiLCJoYW5kbGVTdG9yYWdlRXJyb3IiLCJnZXREYXRhIiwiZ2V0SXRlbSIsInBhcnNlIiwiYXBwZW5kRGF0YSIsIm5ld0l0ZW0iLCJleGlzdGluZyIsInB1c2giLCJ1cGRhdGVVc2VyQmVoYXZpb3IiLCJiZWhhdmlvciIsIlNUT1JBR0VfS0VZUyIsIlVTRVJfQkVIQVZJT1IiLCJnZXRVc2VyQmVoYXZpb3IiLCJxdWV1ZUZvclN5bmMiLCJzZXNzaW9uSWQiLCJwYXlsb2FkIiwiZXZlbnRzIiwiRVZFTlRTIiwibmV0d29ya01ldHJpY3MiLCJORVRXT1JLIiwicGVyZm9ybWFuY2VNZXRyaWNzIiwiUEVSRk9STUFOQ0UiLCJ1c2VyQmVoYXZpb3IiLCJ0aW1lc3RhbXAiLCJEYXRlIiwibm93Iiwic3luY1F1ZXVlIiwiU1lOQ19RVUVVRSIsImdldFN5bmNRdWV1ZSIsImNsZWFyU3luY2VkRGF0YSIsInF1ZXVlIiwiZmlsdGVyIiwiaXRlbSIsImNsZWFyTG9jYWxEYXRhIiwiT2JqZWN0IiwidmFsdWVzIiwiZm9yRWFjaCIsInJlbW92ZUl0ZW0iLCJBcnJheSIsImlzQXJyYXkiLCJyZWR1Y2VkRGF0YSIsImdldFN0b3JhZ2VJbmZvIiwiaW5mbyIsImVudHJpZXMiLCJtYXAiLCJuYW1lIiwidG9GaXhlZCIsIml0ZW1zIiwiTEFTVF9TWU5DIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/util/AnalyticsLocalStorageManager.ts\n"));

/***/ })

});