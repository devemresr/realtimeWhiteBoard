"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/util/DrawingAnalytics.ts":
/*!**************************************!*\
  !*** ./src/util/DrawingAnalytics.ts ***!
  \**************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var object_sizeof__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! object-sizeof */ \"(app-pages-browser)/../node_modules/object-sizeof/indexv2.js\");\n/* harmony import */ var object_sizeof__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(object_sizeof__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _AnalyticsLocalStorageManager__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./AnalyticsLocalStorageManager */ \"(app-pages-browser)/./src/util/AnalyticsLocalStorageManager.ts\");\n\n\nclass DrawingAnalytics {\n    generateId() {\n        return \"\".concat(Date.now(), \"-\").concat(Math.random().toString(36).substr(2, 9));\n    }\n    loadFromStorage() {\n        // Load existing data if any (useful for page refreshes)\n        const existingBehavior = this.storage.getUserBehavior();\n        if (existingBehavior && existingBehavior.sessionId === this.sessionId) {\n            this.userBehavior = existingBehavior;\n        }\n    }\n    initializeUserBehavior() {\n        return {\n            sessionId: this.sessionId,\n            userId: this.userId,\n            sessionStart: Date.now(),\n            totalStrokes: 0,\n            averageStrokeLength: 0,\n            mostUsedTool: '',\n            mostUsedColor: '',\n            totalDrawingTime: 0,\n            idleTime: 0,\n            undoCount: 0,\n            redoCount: 0,\n            canvasClearCount: 0\n        };\n    }\n    startPeriodicSync(intervalMs) {\n        console.log('startPeriodicSync');\n        this.syncTimer = setInterval(async ()=>{\n            await this.syncNow();\n        }, intervalMs);\n    }\n    // Manual sync trigger\n    async syncNow() {\n        console.log('Starting analytics sync...');\n        // Queue current session data\n        this.storage.queueForSync(this.sessionId);\n        // Try to sync all queued data\n        const syncQueue = this.storage.getSyncQueue();\n        let syncedCount = 0;\n        // todo send to the backend\n        // for (const payload of syncQueue) {\n        // if (success) {\n        // \tthis.storage.clearSyncedData(payload.timestamp);\n        // \tsyncedCount++;\n        // } else {\n        // \tbreak; // Stop on first failure to maintain order\n        // }\n        // }\n        if (syncedCount > 0) {\n            console.log(\"Synced \".concat(syncedCount, \" analytics payloads\"));\n            // Clear local data after successful sync\n            this.storage.clearLocalData();\n            return true;\n        }\n        return false;\n    }\n    // Enhanced drawing event logging with comprehensive data\n    logDrawingEvent(eventType) {\n        let data = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n        const eventId = this.generateId();\n        const timestamp = Date.now();\n        const event = {\n            eventId,\n            timestamp,\n            eventType,\n            sessionId: this.sessionId,\n            userId: this.userId,\n            ...data\n        };\n        this.events.push(event);\n        this.updateUserBehavior(event);\n        this.lastActivity = timestamp;\n        // Log to console with structured format\n        // console.group(`Drawing Event: ${eventType}`);\n        // console.log('Event ID:', eventId);\n        // console.log('Timestamp:', new Date(timestamp).toISOString());\n        // console.log('Data:', data);\n        console.groupEnd();\n        this.storage.appendData(this.storage.STORAGE_KEYS.EVENTS, event);\n        return eventId;\n    }\n    // Enhanced network logging with quality assessment\n    logNetworkEvent(eventId, startTime, acknowledged, payloadSize) {\n        let retryCount = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 0;\n        const rtt = performance.now() - startTime;\n        const connectionQuality = this.assessConnectionQuality(rtt);\n        const networkMetric = {\n            eventId,\n            timestamp: Date.now(),\n            rtt,\n            acknowledged,\n            retryCount,\n            payloadSize,\n            connectionQuality\n        };\n        this.networkMetrics.push(networkMetric);\n        // console.group(`Network Event`);\n        // console.log('Event ID:', eventId);\n        // console.log('RTT:', `${rtt.toFixed(2)}ms`);\n        // console.log('Quality:', connectionQuality);\n        // console.log('Payload Size:', `${payloadSize} bytes`);\n        // console.log('Acknowledged:', acknowledged);\n        this.storage.appendData(this.storage.STORAGE_KEYS.NETWORK, networkMetric);\n        if (retryCount > 0) console.warn('Retry Count:', retryCount);\n        console.groupEnd();\n    }\n    assessConnectionQuality(rtt) {\n        if (rtt < 50) return 'excellent';\n        if (rtt < 100) return 'good';\n        if (rtt < 200) return 'fair';\n        if (rtt < 500) return 'decent';\n        return 'poor';\n    }\n    // Performance monitoring\n    startPerformanceMonitoring() {\n        if ( false || typeof requestAnimationFrame === 'undefined') {\n            console.warn('Performance monitoring not available in this environment');\n            return;\n        }\n        const monitor = ()=>{\n            const now = performance.now();\n            const deltaTime = now - this.lastFPSCheck;\n            if (deltaTime >= 1000) {\n                var _performance_memory;\n                // if its been a second\n                const fps = this.frameCount * 1000 / deltaTime;\n                const memoryUsage = ((_performance_memory = performance.memory) === null || _performance_memory === void 0 ? void 0 : _performance_memory.usedJSHeapSize) || 0;\n                const perfMetric = {\n                    timestamp: Date.now(),\n                    fps: Math.round(fps),\n                    memoryUsage,\n                    canvasRenderTime: 0,\n                    eventProcessingTime: 0,\n                    queuedEvents: this.eventQueue.length\n                };\n                this.performanceMetrics.push(perfMetric);\n                this.frameCount = 0;\n                this.lastFPSCheck = now;\n                this.storage.appendData(this.storage.STORAGE_KEYS.PERFORMANCE, this.performanceMetrics);\n                // Log performance warnings\n                if (fps < 30) {\n                    console.warn(\"Low FPS detected: \".concat(fps.toFixed(1)));\n                }\n                if (this.eventQueue.length > 10) {\n                    console.warn(\"Event queue backlog: \".concat(this.eventQueue.length, \" events\"));\n                }\n            }\n            this.frameCount++;\n            requestAnimationFrame(monitor);\n        };\n        requestAnimationFrame(monitor);\n    }\n    // Update user behavior metrics\n    updateUserBehavior(event) {\n        switch(event.eventType){\n            case 'stroke_start':\n                this.userBehavior.totalStrokes++;\n                this.currentStrokeStart = event.timestamp;\n                break;\n            case 'stroke_end':\n                if (this.currentStrokeStart) {\n                    const strokeDuration = event.timestamp - this.currentStrokeStart;\n                    this.userBehavior.totalDrawingTime += strokeDuration;\n                }\n                break;\n            case 'undo':\n                this.userBehavior.undoCount++;\n                break;\n            case 'redo':\n                this.userBehavior.redoCount++;\n                break;\n            case 'canvas_clear':\n                this.userBehavior.canvasClearCount++;\n                break;\n        }\n    }\n    // Enhanced socket emission with comprehensive logging\n    emitWithLogging(socket, eventName, data) {\n        let options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};\n        return new Promise((resolve)=>{\n            const startTime = performance.now();\n            const eventId = this.logDrawingEvent('stroke_continue', data);\n            const payloadSize = object_sizeof__WEBPACK_IMPORTED_MODULE_0___default()(data);\n            let retryCount = 0;\n            const maxRetries = options.retryCount || 3;\n            const attempt = ()=>{\n                socket.emit(eventName, data, (ack)=>{\n                    this.logNetworkEvent(eventId, startTime, ack, payloadSize, retryCount);\n                    if (ack) {\n                        resolve(true);\n                    } else if (retryCount < maxRetries) {\n                        retryCount++;\n                        console.warn(\"Retrying event \".concat(eventId, \" (attempt \").concat(retryCount, \"/\").concat(maxRetries, \")\"));\n                        setTimeout(attempt, 100 * retryCount); // Exponential backoff\n                    } else {\n                        console.error(\"Event \".concat(eventId, \" failed after \").concat(maxRetries, \" retries\"));\n                        resolve(false);\n                    }\n                });\n            };\n            attempt();\n        });\n    }\n    // Data export and analysis methods\n    exportAnalytics() {\n        return {\n            session: this.userBehavior,\n            events: this.events,\n            network: this.networkMetrics,\n            performance: this.performanceMetrics,\n            summary: this.generateSummary()\n        };\n    }\n    generateSummary() {\n        const totalEvents = this.events.length;\n        const avgRTT = this.networkMetrics.reduce((sum, m)=>sum + m.rtt, 0) / this.networkMetrics.length || 0;\n        const acknowledgedMessages = this.networkMetrics.filter((m)=>m.acknowledged);\n        const nackMessages = this.networkMetrics.filter((m)=>!m.acknowledged);\n        const failedDataSend = nackMessages.reduce((sum, i)=>sum + i.payloadSize, 0);\n        const successRate = acknowledgedMessages.length / this.networkMetrics.length * 100 || 0;\n        const totalDataSend = acknowledgedMessages.reduce((sum, i)=>sum + i.payloadSize, 0);\n        const totalDataAttempted = totalDataSend + failedDataSend;\n        const dataEfficiencyRate = totalDataSend / totalDataAttempted * 100;\n        const avgSuccessfulPayloadSize = totalDataSend / acknowledgedMessages.length;\n        const avgFailedPayloadSize = failedDataSend / nackMessages.length;\n        const avgFPS = this.performanceMetrics.reduce((sum, m)=>sum + m.fps, 0) / this.performanceMetrics.length || 0;\n        return {\n            totalEvents,\n            avgRTT: Math.round(avgRTT * 100) / 100,\n            successRate: Math.round(successRate * 100) / 100,\n            avgFPS: Math.round(avgFPS),\n            totalDataSend: Math.round(totalDataSend),\n            dataEfficiencyRate: Math.round(dataEfficiencyRate),\n            avgSuccessfulPayloadSize: Math.round(avgSuccessfulPayloadSize),\n            avgFailedPayloadSize: Math.round(avgFailedPayloadSize),\n            sessionDuration: Date.now() - this.userBehavior.sessionStart,\n            networkQualityDistribution: this.getNetworkQualityDistribution()\n        };\n    }\n    getNetworkQualityDistribution() {\n        const distribution = {\n            excellent: 0,\n            good: 0,\n            fair: 0,\n            poor: 0,\n            decent: 0\n        };\n        this.networkMetrics.forEach((metric)=>{\n            distribution[metric.connectionQuality]++;\n        });\n        return distribution;\n    }\n    // Real-time monitoring dashboard (console-based)\n    startRealtimeMonitoring() {\n        let intervalMs = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 5000;\n        setInterval(()=>{\n            const summary = this.generateSummary();\n            console.log('Session Duration:', \"\".concat(Math.round(summary.sessionDuration / 1000), \"s\"));\n            console.log('local storage', this.storage.getStorageInfo());\n            // console.log('Total Events:', summary.totalEvents);\n            // console.log('Average RTT:', `${summary.avgRTT}ms`);\n            // console.log('Success Rate:', `${summary.successRate}%`);\n            // console.log('Average FPS:', summary.avgFPS);\n            // console.log('Network Quality:', summary.networkQualityDistribution);\n            console.groupEnd();\n        }, intervalMs);\n    }\n    // Cleanup\n    destroy() {\n        if (this.syncTimer) {\n            clearInterval(this.syncTimer);\n        }\n        this.syncNow(); // Final sync\n    }\n    constructor(userId, intervalMs = 30000){\n        this.events = [];\n        this.networkMetrics = [];\n        this.performanceMetrics = [];\n        this.lastActivity = Date.now();\n        this.frameCount = 0;\n        this.lastFPSCheck = performance.now();\n        this.eventQueue = [];\n        this.sessionId = this.generateId();\n        this.userId = userId;\n        this.userBehavior = this.initializeUserBehavior();\n        this.storage = new _AnalyticsLocalStorageManager__WEBPACK_IMPORTED_MODULE_1__[\"default\"]();\n        this.startPerformanceMonitoring();\n        this.startPeriodicSync(intervalMs);\n        // Load existing data from localStorage\n        this.loadFromStorage();\n        // Sync on page unload\n        window.addEventListener('beforeunload', ()=>{\n            this.syncNow();\n        });\n    }\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (DrawingAnalytics);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy91dGlsL0RyYXdpbmdBbmFseXRpY3MudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFtQztBQUN1QztBQXVEMUUsTUFBTUU7SUErQkdDLGFBQXFCO1FBQzVCLE9BQU8sR0FBaUJDLE9BQWRDLEtBQUtDLEdBQUcsSUFBRyxLQUEyQyxPQUF4Q0YsS0FBS0csTUFBTSxHQUFHQyxRQUFRLENBQUMsSUFBSUMsTUFBTSxDQUFDLEdBQUc7SUFDOUQ7SUFFUUMsa0JBQXdCO1FBQy9CLHdEQUF3RDtRQUN4RCxNQUFNQyxtQkFBbUIsSUFBSSxDQUFDQyxPQUFPLENBQUNDLGVBQWU7UUFDckQsSUFBSUYsb0JBQW9CQSxpQkFBaUJHLFNBQVMsS0FBSyxJQUFJLENBQUNBLFNBQVMsRUFBRTtZQUN0RSxJQUFJLENBQUNDLFlBQVksR0FBR0o7UUFDckI7SUFDRDtJQUVRSyx5QkFBOEM7UUFDckQsT0FBTztZQUNORixXQUFXLElBQUksQ0FBQ0EsU0FBUztZQUN6QkcsUUFBUSxJQUFJLENBQUNBLE1BQU07WUFDbkJDLGNBQWNiLEtBQUtDLEdBQUc7WUFDdEJhLGNBQWM7WUFDZEMscUJBQXFCO1lBQ3JCQyxjQUFjO1lBQ2RDLGVBQWU7WUFDZkMsa0JBQWtCO1lBQ2xCQyxVQUFVO1lBQ1ZDLFdBQVc7WUFDWEMsV0FBVztZQUNYQyxrQkFBa0I7UUFDbkI7SUFDRDtJQUVRQyxrQkFBa0JDLFVBQWtCLEVBQVE7UUFDbkRDLFFBQVFDLEdBQUcsQ0FBQztRQUVaLElBQUksQ0FBQ0MsU0FBUyxHQUFHQyxZQUFZO1lBQzVCLE1BQU0sSUFBSSxDQUFDQyxPQUFPO1FBQ25CLEdBQUdMO0lBQ0o7SUFFQSxzQkFBc0I7SUFDdEIsTUFBTUssVUFBNEI7UUFDakNKLFFBQVFDLEdBQUcsQ0FBQztRQUVaLDZCQUE2QjtRQUM3QixJQUFJLENBQUNuQixPQUFPLENBQUN1QixZQUFZLENBQUMsSUFBSSxDQUFDckIsU0FBUztRQUV4Qyw4QkFBOEI7UUFDOUIsTUFBTXNC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TztRQUNiO0lBQ0Q7QUFxWEQ7QUFFQSxpRUFBZWhDLGdCQUFnQkEsRUFBQyIsInNvdXJjZXMiOlsiL1VzZXJzL2VtcmV5aWxkaXJpbS9EZXNrdG9wL2ZpbmFsUHJvamVjdC9jbGllbnQvc3JjL3V0aWwvRHJhd2luZ0FuYWx5dGljcy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgc2l6ZW9mIGZyb20gJ29iamVjdC1zaXplb2YnO1xuaW1wb3J0IEFuYWx5dGljc0xvY2FsU3RvcmFnZU1hbmFnZXIgZnJvbSAnLi9BbmFseXRpY3NMb2NhbFN0b3JhZ2VNYW5hZ2VyJztcbmludGVyZmFjZSBEcmF3aW5nRXZlbnQge1xuXHRldmVudElkOiBzdHJpbmc7XG5cdHRpbWVzdGFtcDogbnVtYmVyO1xuXHRldmVudFR5cGU6XG5cdFx0fCAnc3Ryb2tlX3N0YXJ0J1xuXHRcdHwgJ3N0cm9rZV9jb250aW51ZSdcblx0XHR8ICdzdHJva2VfZW5kJ1xuXHRcdHwgJ2NhbnZhc19jbGVhcidcblx0XHR8ICd1bmRvJ1xuXHRcdHwgJ3JlZG8nO1xuXHRzdHJva2VJZD86IHN0cmluZztcblx0Y29vcmRpbmF0ZXM/OiB7IHg6IG51bWJlcjsgeTogbnVtYmVyIH07XG5cdHByZXNzdXJlPzogbnVtYmVyO1xuXHR0b29sPzogc3RyaW5nO1xuXHRjb2xvcj86IHN0cmluZztcblx0YnJ1c2hTaXplPzogbnVtYmVyO1xuXHR1c2VySWQ/OiBzdHJpbmc7XG5cdHNlc3Npb25JZDogc3RyaW5nO1xufVxuXG5pbnRlcmZhY2UgTmV0d29ya01ldHJpY3Mge1xuXHRldmVudElkOiBzdHJpbmc7XG5cdHRpbWVzdGFtcDogbnVtYmVyO1xuXHRydHQ6IG51bWJlcjtcblx0YWNrbm93bGVkZ2VkOiBib29sZWFuO1xuXHRyZXRyeUNvdW50OiBudW1iZXI7XG5cdHBheWxvYWRTaXplOiBudW1iZXI7XG5cdGNvbm5lY3Rpb25RdWFsaXR5OiAnZXhjZWxsZW50JyB8ICdnb29kJyB8ICdmYWlyJyB8ICdkZWNlbnQnIHwgJ3Bvb3InO1xufVxuXG5pbnRlcmZhY2UgUGVyZm9ybWFuY2VNZXRyaWNzIHtcblx0dGltZXN0YW1wOiBudW1iZXI7XG5cdGZwczogbnVtYmVyO1xuXHRtZW1vcnlVc2FnZTogbnVtYmVyO1xuXHRjYW52YXNSZW5kZXJUaW1lOiBudW1iZXI7XG5cdGV2ZW50UHJvY2Vzc2luZ1RpbWU6IG51bWJlcjtcblx0cXVldWVkRXZlbnRzOiBudW1iZXI7XG59XG5cbmludGVyZmFjZSBVc2VyQmVoYXZpb3JNZXRyaWNzIHtcblx0c2Vzc2lvbklkOiBzdHJpbmc7XG5cdHVzZXJJZD86IHN0cmluZztcblx0c2Vzc2lvblN0YXJ0OiBudW1iZXI7XG5cdHRvdGFsU3Ryb2tlczogbnVtYmVyO1xuXHRhdmVyYWdlU3Ryb2tlTGVuZ3RoOiBudW1iZXI7XG5cdG1vc3RVc2VkVG9vbDogc3RyaW5nO1xuXHRtb3N0VXNlZENvbG9yOiBzdHJpbmc7XG5cdHRvdGFsRHJhd2luZ1RpbWU6IG51bWJlcjtcblx0aWRsZVRpbWU6IG51bWJlcjtcblx0dW5kb0NvdW50OiBudW1iZXI7XG5cdHJlZG9Db3VudDogbnVtYmVyO1xuXHRjYW52YXNDbGVhckNvdW50OiBudW1iZXI7XG59XG5cbmNsYXNzIERyYXdpbmdBbmFseXRpY3Mge1xuXHRwcml2YXRlIHNlc3Npb25JZDogc3RyaW5nO1xuXHRwcml2YXRlIHN0b3JhZ2U6IEFuYWx5dGljc0xvY2FsU3RvcmFnZU1hbmFnZXI7XG5cdHByaXZhdGUgdXNlcklkPzogc3RyaW5nO1xuXHRwcml2YXRlIGV2ZW50czogRHJhd2luZ0V2ZW50W10gPSBbXTtcblx0cHJpdmF0ZSBzeW5jVGltZXI6IE5vZGVKUy5UaW1lb3V0O1xuXHRwcml2YXRlIG5ldHdvcmtNZXRyaWNzOiBOZXR3b3JrTWV0cmljc1tdID0gW107XG5cdHByaXZhdGUgcGVyZm9ybWFuY2VNZXRyaWNzOiBQZXJmb3JtYW5jZU1ldHJpY3NbXSA9IFtdO1xuXHRwcml2YXRlIHVzZXJCZWhhdmlvcjogVXNlckJlaGF2aW9yTWV0cmljcztcblx0cHJpdmF0ZSBsYXN0QWN0aXZpdHk6IG51bWJlciA9IERhdGUubm93KCk7XG5cdHByaXZhdGUgY3VycmVudFN0cm9rZVN0YXJ0PzogbnVtYmVyO1xuXHRwcml2YXRlIGZyYW1lQ291bnQgPSAwO1xuXHRwcml2YXRlIGxhc3RGUFNDaGVjayA9IHBlcmZvcm1hbmNlLm5vdygpO1xuXHRwcml2YXRlIGV2ZW50UXVldWU6IGFueVtdID0gW107XG5cblx0Y29uc3RydWN0b3IodXNlcklkPzogc3RyaW5nLCBpbnRlcnZhbE1zOiBudW1iZXIgPSAzMDAwMCkge1xuXHRcdHRoaXMuc2Vzc2lvbklkID0gdGhpcy5nZW5lcmF0ZUlkKCk7XG5cdFx0dGhpcy51c2VySWQgPSB1c2VySWQ7XG5cdFx0dGhpcy51c2VyQmVoYXZpb3IgPSB0aGlzLmluaXRpYWxpemVVc2VyQmVoYXZpb3IoKTtcblx0XHR0aGlzLnN0b3JhZ2UgPSBuZXcgQW5hbHl0aWNzTG9jYWxTdG9yYWdlTWFuYWdlcigpO1xuXHRcdHRoaXMuc3RhcnRQZXJmb3JtYW5jZU1vbml0b3JpbmcoKTtcblx0XHR0aGlzLnN0YXJ0UGVyaW9kaWNTeW5jKGludGVydmFsTXMpO1xuXHRcdC8vIExvYWQgZXhpc3RpbmcgZGF0YSBmcm9tIGxvY2FsU3RvcmFnZVxuXHRcdHRoaXMubG9hZEZyb21TdG9yYWdlKCk7XG5cblx0XHQvLyBTeW5jIG9uIHBhZ2UgdW5sb2FkXG5cdFx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2JlZm9yZXVubG9hZCcsICgpID0+IHtcblx0XHRcdHRoaXMuc3luY05vdygpO1xuXHRcdH0pO1xuXHR9XG5cblx0cHJpdmF0ZSBnZW5lcmF0ZUlkKCk6IHN0cmluZyB7XG5cdFx0cmV0dXJuIGAke0RhdGUubm93KCl9LSR7TWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyKDIsIDkpfWA7XG5cdH1cblxuXHRwcml2YXRlIGxvYWRGcm9tU3RvcmFnZSgpOiB2b2lkIHtcblx0XHQvLyBMb2FkIGV4aXN0aW5nIGRhdGEgaWYgYW55ICh1c2VmdWwgZm9yIHBhZ2UgcmVmcmVzaGVzKVxuXHRcdGNvbnN0IGV4aXN0aW5nQmVoYXZpb3IgPSB0aGlzLnN0b3JhZ2UuZ2V0VXNlckJlaGF2aW9yKCk7XG5cdFx0aWYgKGV4aXN0aW5nQmVoYXZpb3IgJiYgZXhpc3RpbmdCZWhhdmlvci5zZXNzaW9uSWQgPT09IHRoaXMuc2Vzc2lvbklkKSB7XG5cdFx0XHR0aGlzLnVzZXJCZWhhdmlvciA9IGV4aXN0aW5nQmVoYXZpb3I7XG5cdFx0fVxuXHR9XG5cblx0cHJpdmF0ZSBpbml0aWFsaXplVXNlckJlaGF2aW9yKCk6IFVzZXJCZWhhdmlvck1ldHJpY3Mge1xuXHRcdHJldHVybiB7XG5cdFx0XHRzZXNzaW9uSWQ6IHRoaXMuc2Vzc2lvbklkLFxuXHRcdFx0dXNlcklkOiB0aGlzLnVzZXJJZCxcblx0XHRcdHNlc3Npb25TdGFydDogRGF0ZS5ub3coKSxcblx0XHRcdHRvdGFsU3Ryb2tlczogMCxcblx0XHRcdGF2ZXJhZ2VTdHJva2VMZW5ndGg6IDAsXG5cdFx0XHRtb3N0VXNlZFRvb2w6ICcnLFxuXHRcdFx0bW9zdFVzZWRDb2xvcjogJycsXG5cdFx0XHR0b3RhbERyYXdpbmdUaW1lOiAwLFxuXHRcdFx0aWRsZVRpbWU6IDAsXG5cdFx0XHR1bmRvQ291bnQ6IDAsXG5cdFx0XHRyZWRvQ291bnQ6IDAsXG5cdFx0XHRjYW52YXNDbGVhckNvdW50OiAwLFxuXHRcdH07XG5cdH1cblxuXHRwcml2YXRlIHN0YXJ0UGVyaW9kaWNTeW5jKGludGVydmFsTXM6IG51bWJlcik6IHZvaWQge1xuXHRcdGNvbnNvbGUubG9nKCdzdGFydFBlcmlvZGljU3luYycpO1xuXG5cdFx0dGhpcy5zeW5jVGltZXIgPSBzZXRJbnRlcnZhbChhc3luYyAoKSA9PiB7XG5cdFx0XHRhd2FpdCB0aGlzLnN5bmNOb3coKTtcblx0XHR9LCBpbnRlcnZhbE1zKTtcblx0fVxuXG5cdC8vIE1hbnVhbCBzeW5jIHRyaWdnZXJcblx0YXN5bmMgc3luY05vdygpOiBQcm9taXNlPGJvb2xlYW4+IHtcblx0XHRjb25zb2xlLmxvZygnU3RhcnRpbmcgYW5hbHl0aWNzIHN5bmMuLi4nKTtcblxuXHRcdC8vIFF1ZXVlIGN1cnJlbnQgc2Vzc2lvbiBkYXRhXG5cdFx0dGhpcy5zdG9yYWdlLnF1ZXVlRm9yU3luYyh0aGlzLnNlc3Npb25JZCk7XG5cblx0XHQvLyBUcnkgdG8gc3luYyBhbGwgcXVldWVkIGRhdGFcblx0XHRjb25zdCBzeW5jUXVldWUgPSB0aGlzLnN0b3JhZ2UuZ2V0U3luY1F1ZXVlKCk7XG5cdFx0bGV0IHN5bmNlZENvdW50ID0gMDtcblxuXHRcdC8vIHRvZG8gc2VuZCB0byB0aGUgYmFja2VuZFxuXHRcdC8vIGZvciAoY29uc3QgcGF5bG9hZCBvZiBzeW5jUXVldWUpIHtcblx0XHQvLyBpZiAoc3VjY2Vzcykge1xuXHRcdC8vIFx0dGhpcy5zdG9yYWdlLmNsZWFyU3luY2VkRGF0YShwYXlsb2FkLnRpbWVzdGFtcCk7XG5cdFx0Ly8gXHRzeW5jZWRDb3VudCsrO1xuXHRcdC8vIH0gZWxzZSB7XG5cdFx0Ly8gXHRicmVhazsgLy8gU3RvcCBvbiBmaXJzdCBmYWlsdXJlIHRvIG1haW50YWluIG9yZGVyXG5cdFx0Ly8gfVxuXHRcdC8vIH1cblxuXHRcdGlmIChzeW5jZWRDb3VudCA+IDApIHtcblx0XHRcdGNvbnNvbGUubG9nKGBTeW5jZWQgJHtzeW5jZWRDb3VudH0gYW5hbHl0aWNzIHBheWxvYWRzYCk7XG5cdFx0XHQvLyBDbGVhciBsb2NhbCBkYXRhIGFmdGVyIHN1Y2Nlc3NmdWwgc3luY1xuXHRcdFx0dGhpcy5zdG9yYWdlLmNsZWFyTG9jYWxEYXRhKCk7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHQvLyBFbmhhbmNlZCBkcmF3aW5nIGV2ZW50IGxvZ2dpbmcgd2l0aCBjb21wcmVoZW5zaXZlIGRhdGFcblx0bG9nRHJhd2luZ0V2ZW50KFxuXHRcdGV2ZW50VHlwZTogRHJhd2luZ0V2ZW50WydldmVudFR5cGUnXSxcblx0XHRkYXRhOiB7XG5cdFx0XHRjb29yZGluYXRlcz86IHsgeDogbnVtYmVyOyB5OiBudW1iZXIgfTtcblx0XHRcdHByZXNzdXJlPzogbnVtYmVyO1xuXHRcdFx0dG9vbD86IHN0cmluZztcblx0XHRcdGNvbG9yPzogc3RyaW5nO1xuXHRcdFx0YnJ1c2hTaXplPzogbnVtYmVyO1xuXHRcdFx0c3Ryb2tlSWQ/OiBzdHJpbmc7XG5cdFx0fSA9IHt9XG5cdCk6IHN0cmluZyB7XG5cdFx0Y29uc3QgZXZlbnRJZCA9IHRoaXMuZ2VuZXJhdGVJZCgpO1xuXHRcdGNvbnN0IHRpbWVzdGFtcCA9IERhdGUubm93KCk7XG5cblx0XHRjb25zdCBldmVudDogRHJhd2luZ0V2ZW50ID0ge1xuXHRcdFx0ZXZlbnRJZCxcblx0XHRcdHRpbWVzdGFtcCxcblx0XHRcdGV2ZW50VHlwZSxcblx0XHRcdHNlc3Npb25JZDogdGhpcy5zZXNzaW9uSWQsXG5cdFx0XHR1c2VySWQ6IHRoaXMudXNlcklkLFxuXHRcdFx0Li4uZGF0YSxcblx0XHR9O1xuXG5cdFx0dGhpcy5ldmVudHMucHVzaChldmVudCk7XG5cdFx0dGhpcy51cGRhdGVVc2VyQmVoYXZpb3IoZXZlbnQpO1xuXHRcdHRoaXMubGFzdEFjdGl2aXR5ID0gdGltZXN0YW1wO1xuXG5cdFx0Ly8gTG9nIHRvIGNvbnNvbGUgd2l0aCBzdHJ1Y3R1cmVkIGZvcm1hdFxuXHRcdC8vIGNvbnNvbGUuZ3JvdXAoYERyYXdpbmcgRXZlbnQ6ICR7ZXZlbnRUeXBlfWApO1xuXHRcdC8vIGNvbnNvbGUubG9nKCdFdmVudCBJRDonLCBldmVudElkKTtcblx0XHQvLyBjb25zb2xlLmxvZygnVGltZXN0YW1wOicsIG5ldyBEYXRlKHRpbWVzdGFtcCkudG9JU09TdHJpbmcoKSk7XG5cdFx0Ly8gY29uc29sZS5sb2coJ0RhdGE6JywgZGF0YSk7XG5cdFx0Y29uc29sZS5ncm91cEVuZCgpO1xuXHRcdHRoaXMuc3RvcmFnZS5hcHBlbmREYXRhKHRoaXMuc3RvcmFnZS5TVE9SQUdFX0tFWVMuRVZFTlRTLCBldmVudCk7XG5cblx0XHRyZXR1cm4gZXZlbnRJZDtcblx0fVxuXG5cdC8vIEVuaGFuY2VkIG5ldHdvcmsgbG9nZ2luZyB3aXRoIHF1YWxpdHkgYXNzZXNzbWVudFxuXHRsb2dOZXR3b3JrRXZlbnQoXG5cdFx0ZXZlbnRJZDogc3RyaW5nLFxuXHRcdHN0YXJ0VGltZTogbnVtYmVyLFxuXHRcdGFja25vd2xlZGdlZDogYm9vbGVhbixcblx0XHRwYXlsb2FkU2l6ZTogbnVtYmVyLFxuXHRcdHJldHJ5Q291bnQ6IG51bWJlciA9IDBcblx0KTogdm9pZCB7XG5cdFx0Y29uc3QgcnR0ID0gcGVyZm9ybWFuY2Uubm93KCkgLSBzdGFydFRpbWU7XG5cdFx0Y29uc3QgY29ubmVjdGlvblF1YWxpdHkgPSB0aGlzLmFzc2Vzc0Nvbm5lY3Rpb25RdWFsaXR5KHJ0dCk7XG5cblx0XHRjb25zdCBuZXR3b3JrTWV0cmljOiBOZXR3b3JrTWV0cmljcyA9IHtcblx0XHRcdGV2ZW50SWQsXG5cdFx0XHR0aW1lc3RhbXA6IERhdGUubm93KCksXG5cdFx0XHRydHQsXG5cdFx0XHRhY2tub3dsZWRnZWQsXG5cdFx0XHRyZXRyeUNvdW50LFxuXHRcdFx0cGF5bG9hZFNpemUsXG5cdFx0XHRjb25uZWN0aW9uUXVhbGl0eSxcblx0XHR9O1xuXG5cdFx0dGhpcy5uZXR3b3JrTWV0cmljcy5wdXNoKG5ldHdvcmtNZXRyaWMpO1xuXG5cdFx0Ly8gY29uc29sZS5ncm91cChgTmV0d29yayBFdmVudGApO1xuXHRcdC8vIGNvbnNvbGUubG9nKCdFdmVudCBJRDonLCBldmVudElkKTtcblx0XHQvLyBjb25zb2xlLmxvZygnUlRUOicsIGAke3J0dC50b0ZpeGVkKDIpfW1zYCk7XG5cdFx0Ly8gY29uc29sZS5sb2coJ1F1YWxpdHk6JywgY29ubmVjdGlvblF1YWxpdHkpO1xuXHRcdC8vIGNvbnNvbGUubG9nKCdQYXlsb2FkIFNpemU6JywgYCR7cGF5bG9hZFNpemV9IGJ5dGVzYCk7XG5cdFx0Ly8gY29uc29sZS5sb2coJ0Fja25vd2xlZGdlZDonLCBhY2tub3dsZWRnZWQpO1xuXHRcdHRoaXMuc3RvcmFnZS5hcHBlbmREYXRhKHRoaXMuc3RvcmFnZS5TVE9SQUdFX0tFWVMuTkVUV09SSywgbmV0d29ya01ldHJpYyk7XG5cdFx0aWYgKHJldHJ5Q291bnQgPiAwKSBjb25zb2xlLndhcm4oJ1JldHJ5IENvdW50OicsIHJldHJ5Q291bnQpO1xuXHRcdGNvbnNvbGUuZ3JvdXBFbmQoKTtcblx0fVxuXG5cdHByaXZhdGUgYXNzZXNzQ29ubmVjdGlvblF1YWxpdHkoXG5cdFx0cnR0OiBudW1iZXJcblx0KTogTmV0d29ya01ldHJpY3NbJ2Nvbm5lY3Rpb25RdWFsaXR5J10ge1xuXHRcdGlmIChydHQgPCA1MCkgcmV0dXJuICdleGNlbGxlbnQnO1xuXHRcdGlmIChydHQgPCAxMDApIHJldHVybiAnZ29vZCc7XG5cdFx0aWYgKHJ0dCA8IDIwMCkgcmV0dXJuICdmYWlyJztcblx0XHRpZiAocnR0IDwgNTAwKSByZXR1cm4gJ2RlY2VudCc7XG5cdFx0cmV0dXJuICdwb29yJztcblx0fVxuXG5cdC8vIFBlcmZvcm1hbmNlIG1vbml0b3Jpbmdcblx0cHJpdmF0ZSBzdGFydFBlcmZvcm1hbmNlTW9uaXRvcmluZygpOiB2b2lkIHtcblx0XHRpZiAoXG5cdFx0XHR0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyB8fFxuXHRcdFx0dHlwZW9mIHJlcXVlc3RBbmltYXRpb25GcmFtZSA9PT0gJ3VuZGVmaW5lZCdcblx0XHQpIHtcblx0XHRcdGNvbnNvbGUud2FybignUGVyZm9ybWFuY2UgbW9uaXRvcmluZyBub3QgYXZhaWxhYmxlIGluIHRoaXMgZW52aXJvbm1lbnQnKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0Y29uc3QgbW9uaXRvciA9ICgpID0+IHtcblx0XHRcdGNvbnN0IG5vdyA9IHBlcmZvcm1hbmNlLm5vdygpO1xuXHRcdFx0Y29uc3QgZGVsdGFUaW1lID0gbm93IC0gdGhpcy5sYXN0RlBTQ2hlY2s7XG5cblx0XHRcdGlmIChkZWx0YVRpbWUgPj0gMTAwMCkge1xuXHRcdFx0XHQvLyBpZiBpdHMgYmVlbiBhIHNlY29uZFxuXHRcdFx0XHRjb25zdCBmcHMgPSAodGhpcy5mcmFtZUNvdW50ICogMTAwMCkgLyBkZWx0YVRpbWU7XG5cdFx0XHRcdGNvbnN0IG1lbW9yeVVzYWdlID0gKHBlcmZvcm1hbmNlIGFzIGFueSkubWVtb3J5Py51c2VkSlNIZWFwU2l6ZSB8fCAwO1xuXG5cdFx0XHRcdGNvbnN0IHBlcmZNZXRyaWM6IFBlcmZvcm1hbmNlTWV0cmljcyA9IHtcblx0XHRcdFx0XHR0aW1lc3RhbXA6IERhdGUubm93KCksXG5cdFx0XHRcdFx0ZnBzOiBNYXRoLnJvdW5kKGZwcyksXG5cdFx0XHRcdFx0bWVtb3J5VXNhZ2UsXG5cdFx0XHRcdFx0Y2FudmFzUmVuZGVyVGltZTogMCwgLy8gWW91J2xsIG5lZWQgdG8gbWVhc3VyZSB0aGlzIGluIHlvdXIgcmVuZGVyIGxvb3Bcblx0XHRcdFx0XHRldmVudFByb2Nlc3NpbmdUaW1lOiAwLCAvLyBNZWFzdXJlIGluIHlvdXIgZXZlbnQgaGFuZGxlcnNcblx0XHRcdFx0XHRxdWV1ZWRFdmVudHM6IHRoaXMuZXZlbnRRdWV1ZS5sZW5ndGgsXG5cdFx0XHRcdH07XG5cblx0XHRcdFx0dGhpcy5wZXJmb3JtYW5jZU1ldHJpY3MucHVzaChwZXJmTWV0cmljKTtcblx0XHRcdFx0dGhpcy5mcmFtZUNvdW50ID0gMDtcblx0XHRcdFx0dGhpcy5sYXN0RlBTQ2hlY2sgPSBub3c7XG5cdFx0XHRcdHRoaXMuc3RvcmFnZS5hcHBlbmREYXRhKFxuXHRcdFx0XHRcdHRoaXMuc3RvcmFnZS5TVE9SQUdFX0tFWVMuUEVSRk9STUFOQ0UsXG5cdFx0XHRcdFx0dGhpcy5wZXJmb3JtYW5jZU1ldHJpY3Ncblx0XHRcdFx0KTtcblxuXHRcdFx0XHQvLyBMb2cgcGVyZm9ybWFuY2Ugd2FybmluZ3Ncblx0XHRcdFx0aWYgKGZwcyA8IDMwKSB7XG5cdFx0XHRcdFx0Y29uc29sZS53YXJuKGBMb3cgRlBTIGRldGVjdGVkOiAke2Zwcy50b0ZpeGVkKDEpfWApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICh0aGlzLmV2ZW50UXVldWUubGVuZ3RoID4gMTApIHtcblx0XHRcdFx0XHRjb25zb2xlLndhcm4oYEV2ZW50IHF1ZXVlIGJhY2tsb2c6ICR7dGhpcy5ldmVudFF1ZXVlLmxlbmd0aH0gZXZlbnRzYCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0dGhpcy5mcmFtZUNvdW50Kys7XG5cdFx0XHRyZXF1ZXN0QW5pbWF0aW9uRnJhbWUobW9uaXRvcik7XG5cdFx0fTtcblxuXHRcdHJlcXVlc3RBbmltYXRpb25GcmFtZShtb25pdG9yKTtcblx0fVxuXG5cdC8vIFVwZGF0ZSB1c2VyIGJlaGF2aW9yIG1ldHJpY3Ncblx0cHJpdmF0ZSB1cGRhdGVVc2VyQmVoYXZpb3IoZXZlbnQ6IERyYXdpbmdFdmVudCk6IHZvaWQge1xuXHRcdHN3aXRjaCAoZXZlbnQuZXZlbnRUeXBlKSB7XG5cdFx0XHRjYXNlICdzdHJva2Vfc3RhcnQnOlxuXHRcdFx0XHR0aGlzLnVzZXJCZWhhdmlvci50b3RhbFN0cm9rZXMrKztcblx0XHRcdFx0dGhpcy5jdXJyZW50U3Ryb2tlU3RhcnQgPSBldmVudC50aW1lc3RhbXA7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAnc3Ryb2tlX2VuZCc6XG5cdFx0XHRcdGlmICh0aGlzLmN1cnJlbnRTdHJva2VTdGFydCkge1xuXHRcdFx0XHRcdGNvbnN0IHN0cm9rZUR1cmF0aW9uID0gZXZlbnQudGltZXN0YW1wIC0gdGhpcy5jdXJyZW50U3Ryb2tlU3RhcnQ7XG5cdFx0XHRcdFx0dGhpcy51c2VyQmVoYXZpb3IudG90YWxEcmF3aW5nVGltZSArPSBzdHJva2VEdXJhdGlvbjtcblx0XHRcdFx0fVxuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgJ3VuZG8nOlxuXHRcdFx0XHR0aGlzLnVzZXJCZWhhdmlvci51bmRvQ291bnQrKztcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICdyZWRvJzpcblx0XHRcdFx0dGhpcy51c2VyQmVoYXZpb3IucmVkb0NvdW50Kys7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAnY2FudmFzX2NsZWFyJzpcblx0XHRcdFx0dGhpcy51c2VyQmVoYXZpb3IuY2FudmFzQ2xlYXJDb3VudCsrO1xuXHRcdFx0XHRicmVhaztcblx0XHR9XG5cdH1cblxuXHQvLyBFbmhhbmNlZCBzb2NrZXQgZW1pc3Npb24gd2l0aCBjb21wcmVoZW5zaXZlIGxvZ2dpbmdcblx0ZW1pdFdpdGhMb2dnaW5nKFxuXHRcdHNvY2tldDogYW55LFxuXHRcdGV2ZW50TmFtZTogc3RyaW5nLFxuXHRcdGRhdGE6IGFueSxcblx0XHRvcHRpb25zOiB7XG5cdFx0XHR0aW1lb3V0PzogbnVtYmVyO1xuXHRcdFx0cmV0cnlDb3VudD86IG51bWJlcjtcblx0XHRcdHByaW9yaXR5PzogJ2hpZ2gnIHwgJ25vcm1hbCcgfCAnbG93Jztcblx0XHR9ID0ge31cblx0KTogUHJvbWlzZTxib29sZWFuPiB7XG5cdFx0cmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG5cdFx0XHRjb25zdCBzdGFydFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcblx0XHRcdGNvbnN0IGV2ZW50SWQgPSB0aGlzLmxvZ0RyYXdpbmdFdmVudCgnc3Ryb2tlX2NvbnRpbnVlJywgZGF0YSk7XG5cdFx0XHRjb25zdCBwYXlsb2FkU2l6ZSA9IHNpemVvZihkYXRhKTtcblx0XHRcdGxldCByZXRyeUNvdW50ID0gMDtcblx0XHRcdGNvbnN0IG1heFJldHJpZXMgPSBvcHRpb25zLnJldHJ5Q291bnQgfHwgMztcblxuXHRcdFx0Y29uc3QgYXR0ZW1wdCA9ICgpID0+IHtcblx0XHRcdFx0c29ja2V0LmVtaXQoZXZlbnROYW1lLCBkYXRhLCAoYWNrOiBib29sZWFuKSA9PiB7XG5cdFx0XHRcdFx0dGhpcy5sb2dOZXR3b3JrRXZlbnQoXG5cdFx0XHRcdFx0XHRldmVudElkLFxuXHRcdFx0XHRcdFx0c3RhcnRUaW1lLFxuXHRcdFx0XHRcdFx0YWNrLFxuXHRcdFx0XHRcdFx0cGF5bG9hZFNpemUsXG5cdFx0XHRcdFx0XHRyZXRyeUNvdW50XG5cdFx0XHRcdFx0KTtcblxuXHRcdFx0XHRcdGlmIChhY2spIHtcblx0XHRcdFx0XHRcdHJlc29sdmUodHJ1ZSk7XG5cdFx0XHRcdFx0fSBlbHNlIGlmIChyZXRyeUNvdW50IDwgbWF4UmV0cmllcykge1xuXHRcdFx0XHRcdFx0cmV0cnlDb3VudCsrO1xuXHRcdFx0XHRcdFx0Y29uc29sZS53YXJuKFxuXHRcdFx0XHRcdFx0XHRgUmV0cnlpbmcgZXZlbnQgJHtldmVudElkfSAoYXR0ZW1wdCAke3JldHJ5Q291bnR9LyR7bWF4UmV0cmllc30pYFxuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdHNldFRpbWVvdXQoYXR0ZW1wdCwgMTAwICogcmV0cnlDb3VudCk7IC8vIEV4cG9uZW50aWFsIGJhY2tvZmZcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Y29uc29sZS5lcnJvcihcblx0XHRcdFx0XHRcdFx0YEV2ZW50ICR7ZXZlbnRJZH0gZmFpbGVkIGFmdGVyICR7bWF4UmV0cmllc30gcmV0cmllc2Bcblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRyZXNvbHZlKGZhbHNlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdFx0fTtcblxuXHRcdFx0YXR0ZW1wdCgpO1xuXHRcdH0pO1xuXHR9XG5cblx0Ly8gRGF0YSBleHBvcnQgYW5kIGFuYWx5c2lzIG1ldGhvZHNcblx0ZXhwb3J0QW5hbHl0aWNzKCk6IHtcblx0XHRzZXNzaW9uOiBVc2VyQmVoYXZpb3JNZXRyaWNzO1xuXHRcdGV2ZW50czogRHJhd2luZ0V2ZW50W107XG5cdFx0bmV0d29yazogTmV0d29ya01ldHJpY3NbXTtcblx0XHRwZXJmb3JtYW5jZTogUGVyZm9ybWFuY2VNZXRyaWNzW107XG5cdFx0c3VtbWFyeTogYW55O1xuXHR9IHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0c2Vzc2lvbjogdGhpcy51c2VyQmVoYXZpb3IsXG5cdFx0XHRldmVudHM6IHRoaXMuZXZlbnRzLFxuXHRcdFx0bmV0d29yazogdGhpcy5uZXR3b3JrTWV0cmljcyxcblx0XHRcdHBlcmZvcm1hbmNlOiB0aGlzLnBlcmZvcm1hbmNlTWV0cmljcyxcblx0XHRcdHN1bW1hcnk6IHRoaXMuZ2VuZXJhdGVTdW1tYXJ5KCksXG5cdFx0fTtcblx0fVxuXG5cdHByaXZhdGUgZ2VuZXJhdGVTdW1tYXJ5KCkge1xuXHRcdGNvbnN0IHRvdGFsRXZlbnRzID0gdGhpcy5ldmVudHMubGVuZ3RoO1xuXHRcdGNvbnN0IGF2Z1JUVCA9XG5cdFx0XHR0aGlzLm5ldHdvcmtNZXRyaWNzLnJlZHVjZSgoc3VtLCBtKSA9PiBzdW0gKyBtLnJ0dCwgMCkgL1xuXHRcdFx0XHR0aGlzLm5ldHdvcmtNZXRyaWNzLmxlbmd0aCB8fCAwO1xuXHRcdGNvbnN0IGFja25vd2xlZGdlZE1lc3NhZ2VzID0gdGhpcy5uZXR3b3JrTWV0cmljcy5maWx0ZXIoXG5cdFx0XHQobSkgPT4gbS5hY2tub3dsZWRnZWRcblx0XHQpO1xuXHRcdGNvbnN0IG5hY2tNZXNzYWdlcyA9IHRoaXMubmV0d29ya01ldHJpY3MuZmlsdGVyKChtKSA9PiAhbS5hY2tub3dsZWRnZWQpO1xuXHRcdGNvbnN0IGZhaWxlZERhdGFTZW5kID0gbmFja01lc3NhZ2VzLnJlZHVjZShcblx0XHRcdChzdW06IG51bWJlciwgaTogTmV0d29ya01ldHJpY3MpID0+IHN1bSArIGkucGF5bG9hZFNpemUsXG5cdFx0XHQwXG5cdFx0KTtcblxuXHRcdGNvbnN0IHN1Y2Nlc3NSYXRlID1cblx0XHRcdChhY2tub3dsZWRnZWRNZXNzYWdlcy5sZW5ndGggLyB0aGlzLm5ldHdvcmtNZXRyaWNzLmxlbmd0aCkgKiAxMDAgfHwgMDtcblx0XHRjb25zdCB0b3RhbERhdGFTZW5kID0gYWNrbm93bGVkZ2VkTWVzc2FnZXMucmVkdWNlKFxuXHRcdFx0KHN1bTogbnVtYmVyLCBpOiBOZXR3b3JrTWV0cmljcykgPT4gc3VtICsgaS5wYXlsb2FkU2l6ZSxcblx0XHRcdDBcblx0XHQpO1xuXHRcdGNvbnN0IHRvdGFsRGF0YUF0dGVtcHRlZCA9IHRvdGFsRGF0YVNlbmQgKyBmYWlsZWREYXRhU2VuZDtcblx0XHRjb25zdCBkYXRhRWZmaWNpZW5jeVJhdGUgPSAodG90YWxEYXRhU2VuZCAvIHRvdGFsRGF0YUF0dGVtcHRlZCkgKiAxMDA7XG5cdFx0Y29uc3QgYXZnU3VjY2Vzc2Z1bFBheWxvYWRTaXplID1cblx0XHRcdHRvdGFsRGF0YVNlbmQgLyBhY2tub3dsZWRnZWRNZXNzYWdlcy5sZW5ndGg7XG5cdFx0Y29uc3QgYXZnRmFpbGVkUGF5bG9hZFNpemUgPSBmYWlsZWREYXRhU2VuZCAvIG5hY2tNZXNzYWdlcy5sZW5ndGg7XG5cblx0XHRjb25zdCBhdmdGUFMgPVxuXHRcdFx0dGhpcy5wZXJmb3JtYW5jZU1ldHJpY3MucmVkdWNlKChzdW0sIG0pID0+IHN1bSArIG0uZnBzLCAwKSAvXG5cdFx0XHRcdHRoaXMucGVyZm9ybWFuY2VNZXRyaWNzLmxlbmd0aCB8fCAwO1xuXG5cdFx0cmV0dXJuIHtcblx0XHRcdHRvdGFsRXZlbnRzLFxuXHRcdFx0YXZnUlRUOiBNYXRoLnJvdW5kKGF2Z1JUVCAqIDEwMCkgLyAxMDAsXG5cdFx0XHRzdWNjZXNzUmF0ZTogTWF0aC5yb3VuZChzdWNjZXNzUmF0ZSAqIDEwMCkgLyAxMDAsXG5cdFx0XHRhdmdGUFM6IE1hdGgucm91bmQoYXZnRlBTKSxcblx0XHRcdHRvdGFsRGF0YVNlbmQ6IE1hdGgucm91bmQodG90YWxEYXRhU2VuZCksXG5cdFx0XHRkYXRhRWZmaWNpZW5jeVJhdGU6IE1hdGgucm91bmQoZGF0YUVmZmljaWVuY3lSYXRlKSxcblx0XHRcdGF2Z1N1Y2Nlc3NmdWxQYXlsb2FkU2l6ZTogTWF0aC5yb3VuZChhdmdTdWNjZXNzZnVsUGF5bG9hZFNpemUpLFxuXHRcdFx0YXZnRmFpbGVkUGF5bG9hZFNpemU6IE1hdGgucm91bmQoYXZnRmFpbGVkUGF5bG9hZFNpemUpLFxuXHRcdFx0c2Vzc2lvbkR1cmF0aW9uOiBEYXRlLm5vdygpIC0gdGhpcy51c2VyQmVoYXZpb3Iuc2Vzc2lvblN0YXJ0LFxuXHRcdFx0bmV0d29ya1F1YWxpdHlEaXN0cmlidXRpb246IHRoaXMuZ2V0TmV0d29ya1F1YWxpdHlEaXN0cmlidXRpb24oKSxcblx0XHR9O1xuXHR9XG5cblx0cHJpdmF0ZSBnZXROZXR3b3JrUXVhbGl0eURpc3RyaWJ1dGlvbigpIHtcblx0XHRjb25zdCBkaXN0cmlidXRpb24gPSB7IGV4Y2VsbGVudDogMCwgZ29vZDogMCwgZmFpcjogMCwgcG9vcjogMCwgZGVjZW50OiAwIH07XG5cdFx0dGhpcy5uZXR3b3JrTWV0cmljcy5mb3JFYWNoKChtZXRyaWMpID0+IHtcblx0XHRcdGRpc3RyaWJ1dGlvblttZXRyaWMuY29ubmVjdGlvblF1YWxpdHldKys7XG5cdFx0fSk7XG5cdFx0cmV0dXJuIGRpc3RyaWJ1dGlvbjtcblx0fVxuXG5cdC8vIFJlYWwtdGltZSBtb25pdG9yaW5nIGRhc2hib2FyZCAoY29uc29sZS1iYXNlZClcblx0c3RhcnRSZWFsdGltZU1vbml0b3JpbmcoaW50ZXJ2YWxNczogbnVtYmVyID0gNTAwMCk6IHZvaWQge1xuXHRcdHNldEludGVydmFsKCgpID0+IHtcblx0XHRcdGNvbnN0IHN1bW1hcnkgPSB0aGlzLmdlbmVyYXRlU3VtbWFyeSgpO1xuXHRcdFx0Y29uc29sZS5sb2coXG5cdFx0XHRcdCdTZXNzaW9uIER1cmF0aW9uOicsXG5cdFx0XHRcdGAke01hdGgucm91bmQoc3VtbWFyeS5zZXNzaW9uRHVyYXRpb24gLyAxMDAwKX1zYFxuXHRcdFx0KTtcblx0XHRcdGNvbnNvbGUubG9nKCdsb2NhbCBzdG9yYWdlJywgdGhpcy5zdG9yYWdlLmdldFN0b3JhZ2VJbmZvKCkpO1xuXG5cdFx0XHQvLyBjb25zb2xlLmxvZygnVG90YWwgRXZlbnRzOicsIHN1bW1hcnkudG90YWxFdmVudHMpO1xuXHRcdFx0Ly8gY29uc29sZS5sb2coJ0F2ZXJhZ2UgUlRUOicsIGAke3N1bW1hcnkuYXZnUlRUfW1zYCk7XG5cdFx0XHQvLyBjb25zb2xlLmxvZygnU3VjY2VzcyBSYXRlOicsIGAke3N1bW1hcnkuc3VjY2Vzc1JhdGV9JWApO1xuXHRcdFx0Ly8gY29uc29sZS5sb2coJ0F2ZXJhZ2UgRlBTOicsIHN1bW1hcnkuYXZnRlBTKTtcblx0XHRcdC8vIGNvbnNvbGUubG9nKCdOZXR3b3JrIFF1YWxpdHk6Jywgc3VtbWFyeS5uZXR3b3JrUXVhbGl0eURpc3RyaWJ1dGlvbik7XG5cblx0XHRcdGNvbnNvbGUuZ3JvdXBFbmQoKTtcblx0XHR9LCBpbnRlcnZhbE1zKTtcblx0fVxuXHQvLyBDbGVhbnVwXG5cdGRlc3Ryb3koKTogdm9pZCB7XG5cdFx0aWYgKHRoaXMuc3luY1RpbWVyKSB7XG5cdFx0XHRjbGVhckludGVydmFsKHRoaXMuc3luY1RpbWVyKTtcblx0XHR9XG5cdFx0dGhpcy5zeW5jTm93KCk7IC8vIEZpbmFsIHN5bmNcblx0fVxufVxuXG5leHBvcnQgZGVmYXVsdCBEcmF3aW5nQW5hbHl0aWNzO1xuIl0sIm5hbWVzIjpbInNpemVvZiIsIkFuYWx5dGljc0xvY2FsU3RvcmFnZU1hbmFnZXIiLCJEcmF3aW5nQW5hbHl0aWNzIiwiZ2VuZXJhdGVJZCIsIk1hdGgiLCJEYXRlIiwibm93IiwicmFuZG9tIiwidG9TdHJpbmciLCJzdWJzdHIiLCJsb2FkRnJvbVN0b3JhZ2UiLCJleGlzdGluZ0JlaGF2aW9yIiwic3RvcmFnZSIsImdldFVzZXJCZWhhdmlvciIsInNlc3Npb25JZCIsInVzZXJCZWhhdmlvciIsImluaXRpYWxpemVVc2VyQmVoYXZpb3IiLCJ1c2VySWQiLCJzZXNzaW9uU3RhcnQiLCJ0b3RhbFN0cm9rZXMiLCJhdmVyYWdlU3Ryb2tlTGVuZ3RoIiwibW9zdFVzZWRUb29sIiwibW9zdFVzZWRDb2xvciIsInRvdGFsRHJhd2luZ1RpbWUiLCJpZGxlVGltZSIsInVuZG9Db3VudCIsInJlZG9Db3VudCIsImNhbnZhc0NsZWFyQ291bnQiLCJzdGFydFBlcmlvZGljU3luYyIsImludGVydmFsTXMiLCJjb25zb2xlIiwibG9nIiwic3luY1RpbWVyIiwic2V0SW50ZXJ2YWwiLCJzeW5jTm93IiwicXVldWVGb3JTeW5jIiwic3luY1F1ZXVlIiwiZ2V0U3luY1F1ZXVlIiwic3luY2VkQ291bnQiLCJjbGVhckxvY2FsRGF0YSIsImxvZ0RyYXdpbmdFdmVudCIsImV2ZW50VHlwZSIsImRhdGEiLCJldmVudElkIiwidGltZXN0YW1wIiwiZXZlbnQiLCJldmVudHMiLCJwdXNoIiwidXBkYXRlVXNlckJlaGF2aW9yIiwibGFzdEFjdGl2aXR5IiwiZ3JvdXBFbmQiLCJhcHBlbmREYXRhIiwiU1RPUkFHRV9LRVlTIiwiRVZFTlRTIiwibG9nTmV0d29ya0V2ZW50Iiwic3RhcnRUaW1lIiwiYWNrbm93bGVkZ2VkIiwicGF5bG9hZFNpemUiLCJyZXRyeUNvdW50IiwicnR0IiwicGVyZm9ybWFuY2UiLCJjb25uZWN0aW9uUXVhbGl0eSIsImFzc2Vzc0Nvbm5lY3Rpb25RdWFsaXR5IiwibmV0d29ya01ldHJpYyIsIm5ldHdvcmtNZXRyaWNzIiwiTkVUV09SSyIsIndhcm4iLCJzdGFydFBlcmZvcm1hbmNlTW9uaXRvcmluZyIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsIm1vbml0b3IiLCJkZWx0YVRpbWUiLCJsYXN0RlBTQ2hlY2siLCJmcHMiLCJmcmFtZUNvdW50IiwibWVtb3J5VXNhZ2UiLCJtZW1vcnkiLCJ1c2VkSlNIZWFwU2l6ZSIsInBlcmZNZXRyaWMiLCJyb3VuZCIsImNhbnZhc1JlbmRlclRpbWUiLCJldmVudFByb2Nlc3NpbmdUaW1lIiwicXVldWVkRXZlbnRzIiwiZXZlbnRRdWV1ZSIsImxlbmd0aCIsInBlcmZvcm1hbmNlTWV0cmljcyIsIlBFUkZPUk1BTkNFIiwidG9GaXhlZCIsImN1cnJlbnRTdHJva2VTdGFydCIsInN0cm9rZUR1cmF0aW9uIiwiZW1pdFdpdGhMb2dnaW5nIiwic29ja2V0IiwiZXZlbnROYW1lIiwib3B0aW9ucyIsIlByb21pc2UiLCJyZXNvbHZlIiwibWF4UmV0cmllcyIsImF0dGVtcHQiLCJlbWl0IiwiYWNrIiwic2V0VGltZW91dCIsImVycm9yIiwiZXhwb3J0QW5hbHl0aWNzIiwic2Vzc2lvbiIsIm5ldHdvcmsiLCJzdW1tYXJ5IiwiZ2VuZXJhdGVTdW1tYXJ5IiwidG90YWxFdmVudHMiLCJhdmdSVFQiLCJyZWR1Y2UiLCJzdW0iLCJtIiwiYWNrbm93bGVkZ2VkTWVzc2FnZXMiLCJmaWx0ZXIiLCJuYWNrTWVzc2FnZXMiLCJmYWlsZWREYXRhU2VuZCIsImkiLCJzdWNjZXNzUmF0ZSIsInRvdGFsRGF0YVNlbmQiLCJ0b3RhbERhdGFBdHRlbXB0ZWQiLCJkYXRhRWZmaWNpZW5jeVJhdGUiLCJhdmdTdWNjZXNzZnVsUGF5bG9hZFNpemUiLCJhdmdGYWlsZWRQYXlsb2FkU2l6ZSIsImF2Z0ZQUyIsInNlc3Npb25EdXJhdGlvbiIsIm5ldHdvcmtRdWFsaXR5RGlzdHJpYnV0aW9uIiwiZ2V0TmV0d29ya1F1YWxpdHlEaXN0cmlidXRpb24iLCJkaXN0cmlidXRpb24iLCJleGNlbGxlbnQiLCJnb29kIiwiZmFpciIsInBvb3IiLCJkZWNlbnQiLCJmb3JFYWNoIiwibWV0cmljIiwic3RhcnRSZWFsdGltZU1vbml0b3JpbmciLCJnZXRTdG9yYWdlSW5mbyIsImRlc3Ryb3kiLCJjbGVhckludGVydmFsIiwiY29uc3RydWN0b3IiLCJ3aW5kb3ciLCJhZGRFdmVudExpc3RlbmVyIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/util/DrawingAnalytics.ts\n"));

/***/ })

});