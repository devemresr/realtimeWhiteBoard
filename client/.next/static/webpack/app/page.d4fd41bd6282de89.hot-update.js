"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/util/AnalyticsLocalStorageManager.ts":
/*!**************************************************!*\
  !*** ./src/util/AnalyticsLocalStorageManager.ts ***!
  \**************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var object_sizeof__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! object-sizeof */ \"(app-pages-browser)/../node_modules/object-sizeof/indexv2.js\");\n/* harmony import */ var object_sizeof__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(object_sizeof__WEBPACK_IMPORTED_MODULE_0__);\n\nclass AnalyticsLocalStorageManager {\n    // Store data with size management\n    storeData(key, data) {\n        try {\n            const serialized = JSON.stringify(data);\n            console.log('sizeof serialized:', object_sizeof__WEBPACK_IMPORTED_MODULE_0___default()(serialized));\n            const sizeInMB = new Blob([\n                serialized\n            ]).size / (1024 * 1024);\n            // If data is getting too large (>5MB), keep only recent items\n            if (sizeInMB > 5) {\n                const recentData = data.slice(-1000); // Keep last 1000 items\n                localStorage.setItem(key, JSON.stringify(recentData));\n                console.warn(\"\\uD83D\\uDCE6 Storage size exceeded for \".concat(key, \", keeping recent \").concat(recentData.length, \" items\"));\n            } else {\n                localStorage.setItem(key, serialized);\n            }\n        } catch (error) {\n            console.error(\"❌ Failed to store \".concat(key, \":\"), error);\n            this.handleStorageError(key, data);\n        }\n    }\n    getData(key) {\n        try {\n            const data = localStorage.getItem(key);\n            return data ? JSON.parse(data) : [];\n        } catch (error) {\n            console.error(\"❌ Failed to retrieve \".concat(key, \":\"), error);\n            return [];\n        }\n    }\n    appendData(key, newItem) {\n        const existing = this.getData(key);\n        existing.push(newItem);\n        this.storeData(key, existing);\n    }\n    updateUserBehavior(behavior) {\n        localStorage.setItem(this.STORAGE_KEYS.USER_BEHAVIOR, JSON.stringify(behavior));\n    }\n    getUserBehavior() {\n        const data = localStorage.getItem(this.STORAGE_KEYS.USER_BEHAVIOR);\n        return data ? JSON.parse(data) : null;\n    }\n    // Queue data for syncing\n    queueForSync(sessionId) {\n        const payload = {\n            sessionId,\n            events: this.getData(this.STORAGE_KEYS.EVENTS),\n            networkMetrics: this.getData(this.STORAGE_KEYS.NETWORK),\n            performanceMetrics: this.getData(this.STORAGE_KEYS.PERFORMANCE),\n            userBehavior: this.getUserBehavior() || {},\n            timestamp: Date.now()\n        };\n        const syncQueue = this.getData(this.STORAGE_KEYS.SYNC_QUEUE);\n        syncQueue.push(payload);\n        this.storeData(this.STORAGE_KEYS.SYNC_QUEUE, syncQueue);\n    }\n    getSyncQueue() {\n        return this.getData(this.STORAGE_KEYS.SYNC_QUEUE);\n    }\n    clearSyncedData(timestamp) {\n        const queue = this.getSyncQueue().filter((item)=>item.timestamp > timestamp);\n        this.storeData(this.STORAGE_KEYS.SYNC_QUEUE, queue);\n    }\n    clearLocalData() {\n        Object.values(this.STORAGE_KEYS).forEach((key)=>{\n            if (key !== this.STORAGE_KEYS.SYNC_QUEUE) {\n                localStorage.removeItem(key);\n            }\n        });\n    }\n    handleStorageError(key, data) {\n        // Try to clear old data and retry\n        if (Array.isArray(data) && data.length > 100) {\n            const reducedData = data.slice(-50);\n            try {\n                localStorage.setItem(key, JSON.stringify(reducedData));\n                console.warn(\"Reduced \".concat(key, \" data size and retried\"));\n            } catch (e) {\n                console.error(\"Critical storage error for \".concat(key));\n            }\n        }\n    }\n    getStorageInfo() {\n        const info = Object.entries(this.STORAGE_KEYS).map((param)=>{\n            let [name, key] = param;\n            const data = localStorage.getItem(key);\n            const size = data ? new Blob([\n                data\n            ]).size : 0;\n            return {\n                name,\n                key,\n                size: \"\".concat((size / 1024).toFixed(2), \" KB\"),\n                items: data ? JSON.parse(data).length || 1 : 0\n            };\n        });\n        return info;\n    }\n    constructor(){\n        this.STORAGE_KEYS = {\n            EVENTS: 'drawing_analytics_events',\n            NETWORK: 'drawing_analytics_network',\n            PERFORMANCE: 'drawing_analytics_performance',\n            USER_BEHAVIOR: 'drawing_analytics_behavior',\n            SYNC_QUEUE: 'drawing_analytics_sync_queue',\n            LAST_SYNC: 'drawing_analytics_last_sync'\n        };\n    }\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (AnalyticsLocalStorageManager);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy91dGlsL0FuYWx5dGljc0xvY2FsU3RvcmFnZU1hbmFnZXIudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQW1DO0FBaUVuQyxNQUFNQztJQVVMLGtDQUFrQztJQUNsQ0MsVUFBYUMsR0FBVyxFQUFFQyxJQUFTLEVBQVE7UUFDMUMsSUFBSTtZQUNILE1BQU1DLGFBQWFDLEtBQUtDLFNBQVMsQ0FBQ0g7WUFDbENJLFFBQVFDLEdBQUcsQ0FBQyxzQkFBc0JULG9EQUFNQSxDQUFDSztZQUV6QyxNQUFNSyxXQUFXLElBQUlDLEtBQUs7Z0JBQUNOO2FBQVcsRUFBRU8sSUFBSSxHQUFJLFFBQU8sSUFBRztZQUUxRCw4REFBOEQ7WUFDOUQsSUFBSUYsV0FBVyxHQUFHO2dCQUNqQixNQUFNRyxhQUFhVCxLQUFLVSxLQUFLLENBQUMsQ0FBQyxPQUFPLHVCQUF1QjtnQkFDN0RDLGFBQWFDLE9BQU8sQ0FBQ2IsS0FBS0csS0FBS0MsU0FBUyxDQUFDTTtnQkFDekNMLFFBQVFTLElBQUksQ0FDWCwwQ0FBdURKLE9BQXZCVixLQUFJLHFCQUFxQyxPQUFsQlUsV0FBV0ssTUFBTSxFQUFDO1lBRTNFLE9BQU87Z0JBQ05ILGFBQWFDLE9BQU8sQ0FBQ2IsS0FBS0U7WUFDM0I7UUFDRCxFQUFFLE9BQU9jLE9BQU87WUFDZlgsUUFBUVcsS0FBSyxDQUFDLHFCQUF5QixPQUFKaEIsS0FBSSxNQUFJZ0I7WUFDM0MsSUFBSSxDQUFDQyxrQkFBa0IsQ0FBQ2pCLEtBQUtDO1FBQzlCO0lBQ0Q7SUFFQWlCLFFBQVdsQixHQUFXLEVBQU87UUFDNUIsSUFBSTtZQUNILE1BQU1DLE9BQU9XLGFBQWFPLE9BQU8sQ0FBQ25CO1lBQ2xDLE9BQU9DLE9BQU9FLEtBQUtpQixLQUFLLENBQUNuQixRQUFRLEVBQUU7UUFDcEMsRUFBRSxPQUFPZSxPQUFPO1lBQ2ZYLFFBQVFXLEtBQUssQ0FBQyx3QkFBNEIsT0FBSmhCLEtBQUksTUFBSWdCO1lBQzlDLE9BQU8sRUFBRTtR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LEdBQUc7WUFDNUMsT0FBTztnQkFDTnFEO2dCQUNBOUQ7Z0JBQ0FTLE1BQU0sR0FBNEIsT0FBekIsQ0FBQ0EsT0FBTyxJQUFHLEVBQUdzRCxPQUFPLENBQUMsSUFBRztnQkFDbENDLE9BQU8vRCxPQUFPRSxLQUFLaUIsS0FBSyxDQUFDbkIsTUFBTWMsTUFBTSxJQUFJLElBQUk7WUFDOUM7UUFDRDtRQUNBLE9BQU80QztJQUNSOzthQTdIaUJoQyxlQUFlO1lBQy9CTyxRQUFRO1lBQ1JFLFNBQVM7WUFDVEUsYUFBYTtZQUNiVixlQUFlO1lBQ2ZnQixZQUFZO1lBQ1pxQixXQUFXO1FBQ1o7O0FBdUhEO0FBRUEsaUVBQWVuRSw0QkFBNEJBLEVBQUMiLCJzb3VyY2VzIjpbIi9Vc2Vycy9lbXJleWlsZGlyaW0vRGVza3RvcC9maW5hbFByb2plY3QvY2xpZW50L3NyYy91dGlsL0FuYWx5dGljc0xvY2FsU3RvcmFnZU1hbmFnZXIudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHNpemVvZiBmcm9tICdvYmplY3Qtc2l6ZW9mJztcblxuaW50ZXJmYWNlIERyYXdpbmdFdmVudCB7XG5cdGV2ZW50SWQ6IHN0cmluZztcblx0dGltZXN0YW1wOiBudW1iZXI7XG5cdGV2ZW50VHlwZTpcblx0XHR8ICdzdHJva2Vfc3RhcnQnXG5cdFx0fCAnc3Ryb2tlX2NvbnRpbnVlJ1xuXHRcdHwgJ3N0cm9rZV9lbmQnXG5cdFx0fCAnY2FudmFzX2NsZWFyJ1xuXHRcdHwgJ3VuZG8nXG5cdFx0fCAncmVkbyc7XG5cdHN0cm9rZUlkPzogc3RyaW5nO1xuXHRjb29yZGluYXRlcz86IHsgeDogbnVtYmVyOyB5OiBudW1iZXIgfTtcblx0cHJlc3N1cmU/OiBudW1iZXI7XG5cdHRvb2w/OiBzdHJpbmc7XG5cdGNvbG9yPzogc3RyaW5nO1xuXHRicnVzaFNpemU/OiBudW1iZXI7XG5cdHVzZXJJZD86IHN0cmluZztcblx0c2Vzc2lvbklkOiBzdHJpbmc7XG59XG5cbmludGVyZmFjZSBOZXR3b3JrTWV0cmljcyB7XG5cdGV2ZW50SWQ6IHN0cmluZztcblx0dGltZXN0YW1wOiBudW1iZXI7XG5cdHJ0dDogbnVtYmVyO1xuXHRhY2tub3dsZWRnZWQ6IGJvb2xlYW47XG5cdHJldHJ5Q291bnQ6IG51bWJlcjtcblx0cGF5bG9hZFNpemU6IG51bWJlcjtcblx0Y29ubmVjdGlvblF1YWxpdHk6ICdleGNlbGxlbnQnIHwgJ2dvb2QnIHwgJ2ZhaXInIHwgJ2RlY2VudCcgfCAncG9vcic7XG59XG5cbmludGVyZmFjZSBQZXJmb3JtYW5jZU1ldHJpY3Mge1xuXHR0aW1lc3RhbXA6IG51bWJlcjtcblx0ZnBzOiBudW1iZXI7XG5cdG1lbW9yeVVzYWdlOiBudW1iZXI7XG5cdGNhbnZhc1JlbmRlclRpbWU6IG51bWJlcjtcblx0ZXZlbnRQcm9jZXNzaW5nVGltZTogbnVtYmVyO1xuXHRxdWV1ZWRFdmVudHM6IG51bWJlcjtcbn1cblxuaW50ZXJmYWNlIFVzZXJCZWhhdmlvck1ldHJpY3Mge1xuXHRzZXNzaW9uSWQ6IHN0cmluZztcblx0dXNlcklkPzogc3RyaW5nO1xuXHRzZXNzaW9uU3RhcnQ6IG51bWJlcjtcblx0dG90YWxTdHJva2VzOiBudW1iZXI7XG5cdGF2ZXJhZ2VTdHJva2VMZW5ndGg6IG51bWJlcjtcblx0bW9zdFVzZWRUb29sOiBzdHJpbmc7XG5cdG1vc3RVc2VkQ29sb3I6IHN0cmluZztcblx0dG90YWxEcmF3aW5nVGltZTogbnVtYmVyO1xuXHRpZGxlVGltZTogbnVtYmVyO1xuXHR1bmRvQ291bnQ6IG51bWJlcjtcblx0cmVkb0NvdW50OiBudW1iZXI7XG5cdGNhbnZhc0NsZWFyQ291bnQ6IG51bWJlcjtcbn1cblxuaW50ZXJmYWNlIEFuYWx5dGljc1BheWxvYWQge1xuXHRzZXNzaW9uSWQ6IHN0cmluZztcblx0ZXZlbnRzOiBEcmF3aW5nRXZlbnRbXTtcblx0bmV0d29ya01ldHJpY3M6IE5ldHdvcmtNZXRyaWNzW107XG5cdHBlcmZvcm1hbmNlTWV0cmljczogUGVyZm9ybWFuY2VNZXRyaWNzW107XG5cdHVzZXJCZWhhdmlvcjogVXNlckJlaGF2aW9yTWV0cmljcztcblx0dGltZXN0YW1wOiBudW1iZXI7XG59XG5cbmNsYXNzIEFuYWx5dGljc0xvY2FsU3RvcmFnZU1hbmFnZXIge1xuXHRwcml2YXRlIHJlYWRvbmx5IFNUT1JBR0VfS0VZUyA9IHtcblx0XHRFVkVOVFM6ICdkcmF3aW5nX2FuYWx5dGljc19ldmVudHMnLFxuXHRcdE5FVFdPUks6ICdkcmF3aW5nX2FuYWx5dGljc19uZXR3b3JrJyxcblx0XHRQRVJGT1JNQU5DRTogJ2RyYXdpbmdfYW5hbHl0aWNzX3BlcmZvcm1hbmNlJyxcblx0XHRVU0VSX0JFSEFWSU9SOiAnZHJhd2luZ19hbmFseXRpY3NfYmVoYXZpb3InLFxuXHRcdFNZTkNfUVVFVUU6ICdkcmF3aW5nX2FuYWx5dGljc19zeW5jX3F1ZXVlJyxcblx0XHRMQVNUX1NZTkM6ICdkcmF3aW5nX2FuYWx5dGljc19sYXN0X3N5bmMnLFxuXHR9O1xuXG5cdC8vIFN0b3JlIGRhdGEgd2l0aCBzaXplIG1hbmFnZW1lbnRcblx0c3RvcmVEYXRhPFQ+KGtleTogc3RyaW5nLCBkYXRhOiBUW10pOiB2b2lkIHtcblx0XHR0cnkge1xuXHRcdFx0Y29uc3Qgc2VyaWFsaXplZCA9IEpTT04uc3RyaW5naWZ5KGRhdGEpO1xuXHRcdFx0Y29uc29sZS5sb2coJ3NpemVvZiBzZXJpYWxpemVkOicsIHNpemVvZihzZXJpYWxpemVkKSk7XG5cblx0XHRcdGNvbnN0IHNpemVJbk1CID0gbmV3IEJsb2IoW3NlcmlhbGl6ZWRdKS5zaXplIC8gKDEwMjQgKiAxMDI0KTtcblxuXHRcdFx0Ly8gSWYgZGF0YSBpcyBnZXR0aW5nIHRvbyBsYXJnZSAoPjVNQiksIGtlZXAgb25seSByZWNlbnQgaXRlbXNcblx0XHRcdGlmIChzaXplSW5NQiA+IDUpIHtcblx0XHRcdFx0Y29uc3QgcmVjZW50RGF0YSA9IGRhdGEuc2xpY2UoLTEwMDApOyAvLyBLZWVwIGxhc3QgMTAwMCBpdGVtc1xuXHRcdFx0XHRsb2NhbFN0b3JhZ2Uuc2V0SXRlbShrZXksIEpTT04uc3RyaW5naWZ5KHJlY2VudERhdGEpKTtcblx0XHRcdFx0Y29uc29sZS53YXJuKFxuXHRcdFx0XHRcdGDwn5OmIFN0b3JhZ2Ugc2l6ZSBleGNlZWRlZCBmb3IgJHtrZXl9LCBrZWVwaW5nIHJlY2VudCAke3JlY2VudERhdGEubGVuZ3RofSBpdGVtc2Bcblx0XHRcdFx0KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGxvY2FsU3RvcmFnZS5zZXRJdGVtKGtleSwgc2VyaWFsaXplZCk7XG5cdFx0XHR9XG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdGNvbnNvbGUuZXJyb3IoYOKdjCBGYWlsZWQgdG8gc3RvcmUgJHtrZXl9OmAsIGVycm9yKTtcblx0XHRcdHRoaXMuaGFuZGxlU3RvcmFnZUVycm9yKGtleSwgZGF0YSk7XG5cdFx0fVxuXHR9XG5cblx0Z2V0RGF0YTxUPihrZXk6IHN0cmluZyk6IFRbXSB7XG5cdFx0dHJ5IHtcblx0XHRcdGNvbnN0IGRhdGEgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShrZXkpO1xuXHRcdFx0cmV0dXJuIGRhdGEgPyBKU09OLnBhcnNlKGRhdGEpIDogW107XG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdGNvbnNvbGUuZXJyb3IoYOKdjCBGYWlsZWQgdG8gcmV0cmlldmUgJHtrZXl9OmAsIGVycm9yKTtcblx0XHRcdHJldHVybiBbXTtcblx0XHR9XG5cdH1cblxuXHRhcHBlbmREYXRhPFQ+KGtleTogc3RyaW5nLCBuZXdJdGVtOiBUKTogdm9pZCB7XG5cdFx0Y29uc3QgZXhpc3RpbmcgPSB0aGlzLmdldERhdGE8VD4oa2V5KTtcblx0XHRleGlzdGluZy5wdXNoKG5ld0l0ZW0pO1xuXHRcdHRoaXMuc3RvcmVEYXRhKGtleSwgZXhpc3RpbmcpO1xuXHR9XG5cblx0dXBkYXRlVXNlckJlaGF2aW9yKGJlaGF2aW9yOiBVc2VyQmVoYXZpb3JNZXRyaWNzKTogdm9pZCB7XG5cdFx0bG9jYWxTdG9yYWdlLnNldEl0ZW0oXG5cdFx0XHR0aGlzLlNUT1JBR0VfS0VZUy5VU0VSX0JFSEFWSU9SLFxuXHRcdFx0SlNPTi5zdHJpbmdpZnkoYmVoYXZpb3IpXG5cdFx0KTtcblx0fVxuXG5cdGdldFVzZXJCZWhhdmlvcigpOiBVc2VyQmVoYXZpb3JNZXRyaWNzIHwgbnVsbCB7XG5cdFx0Y29uc3QgZGF0YSA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKHRoaXMuU1RPUkFHRV9LRVlTLlVTRVJfQkVIQVZJT1IpO1xuXHRcdHJldHVybiBkYXRhID8gSlNPTi5wYXJzZShkYXRhKSA6IG51bGw7XG5cdH1cblxuXHQvLyBRdWV1ZSBkYXRhIGZvciBzeW5jaW5nXG5cdHF1ZXVlRm9yU3luYyhzZXNzaW9uSWQ6IHN0cmluZyk6IHZvaWQge1xuXHRcdGNvbnN0IHBheWxvYWQ6IEFuYWx5dGljc1BheWxvYWQgPSB7XG5cdFx0XHRzZXNzaW9uSWQsXG5cdFx0XHRldmVudHM6IHRoaXMuZ2V0RGF0YTxEcmF3aW5nRXZlbnQ+KHRoaXMuU1RPUkFHRV9LRVlTLkVWRU5UUyksXG5cdFx0XHRuZXR3b3JrTWV0cmljczogdGhpcy5nZXREYXRhPE5ldHdvcmtNZXRyaWNzPih0aGlzLlNUT1JBR0VfS0VZUy5ORVRXT1JLKSxcblx0XHRcdHBlcmZvcm1hbmNlTWV0cmljczogdGhpcy5nZXREYXRhPFBlcmZvcm1hbmNlTWV0cmljcz4oXG5cdFx0XHRcdHRoaXMuU1RPUkFHRV9LRVlTLlBFUkZPUk1BTkNFXG5cdFx0XHQpLFxuXHRcdFx0dXNlckJlaGF2aW9yOiB0aGlzLmdldFVzZXJCZWhhdmlvcigpIHx8ICh7fSBhcyBVc2VyQmVoYXZpb3JNZXRyaWNzKSxcblx0XHRcdHRpbWVzdGFtcDogRGF0ZS5ub3coKSxcblx0XHR9O1xuXG5cdFx0Y29uc3Qgc3luY1F1ZXVlID0gdGhpcy5nZXREYXRhPEFuYWx5dGljc1BheWxvYWQ+KFxuXHRcdFx0dGhpcy5TVE9SQUdFX0tFWVMuU1lOQ19RVUVVRVxuXHRcdCk7XG5cdFx0c3luY1F1ZXVlLnB1c2gocGF5bG9hZCk7XG5cdFx0dGhpcy5zdG9yZURhdGEodGhpcy5TVE9SQUdFX0tFWVMuU1lOQ19RVUVVRSwgc3luY1F1ZXVlKTtcblx0fVxuXG5cdGdldFN5bmNRdWV1ZSgpOiBBbmFseXRpY3NQYXlsb2FkW10ge1xuXHRcdHJldHVybiB0aGlzLmdldERhdGE8QW5hbHl0aWNzUGF5bG9hZD4odGhpcy5TVE9SQUdFX0tFWVMuU1lOQ19RVUVVRSk7XG5cdH1cblxuXHRjbGVhclN5bmNlZERhdGEodGltZXN0YW1wOiBudW1iZXIpOiB2b2lkIHtcblx0XHRjb25zdCBxdWV1ZSA9IHRoaXMuZ2V0U3luY1F1ZXVlKCkuZmlsdGVyKFxuXHRcdFx0KGl0ZW0pID0+IGl0ZW0udGltZXN0YW1wID4gdGltZXN0YW1wXG5cdFx0KTtcblx0XHR0aGlzLnN0b3JlRGF0YSh0aGlzLlNUT1JBR0VfS0VZUy5TWU5DX1FVRVVFLCBxdWV1ZSk7XG5cdH1cblxuXHRjbGVhckxvY2FsRGF0YSgpOiB2b2lkIHtcblx0XHRPYmplY3QudmFsdWVzKHRoaXMuU1RPUkFHRV9LRVlTKS5mb3JFYWNoKChrZXkpID0+IHtcblx0XHRcdGlmIChrZXkgIT09IHRoaXMuU1RPUkFHRV9LRVlTLlNZTkNfUVVFVUUpIHtcblx0XHRcdFx0bG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oa2V5KTtcblx0XHRcdH1cblx0XHR9KTtcblx0fVxuXG5cdHByaXZhdGUgaGFuZGxlU3RvcmFnZUVycm9yPFQ+KGtleTogc3RyaW5nLCBkYXRhOiBUW10pOiB2b2lkIHtcblx0XHQvLyBUcnkgdG8gY2xlYXIgb2xkIGRhdGEgYW5kIHJldHJ5XG5cdFx0aWYgKEFycmF5LmlzQXJyYXkoZGF0YSkgJiYgZGF0YS5sZW5ndGggPiAxMDApIHtcblx0XHRcdGNvbnN0IHJlZHVjZWREYXRhID0gZGF0YS5zbGljZSgtNTApO1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0bG9jYWxTdG9yYWdlLnNldEl0ZW0oa2V5LCBKU09OLnN0cmluZ2lmeShyZWR1Y2VkRGF0YSkpO1xuXHRcdFx0XHRjb25zb2xlLndhcm4oYFJlZHVjZWQgJHtrZXl9IGRhdGEgc2l6ZSBhbmQgcmV0cmllZGApO1xuXHRcdFx0fSBjYXRjaCB7XG5cdFx0XHRcdGNvbnNvbGUuZXJyb3IoYENyaXRpY2FsIHN0b3JhZ2UgZXJyb3IgZm9yICR7a2V5fWApO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdGdldFN0b3JhZ2VJbmZvKCkge1xuXHRcdGNvbnN0IGluZm8gPSBPYmplY3QuZW50cmllcyh0aGlzLlNUT1JBR0VfS0VZUykubWFwKChbbmFtZSwga2V5XSkgPT4ge1xuXHRcdFx0Y29uc3QgZGF0YSA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKGtleSk7XG5cdFx0XHRjb25zdCBzaXplID0gZGF0YSA/IG5ldyBCbG9iKFtkYXRhXSkuc2l6ZSA6IDA7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRuYW1lLFxuXHRcdFx0XHRrZXksXG5cdFx0XHRcdHNpemU6IGAkeyhzaXplIC8gMTAyNCkudG9GaXhlZCgyKX0gS0JgLFxuXHRcdFx0XHRpdGVtczogZGF0YSA/IEpTT04ucGFyc2UoZGF0YSkubGVuZ3RoIHx8IDEgOiAwLFxuXHRcdFx0fTtcblx0XHR9KTtcblx0XHRyZXR1cm4gaW5mbztcblx0fVxufVxuXG5leHBvcnQgZGVmYXVsdCBBbmFseXRpY3NMb2NhbFN0b3JhZ2VNYW5hZ2VyO1xuIl0sIm5hbWVzIjpbInNpemVvZiIsIkFuYWx5dGljc0xvY2FsU3RvcmFnZU1hbmFnZXIiLCJzdG9yZURhdGEiLCJrZXkiLCJkYXRhIiwic2VyaWFsaXplZCIsIkpTT04iLCJzdHJpbmdpZnkiLCJjb25zb2xlIiwibG9nIiwic2l6ZUluTUIiLCJCbG9iIiwic2l6ZSIsInJlY2VudERhdGEiLCJzbGljZSIsImxvY2FsU3RvcmFnZSIsInNldEl0ZW0iLCJ3YXJuIiwibGVuZ3RoIiwiZXJyb3IiLCJoYW5kbGVTdG9yYWdlRXJyb3IiLCJnZXREYXRhIiwiZ2V0SXRlbSIsInBhcnNlIiwiYXBwZW5kRGF0YSIsIm5ld0l0ZW0iLCJleGlzdGluZyIsInB1c2giLCJ1cGRhdGVVc2VyQmVoYXZpb3IiLCJiZWhhdmlvciIsIlNUT1JBR0VfS0VZUyIsIlVTRVJfQkVIQVZJT1IiLCJnZXRVc2VyQmVoYXZpb3IiLCJxdWV1ZUZvclN5bmMiLCJzZXNzaW9uSWQiLCJwYXlsb2FkIiwiZXZlbnRzIiwiRVZFTlRTIiwibmV0d29ya01ldHJpY3MiLCJORVRXT1JLIiwicGVyZm9ybWFuY2VNZXRyaWNzIiwiUEVSRk9STUFOQ0UiLCJ1c2VyQmVoYXZpb3IiLCJ0aW1lc3RhbXAiLCJEYXRlIiwibm93Iiwic3luY1F1ZXVlIiwiU1lOQ19RVUVVRSIsImdldFN5bmNRdWV1ZSIsImNsZWFyU3luY2VkRGF0YSIsInF1ZXVlIiwiZmlsdGVyIiwiaXRlbSIsImNsZWFyTG9jYWxEYXRhIiwiT2JqZWN0IiwidmFsdWVzIiwiZm9yRWFjaCIsInJlbW92ZUl0ZW0iLCJBcnJheSIsImlzQXJyYXkiLCJyZWR1Y2VkRGF0YSIsImdldFN0b3JhZ2VJbmZvIiwiaW5mbyIsImVudHJpZXMiLCJtYXAiLCJuYW1lIiwidG9GaXhlZCIsIml0ZW1zIiwiTEFTVF9TWU5DIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/util/AnalyticsLocalStorageManager.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/util/DrawingAnalytics.ts":
/*!**************************************!*\
  !*** ./src/util/DrawingAnalytics.ts ***!
  \**************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var object_sizeof__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! object-sizeof */ \"(app-pages-browser)/../node_modules/object-sizeof/indexv2.js\");\n/* harmony import */ var object_sizeof__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(object_sizeof__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _AnalyticsLocalStorageManager__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./AnalyticsLocalStorageManager */ \"(app-pages-browser)/./src/util/AnalyticsLocalStorageManager.ts\");\n\n\nclass DrawingAnalytics {\n    generateId() {\n        return \"\".concat(Date.now(), \"-\").concat(Math.random().toString(36).substr(2, 9));\n    }\n    initializeUserBehavior() {\n        return {\n            sessionId: this.sessionId,\n            userId: this.userId,\n            sessionStart: Date.now(),\n            totalStrokes: 0,\n            averageStrokeLength: 0,\n            mostUsedTool: '',\n            mostUsedColor: '',\n            totalDrawingTime: 0,\n            idleTime: 0,\n            undoCount: 0,\n            redoCount: 0,\n            canvasClearCount: 0\n        };\n    }\n    startPeriodicSync() {\n        let intervalMs = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 30000;\n        this.syncTimer = setInterval(async ()=>{\n            await this.syncNow();\n        }, intervalMs);\n    }\n    // Manual sync trigger\n    async syncNow() {\n        console.log('Starting analytics sync...');\n        // Queue current session data\n        this.storage.queueForSync(this.sessionId);\n        // Try to sync all queued data\n        const syncQueue = this.storage.getSyncQueue();\n        let syncedCount = 0;\n        // todo send to the backend\n        // for (const payload of syncQueue) {\n        // if (success) {\n        // \tthis.storage.clearSyncedData(payload.timestamp);\n        // \tsyncedCount++;\n        // } else {\n        // \tbreak; // Stop on first failure to maintain order\n        // }\n        // }\n        if (syncedCount > 0) {\n            console.log(\"Synced \".concat(syncedCount, \" analytics payloads\"));\n            // Clear local data after successful sync\n            this.storage.clearLocalData();\n            return true;\n        }\n        return false;\n    }\n    // Enhanced drawing event logging with comprehensive data\n    logDrawingEvent(eventType) {\n        let data = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n        const eventId = this.generateId();\n        const timestamp = Date.now();\n        const event = {\n            eventId,\n            timestamp,\n            eventType,\n            sessionId: this.sessionId,\n            userId: this.userId,\n            ...data\n        };\n        this.events.push(event);\n        this.updateUserBehavior(event);\n        this.lastActivity = timestamp;\n        // Log to console with structured format\n        console.group(\"\\uD83C\\uDFA8 Drawing Event: \".concat(eventType));\n        console.log('Event ID:', eventId);\n        console.log('Timestamp:', new Date(timestamp).toISOString());\n        console.log('Data:', data);\n        console.groupEnd();\n        return eventId;\n    }\n    // Enhanced network logging with quality assessment\n    logNetworkEvent(eventId, startTime, acknowledged, payloadSize) {\n        let retryCount = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 0;\n        const rtt = performance.now() - startTime;\n        const connectionQuality = this.assessConnectionQuality(rtt);\n        const networkMetric = {\n            eventId,\n            timestamp: Date.now(),\n            rtt,\n            acknowledged,\n            retryCount,\n            payloadSize,\n            connectionQuality\n        };\n        this.networkMetrics.push(networkMetric);\n        console.group(\"\\uD83D\\uDCE1 Network Event\");\n        console.log('Event ID:', eventId);\n        console.log('RTT:', \"\".concat(rtt.toFixed(2), \"ms\"));\n        console.log('Quality:', connectionQuality);\n        console.log('Payload Size:', \"\".concat(payloadSize, \" bytes\"));\n        console.log('Acknowledged:', acknowledged);\n        if (retryCount > 0) console.warn('Retry Count:', retryCount);\n        console.groupEnd();\n    }\n    assessConnectionQuality(rtt) {\n        if (rtt < 50) return 'excellent';\n        if (rtt < 100) return 'good';\n        if (rtt < 200) return 'fair';\n        if (rtt < 500) return 'decent';\n        return 'poor';\n    }\n    // Performance monitoring\n    startPerformanceMonitoring() {\n        if ( false || typeof requestAnimationFrame === 'undefined') {\n            console.warn('Performance monitoring not available in this environment');\n            return;\n        }\n        const monitor = ()=>{\n            const now = performance.now();\n            const deltaTime = now - this.lastFPSCheck;\n            if (deltaTime >= 1000) {\n                var _performance_memory;\n                // if its been a second\n                const fps = this.frameCount * 1000 / deltaTime;\n                const memoryUsage = ((_performance_memory = performance.memory) === null || _performance_memory === void 0 ? void 0 : _performance_memory.usedJSHeapSize) || 0;\n                const perfMetric = {\n                    timestamp: Date.now(),\n                    fps: Math.round(fps),\n                    memoryUsage,\n                    canvasRenderTime: 0,\n                    eventProcessingTime: 0,\n                    queuedEvents: this.eventQueue.length\n                };\n                this.performanceMetrics.push(perfMetric);\n                this.frameCount = 0;\n                this.lastFPSCheck = now;\n                // Log performance warnings\n                if (fps < 30) {\n                    console.warn(\"⚠️ Low FPS detected: \".concat(fps.toFixed(1)));\n                }\n                if (this.eventQueue.length > 10) {\n                    console.warn(\"⚠️ Event queue backlog: \".concat(this.eventQueue.length, \" events\"));\n                }\n            }\n            this.frameCount++;\n            requestAnimationFrame(monitor);\n        };\n        requestAnimationFrame(monitor);\n    }\n    // Update user behavior metrics\n    updateUserBehavior(event) {\n        switch(event.eventType){\n            case 'stroke_start':\n                this.userBehavior.totalStrokes++;\n                this.currentStrokeStart = event.timestamp;\n                break;\n            case 'stroke_end':\n                if (this.currentStrokeStart) {\n                    const strokeDuration = event.timestamp - this.currentStrokeStart;\n                    this.userBehavior.totalDrawingTime += strokeDuration;\n                }\n                break;\n            case 'undo':\n                this.userBehavior.undoCount++;\n                break;\n            case 'redo':\n                this.userBehavior.redoCount++;\n                break;\n            case 'canvas_clear':\n                this.userBehavior.canvasClearCount++;\n                break;\n        }\n    }\n    // Enhanced socket emission with comprehensive logging\n    emitWithLogging(socket, eventName, data) {\n        let options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};\n        return new Promise((resolve)=>{\n            const startTime = performance.now();\n            const eventId = this.logDrawingEvent('stroke_continue', data);\n            const payloadSize = object_sizeof__WEBPACK_IMPORTED_MODULE_0___default()(data);\n            let retryCount = 0;\n            const maxRetries = options.retryCount || 3;\n            const attempt = ()=>{\n                socket.emit(eventName, data, (ack)=>{\n                    this.logNetworkEvent(eventId, startTime, ack, payloadSize, retryCount);\n                    if (ack) {\n                        resolve(true);\n                    } else if (retryCount < maxRetries) {\n                        retryCount++;\n                        console.warn(\"\\uD83D\\uDD04 Retrying event \".concat(eventId, \" (attempt \").concat(retryCount, \"/\").concat(maxRetries, \")\"));\n                        setTimeout(attempt, 100 * retryCount); // Exponential backoff\n                    } else {\n                        console.error(\"❌ Event \".concat(eventId, \" failed after \").concat(maxRetries, \" retries\"));\n                        resolve(false);\n                    }\n                });\n            };\n            attempt();\n        });\n    }\n    // Data export and analysis methods\n    exportAnalytics() {\n        return {\n            session: this.userBehavior,\n            events: this.events,\n            network: this.networkMetrics,\n            performance: this.performanceMetrics,\n            summary: this.generateSummary()\n        };\n    }\n    generateSummary() {\n        const totalEvents = this.events.length;\n        const avgRTT = this.networkMetrics.reduce((sum, m)=>sum + m.rtt, 0) / this.networkMetrics.length || 0;\n        const acknowledgedMessages = this.networkMetrics.filter((m)=>m.acknowledged);\n        const nackMessages = this.networkMetrics.filter((m)=>!m.acknowledged);\n        const failedDataSend = nackMessages.reduce((sum, i)=>sum + i.payloadSize, 0);\n        const successRate = acknowledgedMessages.length / this.networkMetrics.length * 100 || 0;\n        const totalDataSend = acknowledgedMessages.reduce((sum, i)=>sum + i.payloadSize, 0);\n        console.log('failedDataSend,', failedDataSend);\n        const totalDataAttempted = totalDataSend + failedDataSend;\n        const dataEfficiencyRate = totalDataSend / totalDataAttempted * 100;\n        const avgSuccessfulPayloadSize = totalDataSend / acknowledgedMessages.length;\n        const avgFailedPayloadSize = failedDataSend / nackMessages.length;\n        const avgFPS = this.performanceMetrics.reduce((sum, m)=>sum + m.fps, 0) / this.performanceMetrics.length || 0;\n        return {\n            totalEvents,\n            avgRTT: Math.round(avgRTT * 100) / 100,\n            successRate: Math.round(successRate * 100) / 100,\n            avgFPS: Math.round(avgFPS),\n            totalDataSend: Math.round(totalDataSend),\n            dataEfficiencyRate: Math.round(dataEfficiencyRate),\n            avgSuccessfulPayloadSize: Math.round(avgSuccessfulPayloadSize),\n            avgFailedPayloadSize: Math.round(avgFailedPayloadSize),\n            sessionDuration: Date.now() - this.userBehavior.sessionStart,\n            networkQualityDistribution: this.getNetworkQualityDistribution()\n        };\n    }\n    getNetworkQualityDistribution() {\n        const distribution = {\n            excellent: 0,\n            good: 0,\n            fair: 0,\n            poor: 0,\n            decent: 0\n        };\n        this.networkMetrics.forEach((metric)=>{\n            distribution[metric.connectionQuality]++;\n        });\n        return distribution;\n    }\n    // Real-time monitoring dashboard (console-based)\n    startRealtimeMonitoring() {\n        let intervalMs = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 5000;\n        setInterval(()=>{\n            const summary = this.generateSummary();\n            console.log('Session Duration:', \"\".concat(Math.round(summary.sessionDuration / 1000), \"s\"));\n            console.log('Total Events:', summary.totalEvents);\n            console.log('Average RTT:', \"\".concat(summary.avgRTT, \"ms\"));\n            console.log('Success Rate:', \"\".concat(summary.successRate, \"%\"));\n            console.log('Average FPS:', summary.avgFPS);\n            console.log('Network Quality:', summary.networkQualityDistribution);\n            console.groupEnd();\n        }, intervalMs);\n    }\n    // Cleanup\n    destroy() {\n        if (this.syncTimer) {\n            clearInterval(this.syncTimer);\n        }\n        this.syncNow(); // Final sync\n    }\n    constructor(userId){\n        this.events = [];\n        this.networkMetrics = [];\n        this.performanceMetrics = [];\n        this.lastActivity = Date.now();\n        this.frameCount = 0;\n        this.lastFPSCheck = performance.now();\n        this.eventQueue = [];\n        this.sessionId = this.generateId();\n        this.userId = userId;\n        this.userBehavior = this.initializeUserBehavior();\n        this.storage = _AnalyticsLocalStorageManager__WEBPACK_IMPORTED_MODULE_1__[\"default\"];\n        this.startPerformanceMonitoring();\n    }\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (DrawingAnalytics);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy91dGlsL0RyYXdpbmdBbmFseXRpY3MudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFtQztBQUN1QztBQXVEMUUsTUFBTUU7SUF1QkdDLGFBQXFCO1FBQzVCLE9BQU8sR0FBaUJDLE9BQWRDLEtBQUtDLEdBQUcsSUFBRyxLQUEyQyxPQUF4Q0YsS0FBS0csTUFBTSxHQUFHQyxRQUFRLENBQUMsSUFBSUMsTUFBTSxDQUFDLEdBQUc7SUFDOUQ7SUFFUUMseUJBQThDO1FBQ3JELE9BQU87WUFDTkMsV0FBVyxJQUFJLENBQUNBLFNBQVM7WUFDekJDLFFBQVEsSUFBSSxDQUFDQSxNQUFNO1lBQ25CQyxjQUFjUixLQUFLQyxHQUFHO1lBQ3RCUSxjQUFjO1lBQ2RDLHFCQUFxQjtZQUNyQkMsY0FBYztZQUNkQyxlQUFlO1lBQ2ZDLGtCQUFrQjtZQUNsQkMsVUFBVTtZQUNWQyxXQUFXO1lBQ1hDLFdBQVc7WUFDWEMsa0JBQWtCO1FBQ25CO0lBQ0Q7SUFFUUMsb0JBQW9EO1lBQWxDQyxhQUFBQSxpRUFBcUI7UUFDOUMsSUFBSSxDQUFDQyxTQUFTLEdBQUdDLFlBQVk7WUFDNUIsTUFBTSxJQUFJLENBQUNDLE9BQU87UUFDbkIsR0FBR0g7SUFDSjtJQUVBLHNCQUFzQjtJQUN0QixNQUFNRyxVQUE0QjtRQUNqQ0MsUUFBUUMsR0FBRyxDQUFDO1FBRVosNkJBQTZCO1FBQzdCLElBQUksQ0FBQ0MsT0FBTyxDQUFDQyxZQUFZLENBQUMsSUFBSSxDQUFDcEIsU0FBUztRQUV4Qyw4QkFBOEI7UUFDOUIsTUFBTXFCLFlBQVksSUFBSSxDQUFDRixPQUFPLENBQUNHLFlBQVk7UUFDM0MsSUFBSUMsY0FBYztRQUVsQiwyQkFBMkI7UUFDM0IscUNBQXFDO1FBQ3JDLGlCQUFpQjtRQUNqQixvREFBb0Q7UUFDcEQsa0JBQWtCO1FBQ2xCLFdBQVc7UUFDWCxxREFBcUQ7UUFDckQsSUFBSTtRQUNKLElBQUk7UUFFSixJQUFJQSxjQUFjLEdBQUc7WUFDcEJO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QixHQUFrQixPQUFmcUUsUUFBUUcsTUFBTSxFQUFDO1lBQzlDekUsUUFBUUMsR0FBRyxDQUFDLGlCQUFpQixHQUF1QixPQUFwQnFFLFFBQVFZLFdBQVcsRUFBQztZQUNwRGxGLFFBQVFDLEdBQUcsQ0FBQyxnQkFBZ0JxRSxRQUFRa0IsTUFBTTtZQUMxQ3hGLFFBQVFDLEdBQUcsQ0FBQyxvQkFBb0JxRSxRQUFRb0IsMEJBQTBCO1lBRWxFMUYsUUFBUW9CLFFBQVE7UUFDakIsR0FBR3hCO0lBQ0o7SUFDQSxVQUFVO0lBQ1Z5RyxVQUFnQjtRQUNmLElBQUksSUFBSSxDQUFDeEcsU0FBUyxFQUFFO1lBQ25CeUcsY0FBYyxJQUFJLENBQUN6RyxTQUFTO1FBQzdCO1FBQ0EsSUFBSSxDQUFDRSxPQUFPLElBQUksYUFBYTtJQUM5QjtJQTNXQXdHLFlBQVl2SCxNQUFlLENBQUU7YUFYckI4QixTQUF5QixFQUFFO2FBRTNCaUIsaUJBQW1DLEVBQUU7YUFDckNvQixxQkFBMkMsRUFBRTthQUU3Q2xDLGVBQXVCeEMsS0FBS0MsR0FBRzthQUUvQjhELGFBQWE7YUFDYkYsZUFBZVgsWUFBWWpELEdBQUc7YUFDOUJ1RSxhQUFvQixFQUFFO1FBRzdCLElBQUksQ0FBQ2xFLFNBQVMsR0FBRyxJQUFJLENBQUNSLFVBQVU7UUFDaEMsSUFBSSxDQUFDUyxNQUFNLEdBQUdBO1FBQ2QsSUFBSSxDQUFDb0UsWUFBWSxHQUFHLElBQUksQ0FBQ3RFLHNCQUFzQjtRQUMvQyxJQUFJLENBQUNvQixPQUFPLEdBQUc3QixxRUFBNEJBO1FBQzNDLElBQUksQ0FBQzZELDBCQUEwQjtJQUNoQztBQXNXRDtBQUVBLGlFQUFlNUQsZ0JBQWdCQSxFQUFDIiwic291cmNlcyI6WyIvVXNlcnMvZW1yZXlpbGRpcmltL0Rlc2t0b3AvZmluYWxQcm9qZWN0L2NsaWVudC9zcmMvdXRpbC9EcmF3aW5nQW5hbHl0aWNzLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBzaXplb2YgZnJvbSAnb2JqZWN0LXNpemVvZic7XG5pbXBvcnQgQW5hbHl0aWNzTG9jYWxTdG9yYWdlTWFuYWdlciBmcm9tICcuL0FuYWx5dGljc0xvY2FsU3RvcmFnZU1hbmFnZXInO1xuaW50ZXJmYWNlIERyYXdpbmdFdmVudCB7XG5cdGV2ZW50SWQ6IHN0cmluZztcblx0dGltZXN0YW1wOiBudW1iZXI7XG5cdGV2ZW50VHlwZTpcblx0XHR8ICdzdHJva2Vfc3RhcnQnXG5cdFx0fCAnc3Ryb2tlX2NvbnRpbnVlJ1xuXHRcdHwgJ3N0cm9rZV9lbmQnXG5cdFx0fCAnY2FudmFzX2NsZWFyJ1xuXHRcdHwgJ3VuZG8nXG5cdFx0fCAncmVkbyc7XG5cdHN0cm9rZUlkPzogc3RyaW5nO1xuXHRjb29yZGluYXRlcz86IHsgeDogbnVtYmVyOyB5OiBudW1iZXIgfTtcblx0cHJlc3N1cmU/OiBudW1iZXI7XG5cdHRvb2w/OiBzdHJpbmc7XG5cdGNvbG9yPzogc3RyaW5nO1xuXHRicnVzaFNpemU/OiBudW1iZXI7XG5cdHVzZXJJZD86IHN0cmluZztcblx0c2Vzc2lvbklkOiBzdHJpbmc7XG59XG5cbmludGVyZmFjZSBOZXR3b3JrTWV0cmljcyB7XG5cdGV2ZW50SWQ6IHN0cmluZztcblx0dGltZXN0YW1wOiBudW1iZXI7XG5cdHJ0dDogbnVtYmVyO1xuXHRhY2tub3dsZWRnZWQ6IGJvb2xlYW47XG5cdHJldHJ5Q291bnQ6IG51bWJlcjtcblx0cGF5bG9hZFNpemU6IG51bWJlcjtcblx0Y29ubmVjdGlvblF1YWxpdHk6ICdleGNlbGxlbnQnIHwgJ2dvb2QnIHwgJ2ZhaXInIHwgJ2RlY2VudCcgfCAncG9vcic7XG59XG5cbmludGVyZmFjZSBQZXJmb3JtYW5jZU1ldHJpY3Mge1xuXHR0aW1lc3RhbXA6IG51bWJlcjtcblx0ZnBzOiBudW1iZXI7XG5cdG1lbW9yeVVzYWdlOiBudW1iZXI7XG5cdGNhbnZhc1JlbmRlclRpbWU6IG51bWJlcjtcblx0ZXZlbnRQcm9jZXNzaW5nVGltZTogbnVtYmVyO1xuXHRxdWV1ZWRFdmVudHM6IG51bWJlcjtcbn1cblxuaW50ZXJmYWNlIFVzZXJCZWhhdmlvck1ldHJpY3Mge1xuXHRzZXNzaW9uSWQ6IHN0cmluZztcblx0dXNlcklkPzogc3RyaW5nO1xuXHRzZXNzaW9uU3RhcnQ6IG51bWJlcjtcblx0dG90YWxTdHJva2VzOiBudW1iZXI7XG5cdGF2ZXJhZ2VTdHJva2VMZW5ndGg6IG51bWJlcjtcblx0bW9zdFVzZWRUb29sOiBzdHJpbmc7XG5cdG1vc3RVc2VkQ29sb3I6IHN0cmluZztcblx0dG90YWxEcmF3aW5nVGltZTogbnVtYmVyO1xuXHRpZGxlVGltZTogbnVtYmVyO1xuXHR1bmRvQ291bnQ6IG51bWJlcjtcblx0cmVkb0NvdW50OiBudW1iZXI7XG5cdGNhbnZhc0NsZWFyQ291bnQ6IG51bWJlcjtcbn1cblxuY2xhc3MgRHJhd2luZ0FuYWx5dGljcyB7XG5cdHByaXZhdGUgc2Vzc2lvbklkOiBzdHJpbmc7XG5cdHByaXZhdGUgc3RvcmFnZTogQW5hbHl0aWNzTG9jYWxTdG9yYWdlTWFuYWdlcjtcblx0cHJpdmF0ZSB1c2VySWQ/OiBzdHJpbmc7XG5cdHByaXZhdGUgZXZlbnRzOiBEcmF3aW5nRXZlbnRbXSA9IFtdO1xuXHRwcml2YXRlIHN5bmNUaW1lcjogTm9kZUpTLlRpbWVvdXQ7XG5cdHByaXZhdGUgbmV0d29ya01ldHJpY3M6IE5ldHdvcmtNZXRyaWNzW10gPSBbXTtcblx0cHJpdmF0ZSBwZXJmb3JtYW5jZU1ldHJpY3M6IFBlcmZvcm1hbmNlTWV0cmljc1tdID0gW107XG5cdHByaXZhdGUgdXNlckJlaGF2aW9yOiBVc2VyQmVoYXZpb3JNZXRyaWNzO1xuXHRwcml2YXRlIGxhc3RBY3Rpdml0eTogbnVtYmVyID0gRGF0ZS5ub3coKTtcblx0cHJpdmF0ZSBjdXJyZW50U3Ryb2tlU3RhcnQ/OiBudW1iZXI7XG5cdHByaXZhdGUgZnJhbWVDb3VudCA9IDA7XG5cdHByaXZhdGUgbGFzdEZQU0NoZWNrID0gcGVyZm9ybWFuY2Uubm93KCk7XG5cdHByaXZhdGUgZXZlbnRRdWV1ZTogYW55W10gPSBbXTtcblxuXHRjb25zdHJ1Y3Rvcih1c2VySWQ/OiBzdHJpbmcpIHtcblx0XHR0aGlzLnNlc3Npb25JZCA9IHRoaXMuZ2VuZXJhdGVJZCgpO1xuXHRcdHRoaXMudXNlcklkID0gdXNlcklkO1xuXHRcdHRoaXMudXNlckJlaGF2aW9yID0gdGhpcy5pbml0aWFsaXplVXNlckJlaGF2aW9yKCk7XG5cdFx0dGhpcy5zdG9yYWdlID0gQW5hbHl0aWNzTG9jYWxTdG9yYWdlTWFuYWdlcjtcblx0XHR0aGlzLnN0YXJ0UGVyZm9ybWFuY2VNb25pdG9yaW5nKCk7XG5cdH1cblxuXHRwcml2YXRlIGdlbmVyYXRlSWQoKTogc3RyaW5nIHtcblx0XHRyZXR1cm4gYCR7RGF0ZS5ub3coKX0tJHtNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHIoMiwgOSl9YDtcblx0fVxuXG5cdHByaXZhdGUgaW5pdGlhbGl6ZVVzZXJCZWhhdmlvcigpOiBVc2VyQmVoYXZpb3JNZXRyaWNzIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0c2Vzc2lvbklkOiB0aGlzLnNlc3Npb25JZCxcblx0XHRcdHVzZXJJZDogdGhpcy51c2VySWQsXG5cdFx0XHRzZXNzaW9uU3RhcnQ6IERhdGUubm93KCksXG5cdFx0XHR0b3RhbFN0cm9rZXM6IDAsXG5cdFx0XHRhdmVyYWdlU3Ryb2tlTGVuZ3RoOiAwLFxuXHRcdFx0bW9zdFVzZWRUb29sOiAnJyxcblx0XHRcdG1vc3RVc2VkQ29sb3I6ICcnLFxuXHRcdFx0dG90YWxEcmF3aW5nVGltZTogMCxcblx0XHRcdGlkbGVUaW1lOiAwLFxuXHRcdFx0dW5kb0NvdW50OiAwLFxuXHRcdFx0cmVkb0NvdW50OiAwLFxuXHRcdFx0Y2FudmFzQ2xlYXJDb3VudDogMCxcblx0XHR9O1xuXHR9XG5cblx0cHJpdmF0ZSBzdGFydFBlcmlvZGljU3luYyhpbnRlcnZhbE1zOiBudW1iZXIgPSAzMDAwMCk6IHZvaWQge1xuXHRcdHRoaXMuc3luY1RpbWVyID0gc2V0SW50ZXJ2YWwoYXN5bmMgKCkgPT4ge1xuXHRcdFx0YXdhaXQgdGhpcy5zeW5jTm93KCk7XG5cdFx0fSwgaW50ZXJ2YWxNcyk7XG5cdH1cblxuXHQvLyBNYW51YWwgc3luYyB0cmlnZ2VyXG5cdGFzeW5jIHN5bmNOb3coKTogUHJvbWlzZTxib29sZWFuPiB7XG5cdFx0Y29uc29sZS5sb2coJ1N0YXJ0aW5nIGFuYWx5dGljcyBzeW5jLi4uJyk7XG5cblx0XHQvLyBRdWV1ZSBjdXJyZW50IHNlc3Npb24gZGF0YVxuXHRcdHRoaXMuc3RvcmFnZS5xdWV1ZUZvclN5bmModGhpcy5zZXNzaW9uSWQpO1xuXG5cdFx0Ly8gVHJ5IHRvIHN5bmMgYWxsIHF1ZXVlZCBkYXRhXG5cdFx0Y29uc3Qgc3luY1F1ZXVlID0gdGhpcy5zdG9yYWdlLmdldFN5bmNRdWV1ZSgpO1xuXHRcdGxldCBzeW5jZWRDb3VudCA9IDA7XG5cblx0XHQvLyB0b2RvIHNlbmQgdG8gdGhlIGJhY2tlbmRcblx0XHQvLyBmb3IgKGNvbnN0IHBheWxvYWQgb2Ygc3luY1F1ZXVlKSB7XG5cdFx0Ly8gaWYgKHN1Y2Nlc3MpIHtcblx0XHQvLyBcdHRoaXMuc3RvcmFnZS5jbGVhclN5bmNlZERhdGEocGF5bG9hZC50aW1lc3RhbXApO1xuXHRcdC8vIFx0c3luY2VkQ291bnQrKztcblx0XHQvLyB9IGVsc2Uge1xuXHRcdC8vIFx0YnJlYWs7IC8vIFN0b3Agb24gZmlyc3QgZmFpbHVyZSB0byBtYWludGFpbiBvcmRlclxuXHRcdC8vIH1cblx0XHQvLyB9XG5cblx0XHRpZiAoc3luY2VkQ291bnQgPiAwKSB7XG5cdFx0XHRjb25zb2xlLmxvZyhgU3luY2VkICR7c3luY2VkQ291bnR9IGFuYWx5dGljcyBwYXlsb2Fkc2ApO1xuXHRcdFx0Ly8gQ2xlYXIgbG9jYWwgZGF0YSBhZnRlciBzdWNjZXNzZnVsIHN5bmNcblx0XHRcdHRoaXMuc3RvcmFnZS5jbGVhckxvY2FsRGF0YSgpO1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0Ly8gRW5oYW5jZWQgZHJhd2luZyBldmVudCBsb2dnaW5nIHdpdGggY29tcHJlaGVuc2l2ZSBkYXRhXG5cdGxvZ0RyYXdpbmdFdmVudChcblx0XHRldmVudFR5cGU6IERyYXdpbmdFdmVudFsnZXZlbnRUeXBlJ10sXG5cdFx0ZGF0YToge1xuXHRcdFx0Y29vcmRpbmF0ZXM/OiB7IHg6IG51bWJlcjsgeTogbnVtYmVyIH07XG5cdFx0XHRwcmVzc3VyZT86IG51bWJlcjtcblx0XHRcdHRvb2w/OiBzdHJpbmc7XG5cdFx0XHRjb2xvcj86IHN0cmluZztcblx0XHRcdGJydXNoU2l6ZT86IG51bWJlcjtcblx0XHRcdHN0cm9rZUlkPzogc3RyaW5nO1xuXHRcdH0gPSB7fVxuXHQpOiBzdHJpbmcge1xuXHRcdGNvbnN0IGV2ZW50SWQgPSB0aGlzLmdlbmVyYXRlSWQoKTtcblx0XHRjb25zdCB0aW1lc3RhbXAgPSBEYXRlLm5vdygpO1xuXG5cdFx0Y29uc3QgZXZlbnQ6IERyYXdpbmdFdmVudCA9IHtcblx0XHRcdGV2ZW50SWQsXG5cdFx0XHR0aW1lc3RhbXAsXG5cdFx0XHRldmVudFR5cGUsXG5cdFx0XHRzZXNzaW9uSWQ6IHRoaXMuc2Vzc2lvbklkLFxuXHRcdFx0dXNlcklkOiB0aGlzLnVzZXJJZCxcblx0XHRcdC4uLmRhdGEsXG5cdFx0fTtcblxuXHRcdHRoaXMuZXZlbnRzLnB1c2goZXZlbnQpO1xuXHRcdHRoaXMudXBkYXRlVXNlckJlaGF2aW9yKGV2ZW50KTtcblx0XHR0aGlzLmxhc3RBY3Rpdml0eSA9IHRpbWVzdGFtcDtcblxuXHRcdC8vIExvZyB0byBjb25zb2xlIHdpdGggc3RydWN0dXJlZCBmb3JtYXRcblx0XHRjb25zb2xlLmdyb3VwKGDwn46oIERyYXdpbmcgRXZlbnQ6ICR7ZXZlbnRUeXBlfWApO1xuXHRcdGNvbnNvbGUubG9nKCdFdmVudCBJRDonLCBldmVudElkKTtcblx0XHRjb25zb2xlLmxvZygnVGltZXN0YW1wOicsIG5ldyBEYXRlKHRpbWVzdGFtcCkudG9JU09TdHJpbmcoKSk7XG5cdFx0Y29uc29sZS5sb2coJ0RhdGE6JywgZGF0YSk7XG5cdFx0Y29uc29sZS5ncm91cEVuZCgpO1xuXG5cdFx0cmV0dXJuIGV2ZW50SWQ7XG5cdH1cblxuXHQvLyBFbmhhbmNlZCBuZXR3b3JrIGxvZ2dpbmcgd2l0aCBxdWFsaXR5IGFzc2Vzc21lbnRcblx0bG9nTmV0d29ya0V2ZW50KFxuXHRcdGV2ZW50SWQ6IHN0cmluZyxcblx0XHRzdGFydFRpbWU6IG51bWJlcixcblx0XHRhY2tub3dsZWRnZWQ6IGJvb2xlYW4sXG5cdFx0cGF5bG9hZFNpemU6IG51bWJlcixcblx0XHRyZXRyeUNvdW50OiBudW1iZXIgPSAwXG5cdCk6IHZvaWQge1xuXHRcdGNvbnN0IHJ0dCA9IHBlcmZvcm1hbmNlLm5vdygpIC0gc3RhcnRUaW1lO1xuXHRcdGNvbnN0IGNvbm5lY3Rpb25RdWFsaXR5ID0gdGhpcy5hc3Nlc3NDb25uZWN0aW9uUXVhbGl0eShydHQpO1xuXG5cdFx0Y29uc3QgbmV0d29ya01ldHJpYzogTmV0d29ya01ldHJpY3MgPSB7XG5cdFx0XHRldmVudElkLFxuXHRcdFx0dGltZXN0YW1wOiBEYXRlLm5vdygpLFxuXHRcdFx0cnR0LFxuXHRcdFx0YWNrbm93bGVkZ2VkLFxuXHRcdFx0cmV0cnlDb3VudCxcblx0XHRcdHBheWxvYWRTaXplLFxuXHRcdFx0Y29ubmVjdGlvblF1YWxpdHksXG5cdFx0fTtcblxuXHRcdHRoaXMubmV0d29ya01ldHJpY3MucHVzaChuZXR3b3JrTWV0cmljKTtcblxuXHRcdGNvbnNvbGUuZ3JvdXAoYPCfk6EgTmV0d29yayBFdmVudGApO1xuXHRcdGNvbnNvbGUubG9nKCdFdmVudCBJRDonLCBldmVudElkKTtcblx0XHRjb25zb2xlLmxvZygnUlRUOicsIGAke3J0dC50b0ZpeGVkKDIpfW1zYCk7XG5cdFx0Y29uc29sZS5sb2coJ1F1YWxpdHk6JywgY29ubmVjdGlvblF1YWxpdHkpO1xuXHRcdGNvbnNvbGUubG9nKCdQYXlsb2FkIFNpemU6JywgYCR7cGF5bG9hZFNpemV9IGJ5dGVzYCk7XG5cdFx0Y29uc29sZS5sb2coJ0Fja25vd2xlZGdlZDonLCBhY2tub3dsZWRnZWQpO1xuXHRcdGlmIChyZXRyeUNvdW50ID4gMCkgY29uc29sZS53YXJuKCdSZXRyeSBDb3VudDonLCByZXRyeUNvdW50KTtcblx0XHRjb25zb2xlLmdyb3VwRW5kKCk7XG5cdH1cblxuXHRwcml2YXRlIGFzc2Vzc0Nvbm5lY3Rpb25RdWFsaXR5KFxuXHRcdHJ0dDogbnVtYmVyXG5cdCk6IE5ldHdvcmtNZXRyaWNzWydjb25uZWN0aW9uUXVhbGl0eSddIHtcblx0XHRpZiAocnR0IDwgNTApIHJldHVybiAnZXhjZWxsZW50Jztcblx0XHRpZiAocnR0IDwgMTAwKSByZXR1cm4gJ2dvb2QnO1xuXHRcdGlmIChydHQgPCAyMDApIHJldHVybiAnZmFpcic7XG5cdFx0aWYgKHJ0dCA8IDUwMCkgcmV0dXJuICdkZWNlbnQnO1xuXHRcdHJldHVybiAncG9vcic7XG5cdH1cblxuXHQvLyBQZXJmb3JtYW5jZSBtb25pdG9yaW5nXG5cdHByaXZhdGUgc3RhcnRQZXJmb3JtYW5jZU1vbml0b3JpbmcoKTogdm9pZCB7XG5cdFx0aWYgKFxuXHRcdFx0dHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgfHxcblx0XHRcdHR5cGVvZiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPT09ICd1bmRlZmluZWQnXG5cdFx0KSB7XG5cdFx0XHRjb25zb2xlLndhcm4oJ1BlcmZvcm1hbmNlIG1vbml0b3Jpbmcgbm90IGF2YWlsYWJsZSBpbiB0aGlzIGVudmlyb25tZW50Jyk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdGNvbnN0IG1vbml0b3IgPSAoKSA9PiB7XG5cdFx0XHRjb25zdCBub3cgPSBwZXJmb3JtYW5jZS5ub3coKTtcblx0XHRcdGNvbnN0IGRlbHRhVGltZSA9IG5vdyAtIHRoaXMubGFzdEZQU0NoZWNrO1xuXG5cdFx0XHRpZiAoZGVsdGFUaW1lID49IDEwMDApIHtcblx0XHRcdFx0Ly8gaWYgaXRzIGJlZW4gYSBzZWNvbmRcblx0XHRcdFx0Y29uc3QgZnBzID0gKHRoaXMuZnJhbWVDb3VudCAqIDEwMDApIC8gZGVsdGFUaW1lO1xuXHRcdFx0XHRjb25zdCBtZW1vcnlVc2FnZSA9IChwZXJmb3JtYW5jZSBhcyBhbnkpLm1lbW9yeT8udXNlZEpTSGVhcFNpemUgfHwgMDtcblxuXHRcdFx0XHRjb25zdCBwZXJmTWV0cmljOiBQZXJmb3JtYW5jZU1ldHJpY3MgPSB7XG5cdFx0XHRcdFx0dGltZXN0YW1wOiBEYXRlLm5vdygpLFxuXHRcdFx0XHRcdGZwczogTWF0aC5yb3VuZChmcHMpLFxuXHRcdFx0XHRcdG1lbW9yeVVzYWdlLFxuXHRcdFx0XHRcdGNhbnZhc1JlbmRlclRpbWU6IDAsIC8vIFlvdSdsbCBuZWVkIHRvIG1lYXN1cmUgdGhpcyBpbiB5b3VyIHJlbmRlciBsb29wXG5cdFx0XHRcdFx0ZXZlbnRQcm9jZXNzaW5nVGltZTogMCwgLy8gTWVhc3VyZSBpbiB5b3VyIGV2ZW50IGhhbmRsZXJzXG5cdFx0XHRcdFx0cXVldWVkRXZlbnRzOiB0aGlzLmV2ZW50UXVldWUubGVuZ3RoLFxuXHRcdFx0XHR9O1xuXG5cdFx0XHRcdHRoaXMucGVyZm9ybWFuY2VNZXRyaWNzLnB1c2gocGVyZk1ldHJpYyk7XG5cdFx0XHRcdHRoaXMuZnJhbWVDb3VudCA9IDA7XG5cdFx0XHRcdHRoaXMubGFzdEZQU0NoZWNrID0gbm93O1xuXG5cdFx0XHRcdC8vIExvZyBwZXJmb3JtYW5jZSB3YXJuaW5nc1xuXHRcdFx0XHRpZiAoZnBzIDwgMzApIHtcblx0XHRcdFx0XHRjb25zb2xlLndhcm4oYOKaoO+4jyBMb3cgRlBTIGRldGVjdGVkOiAke2Zwcy50b0ZpeGVkKDEpfWApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICh0aGlzLmV2ZW50UXVldWUubGVuZ3RoID4gMTApIHtcblx0XHRcdFx0XHRjb25zb2xlLndhcm4oXG5cdFx0XHRcdFx0XHRg4pqg77iPIEV2ZW50IHF1ZXVlIGJhY2tsb2c6ICR7dGhpcy5ldmVudFF1ZXVlLmxlbmd0aH0gZXZlbnRzYFxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0dGhpcy5mcmFtZUNvdW50Kys7XG5cdFx0XHRyZXF1ZXN0QW5pbWF0aW9uRnJhbWUobW9uaXRvcik7XG5cdFx0fTtcblxuXHRcdHJlcXVlc3RBbmltYXRpb25GcmFtZShtb25pdG9yKTtcblx0fVxuXG5cdC8vIFVwZGF0ZSB1c2VyIGJlaGF2aW9yIG1ldHJpY3Ncblx0cHJpdmF0ZSB1cGRhdGVVc2VyQmVoYXZpb3IoZXZlbnQ6IERyYXdpbmdFdmVudCk6IHZvaWQge1xuXHRcdHN3aXRjaCAoZXZlbnQuZXZlbnRUeXBlKSB7XG5cdFx0XHRjYXNlICdzdHJva2Vfc3RhcnQnOlxuXHRcdFx0XHR0aGlzLnVzZXJCZWhhdmlvci50b3RhbFN0cm9rZXMrKztcblx0XHRcdFx0dGhpcy5jdXJyZW50U3Ryb2tlU3RhcnQgPSBldmVudC50aW1lc3RhbXA7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAnc3Ryb2tlX2VuZCc6XG5cdFx0XHRcdGlmICh0aGlzLmN1cnJlbnRTdHJva2VTdGFydCkge1xuXHRcdFx0XHRcdGNvbnN0IHN0cm9rZUR1cmF0aW9uID0gZXZlbnQudGltZXN0YW1wIC0gdGhpcy5jdXJyZW50U3Ryb2tlU3RhcnQ7XG5cdFx0XHRcdFx0dGhpcy51c2VyQmVoYXZpb3IudG90YWxEcmF3aW5nVGltZSArPSBzdHJva2VEdXJhdGlvbjtcblx0XHRcdFx0fVxuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgJ3VuZG8nOlxuXHRcdFx0XHR0aGlzLnVzZXJCZWhhdmlvci51bmRvQ291bnQrKztcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICdyZWRvJzpcblx0XHRcdFx0dGhpcy51c2VyQmVoYXZpb3IucmVkb0NvdW50Kys7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAnY2FudmFzX2NsZWFyJzpcblx0XHRcdFx0dGhpcy51c2VyQmVoYXZpb3IuY2FudmFzQ2xlYXJDb3VudCsrO1xuXHRcdFx0XHRicmVhaztcblx0XHR9XG5cdH1cblxuXHQvLyBFbmhhbmNlZCBzb2NrZXQgZW1pc3Npb24gd2l0aCBjb21wcmVoZW5zaXZlIGxvZ2dpbmdcblx0ZW1pdFdpdGhMb2dnaW5nKFxuXHRcdHNvY2tldDogYW55LFxuXHRcdGV2ZW50TmFtZTogc3RyaW5nLFxuXHRcdGRhdGE6IGFueSxcblx0XHRvcHRpb25zOiB7XG5cdFx0XHR0aW1lb3V0PzogbnVtYmVyO1xuXHRcdFx0cmV0cnlDb3VudD86IG51bWJlcjtcblx0XHRcdHByaW9yaXR5PzogJ2hpZ2gnIHwgJ25vcm1hbCcgfCAnbG93Jztcblx0XHR9ID0ge31cblx0KTogUHJvbWlzZTxib29sZWFuPiB7XG5cdFx0cmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG5cdFx0XHRjb25zdCBzdGFydFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcblx0XHRcdGNvbnN0IGV2ZW50SWQgPSB0aGlzLmxvZ0RyYXdpbmdFdmVudCgnc3Ryb2tlX2NvbnRpbnVlJywgZGF0YSk7XG5cdFx0XHRjb25zdCBwYXlsb2FkU2l6ZSA9IHNpemVvZihkYXRhKTtcblx0XHRcdGxldCByZXRyeUNvdW50ID0gMDtcblx0XHRcdGNvbnN0IG1heFJldHJpZXMgPSBvcHRpb25zLnJldHJ5Q291bnQgfHwgMztcblxuXHRcdFx0Y29uc3QgYXR0ZW1wdCA9ICgpID0+IHtcblx0XHRcdFx0c29ja2V0LmVtaXQoZXZlbnROYW1lLCBkYXRhLCAoYWNrOiBib29sZWFuKSA9PiB7XG5cdFx0XHRcdFx0dGhpcy5sb2dOZXR3b3JrRXZlbnQoXG5cdFx0XHRcdFx0XHRldmVudElkLFxuXHRcdFx0XHRcdFx0c3RhcnRUaW1lLFxuXHRcdFx0XHRcdFx0YWNrLFxuXHRcdFx0XHRcdFx0cGF5bG9hZFNpemUsXG5cdFx0XHRcdFx0XHRyZXRyeUNvdW50XG5cdFx0XHRcdFx0KTtcblxuXHRcdFx0XHRcdGlmIChhY2spIHtcblx0XHRcdFx0XHRcdHJlc29sdmUodHJ1ZSk7XG5cdFx0XHRcdFx0fSBlbHNlIGlmIChyZXRyeUNvdW50IDwgbWF4UmV0cmllcykge1xuXHRcdFx0XHRcdFx0cmV0cnlDb3VudCsrO1xuXHRcdFx0XHRcdFx0Y29uc29sZS53YXJuKFxuXHRcdFx0XHRcdFx0XHRg8J+UhCBSZXRyeWluZyBldmVudCAke2V2ZW50SWR9IChhdHRlbXB0ICR7cmV0cnlDb3VudH0vJHttYXhSZXRyaWVzfSlgXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0c2V0VGltZW91dChhdHRlbXB0LCAxMDAgKiByZXRyeUNvdW50KTsgLy8gRXhwb25lbnRpYWwgYmFja29mZlxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRjb25zb2xlLmVycm9yKFxuXHRcdFx0XHRcdFx0XHRg4p2MIEV2ZW50ICR7ZXZlbnRJZH0gZmFpbGVkIGFmdGVyICR7bWF4UmV0cmllc30gcmV0cmllc2Bcblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRyZXNvbHZlKGZhbHNlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdFx0fTtcblxuXHRcdFx0YXR0ZW1wdCgpO1xuXHRcdH0pO1xuXHR9XG5cblx0Ly8gRGF0YSBleHBvcnQgYW5kIGFuYWx5c2lzIG1ldGhvZHNcblx0ZXhwb3J0QW5hbHl0aWNzKCk6IHtcblx0XHRzZXNzaW9uOiBVc2VyQmVoYXZpb3JNZXRyaWNzO1xuXHRcdGV2ZW50czogRHJhd2luZ0V2ZW50W107XG5cdFx0bmV0d29yazogTmV0d29ya01ldHJpY3NbXTtcblx0XHRwZXJmb3JtYW5jZTogUGVyZm9ybWFuY2VNZXRyaWNzW107XG5cdFx0c3VtbWFyeTogYW55O1xuXHR9IHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0c2Vzc2lvbjogdGhpcy51c2VyQmVoYXZpb3IsXG5cdFx0XHRldmVudHM6IHRoaXMuZXZlbnRzLFxuXHRcdFx0bmV0d29yazogdGhpcy5uZXR3b3JrTWV0cmljcyxcblx0XHRcdHBlcmZvcm1hbmNlOiB0aGlzLnBlcmZvcm1hbmNlTWV0cmljcyxcblx0XHRcdHN1bW1hcnk6IHRoaXMuZ2VuZXJhdGVTdW1tYXJ5KCksXG5cdFx0fTtcblx0fVxuXG5cdHByaXZhdGUgZ2VuZXJhdGVTdW1tYXJ5KCkge1xuXHRcdGNvbnN0IHRvdGFsRXZlbnRzID0gdGhpcy5ldmVudHMubGVuZ3RoO1xuXHRcdGNvbnN0IGF2Z1JUVCA9XG5cdFx0XHR0aGlzLm5ldHdvcmtNZXRyaWNzLnJlZHVjZSgoc3VtLCBtKSA9PiBzdW0gKyBtLnJ0dCwgMCkgL1xuXHRcdFx0XHR0aGlzLm5ldHdvcmtNZXRyaWNzLmxlbmd0aCB8fCAwO1xuXHRcdGNvbnN0IGFja25vd2xlZGdlZE1lc3NhZ2VzID0gdGhpcy5uZXR3b3JrTWV0cmljcy5maWx0ZXIoXG5cdFx0XHQobSkgPT4gbS5hY2tub3dsZWRnZWRcblx0XHQpO1xuXHRcdGNvbnN0IG5hY2tNZXNzYWdlcyA9IHRoaXMubmV0d29ya01ldHJpY3MuZmlsdGVyKChtKSA9PiAhbS5hY2tub3dsZWRnZWQpO1xuXHRcdGNvbnN0IGZhaWxlZERhdGFTZW5kID0gbmFja01lc3NhZ2VzLnJlZHVjZShcblx0XHRcdChzdW06IG51bWJlciwgaTogTmV0d29ya01ldHJpY3MpID0+IHN1bSArIGkucGF5bG9hZFNpemUsXG5cdFx0XHQwXG5cdFx0KTtcblxuXHRcdGNvbnN0IHN1Y2Nlc3NSYXRlID1cblx0XHRcdChhY2tub3dsZWRnZWRNZXNzYWdlcy5sZW5ndGggLyB0aGlzLm5ldHdvcmtNZXRyaWNzLmxlbmd0aCkgKiAxMDAgfHwgMDtcblx0XHRjb25zdCB0b3RhbERhdGFTZW5kID0gYWNrbm93bGVkZ2VkTWVzc2FnZXMucmVkdWNlKFxuXHRcdFx0KHN1bTogbnVtYmVyLCBpOiBOZXR3b3JrTWV0cmljcykgPT4gc3VtICsgaS5wYXlsb2FkU2l6ZSxcblx0XHRcdDBcblx0XHQpO1xuXHRcdGNvbnNvbGUubG9nKCdmYWlsZWREYXRhU2VuZCwnLCBmYWlsZWREYXRhU2VuZCk7XG5cdFx0Y29uc3QgdG90YWxEYXRhQXR0ZW1wdGVkID0gdG90YWxEYXRhU2VuZCArIGZhaWxlZERhdGFTZW5kO1xuXHRcdGNvbnN0IGRhdGFFZmZpY2llbmN5UmF0ZSA9ICh0b3RhbERhdGFTZW5kIC8gdG90YWxEYXRhQXR0ZW1wdGVkKSAqIDEwMDtcblx0XHRjb25zdCBhdmdTdWNjZXNzZnVsUGF5bG9hZFNpemUgPVxuXHRcdFx0dG90YWxEYXRhU2VuZCAvIGFja25vd2xlZGdlZE1lc3NhZ2VzLmxlbmd0aDtcblx0XHRjb25zdCBhdmdGYWlsZWRQYXlsb2FkU2l6ZSA9IGZhaWxlZERhdGFTZW5kIC8gbmFja01lc3NhZ2VzLmxlbmd0aDtcblxuXHRcdGNvbnN0IGF2Z0ZQUyA9XG5cdFx0XHR0aGlzLnBlcmZvcm1hbmNlTWV0cmljcy5yZWR1Y2UoKHN1bSwgbSkgPT4gc3VtICsgbS5mcHMsIDApIC9cblx0XHRcdFx0dGhpcy5wZXJmb3JtYW5jZU1ldHJpY3MubGVuZ3RoIHx8IDA7XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0dG90YWxFdmVudHMsXG5cdFx0XHRhdmdSVFQ6IE1hdGgucm91bmQoYXZnUlRUICogMTAwKSAvIDEwMCxcblx0XHRcdHN1Y2Nlc3NSYXRlOiBNYXRoLnJvdW5kKHN1Y2Nlc3NSYXRlICogMTAwKSAvIDEwMCxcblx0XHRcdGF2Z0ZQUzogTWF0aC5yb3VuZChhdmdGUFMpLFxuXHRcdFx0dG90YWxEYXRhU2VuZDogTWF0aC5yb3VuZCh0b3RhbERhdGFTZW5kKSxcblx0XHRcdGRhdGFFZmZpY2llbmN5UmF0ZTogTWF0aC5yb3VuZChkYXRhRWZmaWNpZW5jeVJhdGUpLFxuXHRcdFx0YXZnU3VjY2Vzc2Z1bFBheWxvYWRTaXplOiBNYXRoLnJvdW5kKGF2Z1N1Y2Nlc3NmdWxQYXlsb2FkU2l6ZSksXG5cdFx0XHRhdmdGYWlsZWRQYXlsb2FkU2l6ZTogTWF0aC5yb3VuZChhdmdGYWlsZWRQYXlsb2FkU2l6ZSksXG5cdFx0XHRzZXNzaW9uRHVyYXRpb246IERhdGUubm93KCkgLSB0aGlzLnVzZXJCZWhhdmlvci5zZXNzaW9uU3RhcnQsXG5cdFx0XHRuZXR3b3JrUXVhbGl0eURpc3RyaWJ1dGlvbjogdGhpcy5nZXROZXR3b3JrUXVhbGl0eURpc3RyaWJ1dGlvbigpLFxuXHRcdH07XG5cdH1cblxuXHRwcml2YXRlIGdldE5ldHdvcmtRdWFsaXR5RGlzdHJpYnV0aW9uKCkge1xuXHRcdGNvbnN0IGRpc3RyaWJ1dGlvbiA9IHsgZXhjZWxsZW50OiAwLCBnb29kOiAwLCBmYWlyOiAwLCBwb29yOiAwLCBkZWNlbnQ6IDAgfTtcblx0XHR0aGlzLm5ldHdvcmtNZXRyaWNzLmZvckVhY2goKG1ldHJpYykgPT4ge1xuXHRcdFx0ZGlzdHJpYnV0aW9uW21ldHJpYy5jb25uZWN0aW9uUXVhbGl0eV0rKztcblx0XHR9KTtcblx0XHRyZXR1cm4gZGlzdHJpYnV0aW9uO1xuXHR9XG5cblx0Ly8gUmVhbC10aW1lIG1vbml0b3JpbmcgZGFzaGJvYXJkIChjb25zb2xlLWJhc2VkKVxuXHRzdGFydFJlYWx0aW1lTW9uaXRvcmluZyhpbnRlcnZhbE1zOiBudW1iZXIgPSA1MDAwKTogdm9pZCB7XG5cdFx0c2V0SW50ZXJ2YWwoKCkgPT4ge1xuXHRcdFx0Y29uc3Qgc3VtbWFyeSA9IHRoaXMuZ2VuZXJhdGVTdW1tYXJ5KCk7XG5cdFx0XHRjb25zb2xlLmxvZyhcblx0XHRcdFx0J1Nlc3Npb24gRHVyYXRpb246Jyxcblx0XHRcdFx0YCR7TWF0aC5yb3VuZChzdW1tYXJ5LnNlc3Npb25EdXJhdGlvbiAvIDEwMDApfXNgXG5cdFx0XHQpO1xuXHRcdFx0Y29uc29sZS5sb2coJ1RvdGFsIEV2ZW50czonLCBzdW1tYXJ5LnRvdGFsRXZlbnRzKTtcblx0XHRcdGNvbnNvbGUubG9nKCdBdmVyYWdlIFJUVDonLCBgJHtzdW1tYXJ5LmF2Z1JUVH1tc2ApO1xuXHRcdFx0Y29uc29sZS5sb2coJ1N1Y2Nlc3MgUmF0ZTonLCBgJHtzdW1tYXJ5LnN1Y2Nlc3NSYXRlfSVgKTtcblx0XHRcdGNvbnNvbGUubG9nKCdBdmVyYWdlIEZQUzonLCBzdW1tYXJ5LmF2Z0ZQUyk7XG5cdFx0XHRjb25zb2xlLmxvZygnTmV0d29yayBRdWFsaXR5OicsIHN1bW1hcnkubmV0d29ya1F1YWxpdHlEaXN0cmlidXRpb24pO1xuXG5cdFx0XHRjb25zb2xlLmdyb3VwRW5kKCk7XG5cdFx0fSwgaW50ZXJ2YWxNcyk7XG5cdH1cblx0Ly8gQ2xlYW51cFxuXHRkZXN0cm95KCk6IHZvaWQge1xuXHRcdGlmICh0aGlzLnN5bmNUaW1lcikge1xuXHRcdFx0Y2xlYXJJbnRlcnZhbCh0aGlzLnN5bmNUaW1lcik7XG5cdFx0fVxuXHRcdHRoaXMuc3luY05vdygpOyAvLyBGaW5hbCBzeW5jXG5cdH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgRHJhd2luZ0FuYWx5dGljcztcbiJdLCJuYW1lcyI6WyJzaXplb2YiLCJBbmFseXRpY3NMb2NhbFN0b3JhZ2VNYW5hZ2VyIiwiRHJhd2luZ0FuYWx5dGljcyIsImdlbmVyYXRlSWQiLCJNYXRoIiwiRGF0ZSIsIm5vdyIsInJhbmRvbSIsInRvU3RyaW5nIiwic3Vic3RyIiwiaW5pdGlhbGl6ZVVzZXJCZWhhdmlvciIsInNlc3Npb25JZCIsInVzZXJJZCIsInNlc3Npb25TdGFydCIsInRvdGFsU3Ryb2tlcyIsImF2ZXJhZ2VTdHJva2VMZW5ndGgiLCJtb3N0VXNlZFRvb2wiLCJtb3N0VXNlZENvbG9yIiwidG90YWxEcmF3aW5nVGltZSIsImlkbGVUaW1lIiwidW5kb0NvdW50IiwicmVkb0NvdW50IiwiY2FudmFzQ2xlYXJDb3VudCIsInN0YXJ0UGVyaW9kaWNTeW5jIiwiaW50ZXJ2YWxNcyIsInN5bmNUaW1lciIsInNldEludGVydmFsIiwic3luY05vdyIsImNvbnNvbGUiLCJsb2ciLCJzdG9yYWdlIiwicXVldWVGb3JTeW5jIiwic3luY1F1ZXVlIiwiZ2V0U3luY1F1ZXVlIiwic3luY2VkQ291bnQiLCJjbGVhckxvY2FsRGF0YSIsImxvZ0RyYXdpbmdFdmVudCIsImV2ZW50VHlwZSIsImRhdGEiLCJldmVudElkIiwidGltZXN0YW1wIiwiZXZlbnQiLCJldmVudHMiLCJwdXNoIiwidXBkYXRlVXNlckJlaGF2aW9yIiwibGFzdEFjdGl2aXR5IiwiZ3JvdXAiLCJ0b0lTT1N0cmluZyIsImdyb3VwRW5kIiwibG9nTmV0d29ya0V2ZW50Iiwic3RhcnRUaW1lIiwiYWNrbm93bGVkZ2VkIiwicGF5bG9hZFNpemUiLCJyZXRyeUNvdW50IiwicnR0IiwicGVyZm9ybWFuY2UiLCJjb25uZWN0aW9uUXVhbGl0eSIsImFzc2Vzc0Nvbm5lY3Rpb25RdWFsaXR5IiwibmV0d29ya01ldHJpYyIsIm5ldHdvcmtNZXRyaWNzIiwidG9GaXhlZCIsIndhcm4iLCJzdGFydFBlcmZvcm1hbmNlTW9uaXRvcmluZyIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsIm1vbml0b3IiLCJkZWx0YVRpbWUiLCJsYXN0RlBTQ2hlY2siLCJmcHMiLCJmcmFtZUNvdW50IiwibWVtb3J5VXNhZ2UiLCJtZW1vcnkiLCJ1c2VkSlNIZWFwU2l6ZSIsInBlcmZNZXRyaWMiLCJyb3VuZCIsImNhbnZhc1JlbmRlclRpbWUiLCJldmVudFByb2Nlc3NpbmdUaW1lIiwicXVldWVkRXZlbnRzIiwiZXZlbnRRdWV1ZSIsImxlbmd0aCIsInBlcmZvcm1hbmNlTWV0cmljcyIsInVzZXJCZWhhdmlvciIsImN1cnJlbnRTdHJva2VTdGFydCIsInN0cm9rZUR1cmF0aW9uIiwiZW1pdFdpdGhMb2dnaW5nIiwic29ja2V0IiwiZXZlbnROYW1lIiwib3B0aW9ucyIsIlByb21pc2UiLCJyZXNvbHZlIiwibWF4UmV0cmllcyIsImF0dGVtcHQiLCJlbWl0IiwiYWNrIiwic2V0VGltZW91dCIsImVycm9yIiwiZXhwb3J0QW5hbHl0aWNzIiwic2Vzc2lvbiIsIm5ldHdvcmsiLCJzdW1tYXJ5IiwiZ2VuZXJhdGVTdW1tYXJ5IiwidG90YWxFdmVudHMiLCJhdmdSVFQiLCJyZWR1Y2UiLCJzdW0iLCJtIiwiYWNrbm93bGVkZ2VkTWVzc2FnZXMiLCJmaWx0ZXIiLCJuYWNrTWVzc2FnZXMiLCJmYWlsZWREYXRhU2VuZCIsImkiLCJzdWNjZXNzUmF0ZSIsInRvdGFsRGF0YVNlbmQiLCJ0b3RhbERhdGFBdHRlbXB0ZWQiLCJkYXRhRWZmaWNpZW5jeVJhdGUiLCJhdmdTdWNjZXNzZnVsUGF5bG9hZFNpemUiLCJhdmdGYWlsZWRQYXlsb2FkU2l6ZSIsImF2Z0ZQUyIsInNlc3Npb25EdXJhdGlvbiIsIm5ldHdvcmtRdWFsaXR5RGlzdHJpYnV0aW9uIiwiZ2V0TmV0d29ya1F1YWxpdHlEaXN0cmlidXRpb24iLCJkaXN0cmlidXRpb24iLCJleGNlbGxlbnQiLCJnb29kIiwiZmFpciIsInBvb3IiLCJkZWNlbnQiLCJmb3JFYWNoIiwibWV0cmljIiwic3RhcnRSZWFsdGltZU1vbml0b3JpbmciLCJkZXN0cm95IiwiY2xlYXJJbnRlcnZhbCIsImNvbnN0cnVjdG9yIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/util/DrawingAnalytics.ts\n"));

/***/ })

});