"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/util/AnalyticsLocalStorageManager.ts":
/*!**************************************************!*\
  !*** ./src/util/AnalyticsLocalStorageManager.ts ***!
  \**************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var object_sizeof__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! object-sizeof */ \"(app-pages-browser)/../node_modules/object-sizeof/indexv2.js\");\n/* harmony import */ var object_sizeof__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(object_sizeof__WEBPACK_IMPORTED_MODULE_0__);\n\nclass AnalyticsLocalStorageManager {\n    // Store data with size management\n    storeData(key, data) {\n        try {\n            const serialized = JSON.stringify(data);\n            console.log('sizeof serialized:', object_sizeof__WEBPACK_IMPORTED_MODULE_0___default()(serialized));\n            console.log('here', object_sizeof__WEBPACK_IMPORTED_MODULE_0___default()(data));\n            // If data is getting too large (>5MB), keep only recent items\n            if (object_sizeof__WEBPACK_IMPORTED_MODULE_0___default()(serialized) / (1024 * 1024) > 5) {\n                const recentData = data.slice(-1000); // Keep last 1000 items\n                localStorage.setItem(key, JSON.stringify(recentData));\n                console.warn(\"Storage size exceeded for \".concat(key, \", keeping recent \").concat(recentData.length, \" items\"));\n            } else {\n                localStorage.setItem(key, serialized);\n            }\n        } catch (error) {\n            console.error(\"❌ Failed to store \".concat(key, \":\"), error);\n            this.handleStorageError(key, data);\n        }\n    }\n    getData(key) {\n        try {\n            const data = localStorage.getItem(key);\n            return data ? JSON.parse(data) : [];\n        } catch (error) {\n            console.error(\"❌ Failed to retrieve \".concat(key, \":\"), error);\n            return [];\n        }\n    }\n    appendData(key, newItem) {\n        const existing = this.getData(key);\n        existing.push(newItem);\n        this.storeData(key, existing);\n    }\n    updateUserBehavior(behavior) {\n        localStorage.setItem(this.STORAGE_KEYS.USER_BEHAVIOR, JSON.stringify(behavior));\n    }\n    getUserBehavior() {\n        const data = localStorage.getItem(this.STORAGE_KEYS.USER_BEHAVIOR);\n        return data ? JSON.parse(data) : null;\n    }\n    // Queue data for syncing\n    queueForSync(sessionId) {\n        const payload = {\n            sessionId,\n            events: this.getData(this.STORAGE_KEYS.EVENTS),\n            networkMetrics: this.getData(this.STORAGE_KEYS.NETWORK),\n            performanceMetrics: this.getData(this.STORAGE_KEYS.PERFORMANCE),\n            userBehavior: this.getUserBehavior() || {},\n            timestamp: Date.now()\n        };\n        const syncQueue = this.getData(this.STORAGE_KEYS.SYNC_QUEUE);\n        syncQueue.push(payload);\n        this.storeData(this.STORAGE_KEYS.SYNC_QUEUE, syncQueue);\n    }\n    getSyncQueue() {\n        return this.getData(this.STORAGE_KEYS.SYNC_QUEUE);\n    }\n    clearSyncedData(timestamp) {\n        const queue = this.getSyncQueue().filter((item)=>item.timestamp > timestamp);\n        this.storeData(this.STORAGE_KEYS.SYNC_QUEUE, queue);\n    }\n    clearLocalData() {\n        Object.values(this.STORAGE_KEYS).forEach((key)=>{\n            if (key !== this.STORAGE_KEYS.SYNC_QUEUE) {\n                localStorage.removeItem(key);\n            }\n        });\n    }\n    handleStorageError(key, data) {\n        // Try to clear old data and retry\n        if (Array.isArray(data) && data.length > 100) {\n            const reducedData = data.slice(-50);\n            try {\n                localStorage.setItem(key, JSON.stringify(reducedData));\n                console.warn(\"Reduced \".concat(key, \" data size and retried\"));\n            } catch (e) {\n                console.error(\"Critical storage error for \".concat(key));\n            }\n        }\n    }\n    getStorageInfo() {\n        const info = Object.entries(this.STORAGE_KEYS).map((param)=>{\n            let [name, key] = param;\n            const data = localStorage.getItem(key);\n            const size = data ? new Blob([\n                data\n            ]).size : 0;\n            return {\n                name,\n                key,\n                size: \"\".concat((size / 1024).toFixed(2), \" KB\"),\n                items: data ? JSON.parse(data).length || 1 : 0\n            };\n        });\n        return info;\n    }\n    constructor(){\n        this.STORAGE_KEYS = {\n            EVENTS: 'drawing_analytics_events',\n            NETWORK: 'drawing_analytics_network',\n            PERFORMANCE: 'drawing_analytics_performance',\n            USER_BEHAVIOR: 'drawing_analytics_behavior',\n            SYNC_QUEUE: 'drawing_analytics_sync_queue',\n            LAST_SYNC: 'drawing_analytics_last_sync'\n        };\n    }\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (AnalyticsLocalStorageManager);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy91dGlsL0FuYWx5dGljc0xvY2FsU3RvcmFnZU1hbmFnZXIudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQW1DO0FBaUVuQyxNQUFNQztJQVVMLGtDQUFrQztJQUNsQ0MsVUFBYUMsR0FBVyxFQUFFQyxJQUFTLEVBQVE7UUFDMUMsSUFBSTtZQUNILE1BQU1DLGFBQWFDLEtBQUtDLFNBQVMsQ0FBQ0g7WUFDbENJLFFBQVFDLEdBQUcsQ0FBQyxzQkFBc0JULG9EQUFNQSxDQUFDSztZQUN6Q0csUUFBUUMsR0FBRyxDQUFDLFFBQVFULG9EQUFNQSxDQUFDSTtZQUUzQiw4REFBOEQ7WUFDOUQsSUFBSUosb0RBQU1BLENBQUNLLGNBQWUsUUFBTyxJQUFHLElBQUssR0FBRztnQkFDM0MsTUFBTUssYUFBYU4sS0FBS08sS0FBSyxDQUFDLENBQUMsT0FBTyx1QkFBdUI7Z0JBQzdEQyxhQUFhQyxPQUFPLENBQUNWLEtBQUtHLEtBQUtDLFNBQVMsQ0FBQ0c7Z0JBQ3pDRixRQUFRTSxJQUFJLENBQ1gsNkJBQW9ESixPQUF2QlAsS0FBSSxxQkFBcUMsT0FBbEJPLFdBQVdLLE1BQU0sRUFBQztZQUV4RSxPQUFPO2dCQUNOSCxhQUFhQyxPQUFPLENBQUNWLEtBQUtFO1lBQzNCO1FBQ0QsRUFBRSxPQUFPVyxPQUFPO1lBQ2ZSLFFBQVFRLEtBQUssQ0FBQyxxQkFBeUIsT0FBSmIsS0FBSSxNQUFJYTtZQUMzQyxJQUFJLENBQUNDLGtCQUFrQixDQUFDZCxLQUFLQztRQUM5QjtJQUNEO0lBRUFjLFFBQVdmLEdBQVcsRUFBTztRQUM1QixJQUFJO1lBQ0gsTUFBTUMsT0FBT1EsYUFBYU8sT0FBTyxDQUFDaEI7WUFDbEMsT0FBT0MsT0FBT0UsS0FBS2MsS0FBSyxDQUFDaEIsUUFBUSxFQUFFO1FBQ3BDLEVBQUUsT0FBT1ksT0FBTztZQUNmUixRQUFRUSxLQUFLLENBQUMsd0JBQTRCLE9BQUpiLEtBQUksTUFBSWE7WUFDOUMsT0FBTyxFQUFFO1FBQ1Y7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RztZQUM1QyxPQUFPO2dCQUNORDtnQkFDQTNEO2dCQUNBNEQsTUFBTSxHQUE0QixPQUF6QixDQUFDQSxPQUFPLElBQUcsRUFBR0UsT0FBTyxDQUFDLElBQUc7Z0JBQ2xDQyxPQUFPOUQsT0FBT0UsS0FBS2MsS0FBSyxDQUFDaEIsTUFBTVcsTUFBTSxJQUFJLElBQUk7WUFDOUM7UUFDRDtRQUNBLE9BQU80QztJQUNSOzthQTVIaUJoQyxlQUFlO1lBQy9CTyxRQUFRO1lBQ1JFLFNBQVM7WUFDVEUsYUFBYTtZQUNiVixlQUFlO1lBQ2ZnQixZQUFZO1lBQ1p1QixXQUFXO1FBQ1o7O0FBc0hEO0FBRUEsaUVBQWVsRSw0QkFBNEJBLEVBQUMiLCJzb3VyY2VzIjpbIi9Vc2Vycy9lbXJleWlsZGlyaW0vRGVza3RvcC9maW5hbFByb2plY3QvY2xpZW50L3NyYy91dGlsL0FuYWx5dGljc0xvY2FsU3RvcmFnZU1hbmFnZXIudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHNpemVvZiBmcm9tICdvYmplY3Qtc2l6ZW9mJztcblxuaW50ZXJmYWNlIERyYXdpbmdFdmVudCB7XG5cdGV2ZW50SWQ6IHN0cmluZztcblx0dGltZXN0YW1wOiBudW1iZXI7XG5cdGV2ZW50VHlwZTpcblx0XHR8ICdzdHJva2Vfc3RhcnQnXG5cdFx0fCAnc3Ryb2tlX2NvbnRpbnVlJ1xuXHRcdHwgJ3N0cm9rZV9lbmQnXG5cdFx0fCAnY2FudmFzX2NsZWFyJ1xuXHRcdHwgJ3VuZG8nXG5cdFx0fCAncmVkbyc7XG5cdHN0cm9rZUlkPzogc3RyaW5nO1xuXHRjb29yZGluYXRlcz86IHsgeDogbnVtYmVyOyB5OiBudW1iZXIgfTtcblx0cHJlc3N1cmU/OiBudW1iZXI7XG5cdHRvb2w/OiBzdHJpbmc7XG5cdGNvbG9yPzogc3RyaW5nO1xuXHRicnVzaFNpemU/OiBudW1iZXI7XG5cdHVzZXJJZD86IHN0cmluZztcblx0c2Vzc2lvbklkOiBzdHJpbmc7XG59XG5cbmludGVyZmFjZSBOZXR3b3JrTWV0cmljcyB7XG5cdGV2ZW50SWQ6IHN0cmluZztcblx0dGltZXN0YW1wOiBudW1iZXI7XG5cdHJ0dDogbnVtYmVyO1xuXHRhY2tub3dsZWRnZWQ6IGJvb2xlYW47XG5cdHJldHJ5Q291bnQ6IG51bWJlcjtcblx0cGF5bG9hZFNpemU6IG51bWJlcjtcblx0Y29ubmVjdGlvblF1YWxpdHk6ICdleGNlbGxlbnQnIHwgJ2dvb2QnIHwgJ2ZhaXInIHwgJ2RlY2VudCcgfCAncG9vcic7XG59XG5cbmludGVyZmFjZSBQZXJmb3JtYW5jZU1ldHJpY3Mge1xuXHR0aW1lc3RhbXA6IG51bWJlcjtcblx0ZnBzOiBudW1iZXI7XG5cdG1lbW9yeVVzYWdlOiBudW1iZXI7XG5cdGNhbnZhc1JlbmRlclRpbWU6IG51bWJlcjtcblx0ZXZlbnRQcm9jZXNzaW5nVGltZTogbnVtYmVyO1xuXHRxdWV1ZWRFdmVudHM6IG51bWJlcjtcbn1cblxuaW50ZXJmYWNlIFVzZXJCZWhhdmlvck1ldHJpY3Mge1xuXHRzZXNzaW9uSWQ6IHN0cmluZztcblx0dXNlcklkPzogc3RyaW5nO1xuXHRzZXNzaW9uU3RhcnQ6IG51bWJlcjtcblx0dG90YWxTdHJva2VzOiBudW1iZXI7XG5cdGF2ZXJhZ2VTdHJva2VMZW5ndGg6IG51bWJlcjtcblx0bW9zdFVzZWRUb29sOiBzdHJpbmc7XG5cdG1vc3RVc2VkQ29sb3I6IHN0cmluZztcblx0dG90YWxEcmF3aW5nVGltZTogbnVtYmVyO1xuXHRpZGxlVGltZTogbnVtYmVyO1xuXHR1bmRvQ291bnQ6IG51bWJlcjtcblx0cmVkb0NvdW50OiBudW1iZXI7XG5cdGNhbnZhc0NsZWFyQ291bnQ6IG51bWJlcjtcbn1cblxuaW50ZXJmYWNlIEFuYWx5dGljc1BheWxvYWQge1xuXHRzZXNzaW9uSWQ6IHN0cmluZztcblx0ZXZlbnRzOiBEcmF3aW5nRXZlbnRbXTtcblx0bmV0d29ya01ldHJpY3M6IE5ldHdvcmtNZXRyaWNzW107XG5cdHBlcmZvcm1hbmNlTWV0cmljczogUGVyZm9ybWFuY2VNZXRyaWNzW107XG5cdHVzZXJCZWhhdmlvcjogVXNlckJlaGF2aW9yTWV0cmljcztcblx0dGltZXN0YW1wOiBudW1iZXI7XG59XG5cbmNsYXNzIEFuYWx5dGljc0xvY2FsU3RvcmFnZU1hbmFnZXIge1xuXHRwcml2YXRlIHJlYWRvbmx5IFNUT1JBR0VfS0VZUyA9IHtcblx0XHRFVkVOVFM6ICdkcmF3aW5nX2FuYWx5dGljc19ldmVudHMnLFxuXHRcdE5FVFdPUks6ICdkcmF3aW5nX2FuYWx5dGljc19uZXR3b3JrJyxcblx0XHRQRVJGT1JNQU5DRTogJ2RyYXdpbmdfYW5hbHl0aWNzX3BlcmZvcm1hbmNlJyxcblx0XHRVU0VSX0JFSEFWSU9SOiAnZHJhd2luZ19hbmFseXRpY3NfYmVoYXZpb3InLFxuXHRcdFNZTkNfUVVFVUU6ICdkcmF3aW5nX2FuYWx5dGljc19zeW5jX3F1ZXVlJyxcblx0XHRMQVNUX1NZTkM6ICdkcmF3aW5nX2FuYWx5dGljc19sYXN0X3N5bmMnLFxuXHR9O1xuXG5cdC8vIFN0b3JlIGRhdGEgd2l0aCBzaXplIG1hbmFnZW1lbnRcblx0c3RvcmVEYXRhPFQ+KGtleTogc3RyaW5nLCBkYXRhOiBUW10pOiB2b2lkIHtcblx0XHR0cnkge1xuXHRcdFx0Y29uc3Qgc2VyaWFsaXplZCA9IEpTT04uc3RyaW5naWZ5KGRhdGEpO1xuXHRcdFx0Y29uc29sZS5sb2coJ3NpemVvZiBzZXJpYWxpemVkOicsIHNpemVvZihzZXJpYWxpemVkKSk7XG5cdFx0XHRjb25zb2xlLmxvZygnaGVyZScsIHNpemVvZihkYXRhKSk7XG5cblx0XHRcdC8vIElmIGRhdGEgaXMgZ2V0dGluZyB0b28gbGFyZ2UgKD41TUIpLCBrZWVwIG9ubHkgcmVjZW50IGl0ZW1zXG5cdFx0XHRpZiAoc2l6ZW9mKHNlcmlhbGl6ZWQpIC8gKDEwMjQgKiAxMDI0KSA+IDUpIHtcblx0XHRcdFx0Y29uc3QgcmVjZW50RGF0YSA9IGRhdGEuc2xpY2UoLTEwMDApOyAvLyBLZWVwIGxhc3QgMTAwMCBpdGVtc1xuXHRcdFx0XHRsb2NhbFN0b3JhZ2Uuc2V0SXRlbShrZXksIEpTT04uc3RyaW5naWZ5KHJlY2VudERhdGEpKTtcblx0XHRcdFx0Y29uc29sZS53YXJuKFxuXHRcdFx0XHRcdGBTdG9yYWdlIHNpemUgZXhjZWVkZWQgZm9yICR7a2V5fSwga2VlcGluZyByZWNlbnQgJHtyZWNlbnREYXRhLmxlbmd0aH0gaXRlbXNgXG5cdFx0XHRcdCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRsb2NhbFN0b3JhZ2Uuc2V0SXRlbShrZXksIHNlcmlhbGl6ZWQpO1xuXHRcdFx0fVxuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRjb25zb2xlLmVycm9yKGDinYwgRmFpbGVkIHRvIHN0b3JlICR7a2V5fTpgLCBlcnJvcik7XG5cdFx0XHR0aGlzLmhhbmRsZVN0b3JhZ2VFcnJvcihrZXksIGRhdGEpO1xuXHRcdH1cblx0fVxuXG5cdGdldERhdGE8VD4oa2V5OiBzdHJpbmcpOiBUW10ge1xuXHRcdHRyeSB7XG5cdFx0XHRjb25zdCBkYXRhID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oa2V5KTtcblx0XHRcdHJldHVybiBkYXRhID8gSlNPTi5wYXJzZShkYXRhKSA6IFtdO1xuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRjb25zb2xlLmVycm9yKGDinYwgRmFpbGVkIHRvIHJldHJpZXZlICR7a2V5fTpgLCBlcnJvcik7XG5cdFx0XHRyZXR1cm4gW107XG5cdFx0fVxuXHR9XG5cblx0YXBwZW5kRGF0YTxUPihrZXk6IHN0cmluZywgbmV3SXRlbTogVCk6IHZvaWQge1xuXHRcdGNvbnN0IGV4aXN0aW5nID0gdGhpcy5nZXREYXRhPFQ+KGtleSk7XG5cdFx0ZXhpc3RpbmcucHVzaChuZXdJdGVtKTtcblx0XHR0aGlzLnN0b3JlRGF0YShrZXksIGV4aXN0aW5nKTtcblx0fVxuXG5cdHVwZGF0ZVVzZXJCZWhhdmlvcihiZWhhdmlvcjogVXNlckJlaGF2aW9yTWV0cmljcyk6IHZvaWQge1xuXHRcdGxvY2FsU3RvcmFnZS5zZXRJdGVtKFxuXHRcdFx0dGhpcy5TVE9SQUdFX0tFWVMuVVNFUl9CRUhBVklPUixcblx0XHRcdEpTT04uc3RyaW5naWZ5KGJlaGF2aW9yKVxuXHRcdCk7XG5cdH1cblxuXHRnZXRVc2VyQmVoYXZpb3IoKTogVXNlckJlaGF2aW9yTWV0cmljcyB8IG51bGwge1xuXHRcdGNvbnN0IGRhdGEgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSh0aGlzLlNUT1JBR0VfS0VZUy5VU0VSX0JFSEFWSU9SKTtcblx0XHRyZXR1cm4gZGF0YSA/IEpTT04ucGFyc2UoZGF0YSkgOiBudWxsO1xuXHR9XG5cblx0Ly8gUXVldWUgZGF0YSBmb3Igc3luY2luZ1xuXHRxdWV1ZUZvclN5bmMoc2Vzc2lvbklkOiBzdHJpbmcpOiB2b2lkIHtcblx0XHRjb25zdCBwYXlsb2FkOiBBbmFseXRpY3NQYXlsb2FkID0ge1xuXHRcdFx0c2Vzc2lvbklkLFxuXHRcdFx0ZXZlbnRzOiB0aGlzLmdldERhdGE8RHJhd2luZ0V2ZW50Pih0aGlzLlNUT1JBR0VfS0VZUy5FVkVOVFMpLFxuXHRcdFx0bmV0d29ya01ldHJpY3M6IHRoaXMuZ2V0RGF0YTxOZXR3b3JrTWV0cmljcz4odGhpcy5TVE9SQUdFX0tFWVMuTkVUV09SSyksXG5cdFx0XHRwZXJmb3JtYW5jZU1ldHJpY3M6IHRoaXMuZ2V0RGF0YTxQZXJmb3JtYW5jZU1ldHJpY3M+KFxuXHRcdFx0XHR0aGlzLlNUT1JBR0VfS0VZUy5QRVJGT1JNQU5DRVxuXHRcdFx0KSxcblx0XHRcdHVzZXJCZWhhdmlvcjogdGhpcy5nZXRVc2VyQmVoYXZpb3IoKSB8fCAoe30gYXMgVXNlckJlaGF2aW9yTWV0cmljcyksXG5cdFx0XHR0aW1lc3RhbXA6IERhdGUubm93KCksXG5cdFx0fTtcblxuXHRcdGNvbnN0IHN5bmNRdWV1ZSA9IHRoaXMuZ2V0RGF0YTxBbmFseXRpY3NQYXlsb2FkPihcblx0XHRcdHRoaXMuU1RPUkFHRV9LRVlTLlNZTkNfUVVFVUVcblx0XHQpO1xuXHRcdHN5bmNRdWV1ZS5wdXNoKHBheWxvYWQpO1xuXHRcdHRoaXMuc3RvcmVEYXRhKHRoaXMuU1RPUkFHRV9LRVlTLlNZTkNfUVVFVUUsIHN5bmNRdWV1ZSk7XG5cdH1cblxuXHRnZXRTeW5jUXVldWUoKTogQW5hbHl0aWNzUGF5bG9hZFtdIHtcblx0XHRyZXR1cm4gdGhpcy5nZXREYXRhPEFuYWx5dGljc1BheWxvYWQ+KHRoaXMuU1RPUkFHRV9LRVlTLlNZTkNfUVVFVUUpO1xuXHR9XG5cblx0Y2xlYXJTeW5jZWREYXRhKHRpbWVzdGFtcDogbnVtYmVyKTogdm9pZCB7XG5cdFx0Y29uc3QgcXVldWUgPSB0aGlzLmdldFN5bmNRdWV1ZSgpLmZpbHRlcihcblx0XHRcdChpdGVtKSA9PiBpdGVtLnRpbWVzdGFtcCA+IHRpbWVzdGFtcFxuXHRcdCk7XG5cdFx0dGhpcy5zdG9yZURhdGEodGhpcy5TVE9SQUdFX0tFWVMuU1lOQ19RVUVVRSwgcXVldWUpO1xuXHR9XG5cblx0Y2xlYXJMb2NhbERhdGEoKTogdm9pZCB7XG5cdFx0T2JqZWN0LnZhbHVlcyh0aGlzLlNUT1JBR0VfS0VZUykuZm9yRWFjaCgoa2V5KSA9PiB7XG5cdFx0XHRpZiAoa2V5ICE9PSB0aGlzLlNUT1JBR0VfS0VZUy5TWU5DX1FVRVVFKSB7XG5cdFx0XHRcdGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKGtleSk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH1cblxuXHRwcml2YXRlIGhhbmRsZVN0b3JhZ2VFcnJvcjxUPihrZXk6IHN0cmluZywgZGF0YTogVFtdKTogdm9pZCB7XG5cdFx0Ly8gVHJ5IHRvIGNsZWFyIG9sZCBkYXRhIGFuZCByZXRyeVxuXHRcdGlmIChBcnJheS5pc0FycmF5KGRhdGEpICYmIGRhdGEubGVuZ3RoID4gMTAwKSB7XG5cdFx0XHRjb25zdCByZWR1Y2VkRGF0YSA9IGRhdGEuc2xpY2UoLTUwKTtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdGxvY2FsU3RvcmFnZS5zZXRJdGVtKGtleSwgSlNPTi5zdHJpbmdpZnkocmVkdWNlZERhdGEpKTtcblx0XHRcdFx0Y29uc29sZS53YXJuKGBSZWR1Y2VkICR7a2V5fSBkYXRhIHNpemUgYW5kIHJldHJpZWRgKTtcblx0XHRcdH0gY2F0Y2gge1xuXHRcdFx0XHRjb25zb2xlLmVycm9yKGBDcml0aWNhbCBzdG9yYWdlIGVycm9yIGZvciAke2tleX1gKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRnZXRTdG9yYWdlSW5mbygpIHtcblx0XHRjb25zdCBpbmZvID0gT2JqZWN0LmVudHJpZXModGhpcy5TVE9SQUdFX0tFWVMpLm1hcCgoW25hbWUsIGtleV0pID0+IHtcblx0XHRcdGNvbnN0IGRhdGEgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShrZXkpO1xuXHRcdFx0Y29uc3Qgc2l6ZSA9IGRhdGEgPyBuZXcgQmxvYihbZGF0YV0pLnNpemUgOiAwO1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0bmFtZSxcblx0XHRcdFx0a2V5LFxuXHRcdFx0XHRzaXplOiBgJHsoc2l6ZSAvIDEwMjQpLnRvRml4ZWQoMil9IEtCYCxcblx0XHRcdFx0aXRlbXM6IGRhdGEgPyBKU09OLnBhcnNlKGRhdGEpLmxlbmd0aCB8fCAxIDogMCxcblx0XHRcdH07XG5cdFx0fSk7XG5cdFx0cmV0dXJuIGluZm87XG5cdH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQW5hbHl0aWNzTG9jYWxTdG9yYWdlTWFuYWdlcjtcbiJdLCJuYW1lcyI6WyJzaXplb2YiLCJBbmFseXRpY3NMb2NhbFN0b3JhZ2VNYW5hZ2VyIiwic3RvcmVEYXRhIiwia2V5IiwiZGF0YSIsInNlcmlhbGl6ZWQiLCJKU09OIiwic3RyaW5naWZ5IiwiY29uc29sZSIsImxvZyIsInJlY2VudERhdGEiLCJzbGljZSIsImxvY2FsU3RvcmFnZSIsInNldEl0ZW0iLCJ3YXJuIiwibGVuZ3RoIiwiZXJyb3IiLCJoYW5kbGVTdG9yYWdlRXJyb3IiLCJnZXREYXRhIiwiZ2V0SXRlbSIsInBhcnNlIiwiYXBwZW5kRGF0YSIsIm5ld0l0ZW0iLCJleGlzdGluZyIsInB1c2giLCJ1cGRhdGVVc2VyQmVoYXZpb3IiLCJiZWhhdmlvciIsIlNUT1JBR0VfS0VZUyIsIlVTRVJfQkVIQVZJT1IiLCJnZXRVc2VyQmVoYXZpb3IiLCJxdWV1ZUZvclN5bmMiLCJzZXNzaW9uSWQiLCJwYXlsb2FkIiwiZXZlbnRzIiwiRVZFTlRTIiwibmV0d29ya01ldHJpY3MiLCJORVRXT1JLIiwicGVyZm9ybWFuY2VNZXRyaWNzIiwiUEVSRk9STUFOQ0UiLCJ1c2VyQmVoYXZpb3IiLCJ0aW1lc3RhbXAiLCJEYXRlIiwibm93Iiwic3luY1F1ZXVlIiwiU1lOQ19RVUVVRSIsImdldFN5bmNRdWV1ZSIsImNsZWFyU3luY2VkRGF0YSIsInF1ZXVlIiwiZmlsdGVyIiwiaXRlbSIsImNsZWFyTG9jYWxEYXRhIiwiT2JqZWN0IiwidmFsdWVzIiwiZm9yRWFjaCIsInJlbW92ZUl0ZW0iLCJBcnJheSIsImlzQXJyYXkiLCJyZWR1Y2VkRGF0YSIsImdldFN0b3JhZ2VJbmZvIiwiaW5mbyIsImVudHJpZXMiLCJtYXAiLCJuYW1lIiwic2l6ZSIsIkJsb2IiLCJ0b0ZpeGVkIiwiaXRlbXMiLCJMQVNUX1NZTkMiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/util/AnalyticsLocalStorageManager.ts\n"));

/***/ })

});